<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>题库</title>
    <link href="/zhouyuchen/2023/12/27/%E9%A2%98%E5%BA%93/"/>
    <url>/zhouyuchen/2023/12/27/%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>并行计算科学主要研究的是空间上的并行问题。空间上的并行导致了两类并行机的产生，按照Flynn的说法分为：A<br>    <strong>A 单指令流多数据流(SIMD) 和 多指令流多数据流(MIMD)</strong><br>    B 单指令流单数据流(SISD) 和 多指令流多数据流(MIMD)<br>    C 多指令流单数据流(MISD) 和 单指令流多数据流(SIMD)<br>    D 多指令流单数据流(MISD) 和 单指令流单数据流(SISD)</p><p>并行的层次按照从粗粒度到细粒度的顺序排列为：D<br>    A 程序级→子程序级→操作级→微操作级→语句级<br>    B 程序级→语句级→子程序级→操作级→微操作级<br>    C 微操作级→操作级→语句级→子程序级→程序级<br>    <strong>D 程序级→子程序级→语句级→操作级→微操作级</strong></p><p>下列并行计算机系统结构中属于访存模型的是：C<br>    A MIMD (Multi-Instruction Multi-Data)<br>    B COW (Cluster of Workstation)<br>    <strong>C NORMA (No-Remote Memory Access)</strong><br>    D DSM (Distributed Shared Memory)</p><p>下面说法中<strong>不是</strong>并行程序设计难的原因的是：C<br>    A 技术先行，缺乏理论指导<br>    B 程序的语法/语义复杂，需要用户自己处理<br>    <strong>C 环境和工具的生长期较长, 缺乏代码可扩展和异构可扩展</strong><br>    D 并行语言缺乏代码可扩展和异构可扩展, 程序移植困难, 重写代码难度太大</p><p>下面哪一项是共享变量并行编程模型的典型代表：B<br>    A MPI        <strong>B OpenMP</strong><br>    C PVM（Parallel Virtual Machine）是一种用于并行计算的软件系统        </p><p>​    D HPF   HPF (High Performance Fortran) 是一种并行编程语言</p><p>下面哪一项<strong>不是</strong>MPI的派生数据类型方法：C<br>    A MPI_Type_contiguous() 连续复制的类型生成器<br>    B MPI_Type_vector() 向量数据类型的生成器<br>    <strong>C MPI_Type_index() 索引数据类型的生成器</strong>  <strong>indexed</strong><br>    D MPI_Type_struct() 结构数据类型的生成器</p><p>按通信的方向不同，<strong>组通信可分为三种</strong>，下面哪一项并<strong>不</strong>在其中：D<br>    A 一对多通信        B 多对一通信<br>    C 多对多通信        <strong>D 点对点通信</strong></p><p>下面关于MapReduce的说法中，哪一项是<strong>错误</strong>的：C<br>    A 简而言之，MapReduce是将一个大作业拆分为多个小作业的框架，用户需要做的是决定拆成多少份，以及定义作业本身。<br>    B MapReduce具有强大的并行处理能力，能够将一个庞大的数据分布到大规模的集群中进行分布式处理<br>    <strong>C Map/Reduce的容错能力较低，集群中某一个节点出现错误可能会对整个数据处理有不小的影响。</strong><br>    D MapReduce就是一个计算函数，对于迁移计算本身就比迁移数据更加快，更合理。</p><ol><li>第一台并行计算机ILLIAC  IV 于（C）年运行第一个应用程序。<br>a)    1972<br>b)    1974</li></ol><p>   <strong>c)    1976</strong><br>   d)    1981<br>2.    所有内存模块都由硬件进行了统一的编址，各个结点既可以<strong>直接访问局部内存</strong>单元，又可以<strong>直接访问其他结点</strong>的局部内存单元的并行体系结构是（A）。<br>   <strong>a)    DSM</strong><br>   b)    MPP<br>   c)    ASM<br>   d)    NOW<br>3.    <strong>SIMD</strong> 是现今大量使用的指令集，其含义是（C）。<br>   a)    各个进程在同一时间可以执行不同的指令<br>   b)    各个进程顺序执行不同指令<br>   c)    <strong>各个进程同一时间执行相同指令</strong><br>   d)    单个进程选择执行不用指令<br>4.    进程编组的目的是将需要交互的进程调度到一个组中，其中一个进程的组成员由（B）唯一确定。<br>   a)    机器唯一标识+组标识符+成员序号<br>   b)    <strong>组标识符+成员序号</strong><br>   c)    全局唯一标识符<br>   d)    机器唯一标识+成员需要<br>5.    并行度和并行粒度之间的关系是（A）。<br>   a)    <strong>并行度与并行粒度大小常互为倒数，增大粒度会减小并行度</strong>。<br>   b)    并行度会随着并行粒度的细分而增大。<br>   c)    并行粒度由用户确定，并行度由处理器确定。<br>   d)    增加并行度和并行粒度都会减小系统的开销。</p><p>3、MPI调用下列哪个函数可以获得当前进程标识（A ）。<br>A、<strong>MPI_COMM_RANK</strong>            B、MPI_COMM_SIZE<br>C、MPI_INIT                         D、MPI_SENDRECV<br>5、下列关于MPI的叙述中<strong>错误</strong>的是（    B）。<br>A、MPI定义的接口和现在已有的接口差别不能太大，但是允许扩展以提供更大的灵活性<br><strong>B、MPI是一种并行程序设计语言</strong></p><p>MPI（Message Passing  Interface）并不是一种编程语言，而是一种用于编写并行程序的标准和库。MPI定义了一组规范，用于在多台计算机之间进行消息传递，从而实现并行计算。MPI可以与多种编程语言结合使用，如C、C++、Fortran等，但它本身并不是一种编程语言。</p><p>C、MPI提供可靠的通信接口，用户不必处理通信失败<br>D、MPI提供的接口可以方便C语言和FORTRAN语言的调用</p><p>1、目前MPI不支持下列哪一门语言（ B）。<br>A、C语言<br>B、Java语言<br>C、C++语言<br>D、Fortran语言<br>2、下列哪一个不是目前MPI的主要实现（ D）<br>    A、MPICH        B、OpenMPI<br>    C、LAM        D、LAN 局域网<br>3、MPI调用下列哪个函数可以退出MPI系统（ C）。<br>A、MPI_COMM_RANK            B、MPI_COMM_SIZE<br>C、MPI_FINALIZE                 D、MPI_SENDRECV<br>4、下列并行的层次中哪个不是以并行粒度划分的（ D）。<br>A、程序级并行<br>B、语句级并行<br>C、操作级并行<br>D、算法级并行<br>5、下列关于MPI的叙述中正确的是（    C    ）。<br>A、MPI定义的接口和现在已有的接口可以差别太大，也允许扩展以提供更大的灵活性<br>B、MPI是一种并行程序设计语言<br>C、MPI提供可靠的通信接口，用户不必处理通信失败<br>D、MPI提供的接口可以方便C语言和JAVA语言的调用</p><p>1、在MPI中，大致可以划分出四种通信模式，以下哪个选项不属于MPI的通信模式（ B）。<br>A、标准模式<br><strong>B、缓存模式</strong><br>C、同步模式<br>D、就绪模式<br>2、MPI的消息接收函数与消息发送函数十分类似，但消息接收函数比消息发送函数的参数要多一个，多出的这个参数为（C ）<br>    A、flag        B、argc     <strong>C、status</strong>        D、steam<br>3、MPI调用下列哪个函数可以用于检测MPI环境是否已经初始化（D ）。<br>A、MPI_Type_contiguous            B、MPI_TEST<br>C、MPI_BCAST                     <strong>D、MPI_INITIALIZED</strong><br>4、对于MPI消息的标识Tag，以下说法<strong>不正确</strong>的是（ D）。<br>A、Tag可以区别同一进程的不同消息，使程序员以一种有序的方式处理到达的消息。<br>B、MPI用一个新概念“上下文”(context)对“tag”进行扩展。系统运行时分配，不允许统配。<br>C、tag在取值上有一个范围，不能随意取值。<br><strong>D、如果消息的收发操作发生在任意进程之间，那么接受和发送函数中的tag参数可以省略不写。</strong><br>5、下列关于MPI通信模式中的标准模式，以下说法中<strong>错误</strong>的是（D    ）。<br>A、由 MPI 系统来决定是先将消息拷贝至一个缓冲区然后立即返回 ，还是等待将数据发送出去后再返回。<br>B、MPI系统预留了一部分缓存空间，用于存放需要发送的消息。<br>C、当MPI要发送的消息大于预留的缓存空间大小时，MPI的标准收发操作会产生错误或是溢出。<br><strong>D、MPI的标准发送模式只需要有一个发送方即可，无需考虑是否有消息接收的接收方。</strong></p><p>1.关于并行计算算法设计，以下<strong>错误</strong>的选项是（C）<br>A 以 MIMD 为主<br>B 可扩展、可移植<br><strong>C 是小粒度任务级并行</strong><br>D 每个进程发挥单机性能</p><p>2.以下不属于并行计算机体系结构组成要素的是（D）<br>A 节点 B 互联网络 C 内存 <strong>D 进程</strong></p><p>3.以下关于并行算法错误的是（C）<br>A 适合在并行机上实现的算法<br>B 好的并行算法应充分发挥并行机计算机的潜在性能<br><strong>C 按并行进程执行顺序：同步并行算法、异步并行算法</strong>  （混合并行算法）<br>D 按计算任务：细粒度并行算法、中粒度并行算法、大粒度并行算法</p><ol start="4"><li>以下关于MPI说法<strong>错误</strong>的是（A）</li></ol><p><strong>A MPI标准所支持的数据类型为弱类型</strong><br>B MPI是一种消息传递编程模型，并成为这种编程模型的代表和事实上的标准。<br>C MPI并行程序设计采用提供并行库的方式<br>D MPI是一种标准或规范的代表。不是特指某一个对它的具体实现。</p><ol start="5"><li>以下不属于MPI六个基本函数的是（A）<br>A MPI_Initialized        B MPI_Init    C MPI_Finalize    D MPI_COMM_RANK</li></ol><h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>高性能计算机肯定是并行计算机。    √<br>并行算法按照计算任务可分为数值并行算法与非数值并行算法。    ×<br>并行计算机的体系结构在80年代趋于统一。    ×<br>集群系统中每一个节点都是一个完整的计算机。    √<br>对于资源高度共享的处理机，常称为紧耦合系统。    √<br>MPI标准所支持的数据类型为弱类型。    ×<br>除了MPI_Init()，其余所有的MPI函数应该在其后被调用。× MPI_Initialized<br>不能用一个程序实现消息传递程序的两种方式。    ×<br>静态并行性指程序的结构以及进程的个数在运行之前就可确定。    √<br>并行度与并行粒度大小成正比关系: 增大粒度也会增大并行度。    ×<br>MPI消息传递过程分为消息装配、消息发送、消息拆卸三个阶段。    √<br>MPI预定义数据类型中MPI_BYTE和MPI_PACKED可以匹配任何以字节为单位的存储。√<br>同步模式中MPI_Ssend遵从三次握手协议。    √<br>MapReduce编程模型的思想是通过手动分割将要执行的问题(程序)、拆解成Map(映射)和Reduce(化简)的方式。    ×<br>对于复杂的查询，如多层嵌套的SQL语言，Map/Reduce并不支持。        √</p><ol><li>   并行程序能通过将任务分解到多个核心并行计算的方式加快任务完成，因此同一任务在相同硬件条件下总是并行程序计算更快。（X）</li><li>   基于消息传递的并行程序，每个并行进程均有自己独立的地址空间，相互之间访问不能直接进行，必须通过显式的消息传递来实现。（√）</li><li>   在调用MPI_Finalize函数后，表明并行代码的结束,结束所有进程。（X）除了主进程</li><li>   每个MPI消息都有相应的数据类型，用于MPI消息在处理和传递过程中，独立于某一具体的语言和平台体系结构，其分为预定义数据类型和派生数据类型。（√）</li><li>   使用缓冲模式MPI_Bsend发送消息，其通信缓冲区由MPI系统保证，用户仅需将数据写入缓冲区即可。（X）</li><li>   （F）并行程序能通过将任务分解到多个核心并行计算的方式加快任务完成，因此同一任务在相同硬件条件下总是并行程序计算更快。</li><li>   （T ）高性能计算机肯定是并行计算机。</li><li>   （ F）使用缓冲模式MPI_Bsend发送消息，其通信缓冲区由MPI系统保证，用户仅需将数据写入缓冲区即可。  <strong>要确保缓存区大小足够容纳</strong></li></ol><ol><li><p>（F ）MPI是一门并行语言。</p></li><li><p>（T ）目前支持MPI的语言有C，C++，Fortran语言。</p></li><li><p>（T ）MPI消息是由消息信封和和消息内容组成</p></li><li><p>（ T）MPI标准所支持的数据类型为强类型。</p></li><li><p>（ F）MPI_Comm_rank（）函数的作用是获得进程的个数。 </p></li><li><p>（ F）MPI（Message Passing Interface），可以视为是一种接口。</p></li><li><p>（ T）对称式共享存储指的是，任意处理器可直接访问任意内存地址,且访问延迟、带宽、几率都是等价的，系统是对称的。</p></li><li><p>（ F）MPP（Massively Parallel Processor，大规模并行处理机）<br>每个结点均有自己的操作系统,但这些结点均没有独立的内存。</p><p>MPP系统是由多个处理节点组成的并行计算机系统，每个节点都具有自己的处理器、内存和存储器。这些节点通过高速互连网络进行通信和协调，以实现并行计算和数据处理。</p></li><li><p>（ T）MPI程序中在进程间通信传送的所有信息称为消息，一个MPI消息包括消息信封、消息内容两部分。</p></li><li><p>（ F）在MPI通信模式中，阻塞式消息传送允许Source == dest，也即消息的发送进程可以是消息的接收进程。 </p></li></ol><p>这是因为阻塞式消息传送是同步的操作，发送进程会等待接收进程接收消息后才能继续执行后续代码。如果发送进程和接收进程是同一个进程，那么它会一直等待自己去接收消息，导致死锁。</p><p>1.并行计算时间上的并行是指用多个处理器并发的执行计算（F）<br>2.我们常用的串行机也叫做单指令流单数据流（SISD）（T）<br>4.高性能计算机可以不是并行计算机（F）<br>5.并行算法设计以SIMD为主（F）</p><h1 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h1><p>1.所谓并行计算，分为<strong>时间上的并行</strong>和<strong>空间上的并行</strong>，前者指<strong>流水线技术</strong>，后者指用<strong>多个处理器并发的执行计算</strong>。<br>2.<strong>计算</strong>科学、传统的两种科学（即<strong>理论</strong>科学和<strong>实验</strong>科学），并列被认为是人类认识自然的三大支柱，他们彼此相辅相成地推动科学发展与社会进步。<br>3.MPI是一种<strong>消息传递编程模型</strong>；对于并行语言的实现方式，MPI并行程序设计采用的是<strong>提供并行库</strong>。<br>4.MPI并行程序的两种主要形式是<strong>对等模式</strong>和<strong>主从模式</strong>。<br>5.MPI消息包括<strong>消息信封</strong>和<strong>消息内容</strong>两部分。<br>6.SPMD编程模式的程序需要一份源代码。<br>    一个进程组成员由<strong>组标识符</strong>和<strong>成员序号</strong>唯一确定。<br>    并行程序的设计模型有<strong>隐式并行</strong>、<strong>数据并行</strong>、<strong>共享变量</strong>、<strong>消息传递</strong>四种。<br>7.MPI的数据类型分为<strong>预定义</strong>数据类型和<strong>派生</strong>数据类型。<br>    组通信的三大功能为<strong>通信、同步、计算</strong>。</p><p>4.利用MPI_Send可以发送数据，其函数为MPI_Send(buf,count, <strong>datatype</strong>, dest,<br>tag,comm)。</p><p>5.利用MPI_Recv可以接收数据，其函数为MPI_Send(buf,count, <strong>datatype</strong>, dest,<br>tag,comm,<strong>status</strong>)。</p><p>3.按进程间程序执行的顺序关系分类：同步算法、异步算法；独立并行算法；</p><ol><li>   MPI预定义了进程组和通信域，其中<strong>MPI_COMM_WORLD</strong>是指<strong>有效通信域句柄</strong>，包含元素为<strong>所有进程</strong>。</li><li>   并行的层次以并行粒度可分为<strong>程序级并行、子程序级并行、语句级并行、操作级并行、微操作级</strong>并行五层。</li><li>   <strong>加速比（</strong>speedup)是同一个任务在<strong>单处理器</strong>系统和<strong>并行处理器</strong>系统中运行消耗的时间的比率，用来衡量并行系统或程序并行化的性能和效果。</li></ol><p>1、使用MPI程序需要保证__MPI_Init__函数第一个被调用，__MPI_Finalize__函数被最终调用。<br>4、MPI程序中在进程间通信传送的所有信息称为消息。一个MPI消息包括__消息信封__和<strong>消息内容</strong>两部分。<br>2、并行计算机的组成要素有__结点、互联网络和内存。<br>3、Flynn提出指令流，数据流，和多倍性的概念，把不同的计算机分为4类，分别为SISD、SIMD、MISD和_MIMD__。<br>4、第一台并行计算机于1972年诞生于<strong>伊利诺伊</strong>大学。<br>5、并行计算机的结构模型有PVP、SMP、DSM、MPP和COW。</p><p>1、MPI程序常用__C__、__C++__、__Fortran__这三种语言进行编写。<br>3、在一个MPI程序中，<strong>size</strong>用于标识当前程序中的总进程数，<strong>rank</strong><strong>用于标识当前正在运行的进程，这两个变量均属于__整型（int）（数据类型）。<br>4、MPI最基本的通信模式是在一对进程之间进行的消息收发操作：一个进程发送消息，另一个进程接收消息，这种通信方式称为<strong>点对点通信模式</strong>。<br>5、MPI程序中为完成某个并行计算的所涉及多个进程，这些进程合在一起形成的进程组称之为__communicator</strong><br>6、均匀存储器访问：所有处理器<strong>均匀共享</strong>物理存储器，这里所谓均匀是指所有处理器对所有存储字具有相同的存取时间</p><h1 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h1><p>1.简述加DSM、MPP、NOW的特点</p><p> DSM （Distributed Shared Memory）分布式共享存储</p><p>以结点为单位，每个结点有一个或多个CPU ；专用的高性能互联网络连接； 单一的操作系统；单一的内存地址空间：所有内存模块都由硬件进行了统一的编址，各个结点既可以直接访问局部内存单元，又可以直接访问其他结点的局部内存单元；可扩展到上百个结点；支持消息传递、共享存储并行程序设计</p><p>MPP（Massively Parallel Processing）大规模并行处理结构</p><p> 每个结点相对独立，有一个或多个微处理器</p><p> 每个结点均有自己的操作系统</p><p> 各个结点自己独立的内存，避免内存访问瓶颈</p><p> 各个结点只能访问自己的内存模块</p><p> 扩展性较好</p><p>NOW（Network of Workstations）工作站机群</p><p> 每个结点都是一个完整的工作站，有独立的硬盘与UNIX系统</p><p> 结点间通过低成本的网络（如千兆以太网）连接</p><p> 每个结点安装消息传递并行程序设计软件，实现通信、负载平衡等</p><p> 投资风险小、结构灵活、可扩展性强、通用性好、异构能力强，被大量中小型计算用户和科研院校所采用</p><p>2.集群的概念及集群系统的分类</p><p>集群是一组独立计算机(结点)的结合体，结点间通过高性能的网络相连，各结点除了作为一个单一的计算资源供用户使用外，还可以协同工作，并表示为一个单一的、集中的计算资源，供并行计算使用。集群是一种造价低廉，易于构建并且具有较好可扩展性的体系结构。</p><p>集群系统按功能和结构可以分为如下四类：(1)高可用性集群系统；(2)负载均衡集群系统；(3)高性能集群系统；(4)虚拟化集群系统</p><p>3.并行计算的四类设计模型</p><p>隐式并行、数据并行、共享变量、消息传递；</p><p>(1)隐式并行：程序员用熟悉的串行语言编码，由编译器或者运行支持系统自动转化为并行代码，其特点是语义简单、可移植性好，单线程，易于调试和验证正确性，但效率很低。</p><p>(2)数据并行：数据并行是SIMD(单指令多数据流)的自然模型，是局部计算和数据选路操作。其特点是单线程、并行操作于聚合数据结构(数组)，松散同步，单一地址空间，隐式交互作用和显式数据分布。</p><p>(3)共享变量：共享变量是PVP，SMP，DSM的自然模型。其特点是多线程，异步，单一地址空间，显式同步，隐式数据分布，隐式通信。</p><p>(4)消息传递：消息传递是MPP,COW的自然模型。其特点是多线程，异步，多地址空间，显式同步，显式通信，显式数据映射和负载分配。</p><ol start="4"><li>是什么是MPI</li></ol><p>MPI是一个库，而不是一门语言</p><p>MPI是一种标准或规范的代表，而不特指某一个对它的具体实现</p><p>MPI是一种消息传递编程模型，并成为这种编程模型的代表和事实上的标准</p><p>5.并行计算的定义和主要目的</p><p>定义：并行计算是指同时对多个任务或多条指令、或对多个数据项进行处理。完成此项处理的计算机系统称为并行计算机系统，它是将多个处理器（可以几个、几十个、几千个、几万个等）通过网络连接以一定的方式有序地组织起来（一定的连接方式涉及网络的互联拓扑、通信协议等，而有序的组织则涉及操作系统、中间件软件等）。</p><p>并行计算的主要目的：</p><p>一是为了提供比传统计算机快的计算速度；</p><p>二是解决传统计算机无法解决的问题。</p><p>6.MPI中6个常用函数的基本功能</p><p>MPI_INIT 初始化MPI</p><p>MPI_FINALIZE 终止MPI</p><p>MPI_COMM_SIZE 确定进程的数目</p><p>MPI_COMM_RANK 确定进程的序号</p><p>MPI_SEND 发送一条信息</p><p>MPI_RECV 就收一条信息</p><p>7.什么是并行计算机、并行计算机的组成部分</p><p>并行计算机是由一组处理单元组成的，这组处理单元通过相互之间的通信与协作，以更快的速度共同完成一项大规模的计算任务。</p><p>并行计算机的组成部分：计算节点和节点间的通信与协作机制。</p><ol start="8"><li>MPI的特点</li></ol><p>基于消息传递的通信机制</p><p>结合串行语言的并行库</p><p>支持Fortran、C和C++常用串行语言</p><p>可移植性好</p><p>程序设计方式灵活、简单</p><ol><li>对于可以执行并行计算的任务，通常表现出哪些特征？</li></ol><p> （1）可以工作分离成离散部分，有助于同时解决； </p><p> （2）随时并及时地执行多个程序指令； </p><p> （3）多计算资源下解决问题的耗时要少于单个计算资源下的耗时。</p><ol start="2"><li>相较于串行计算，并行计算的挑战有哪些？</li></ol><p>  （1）相对于先进的串行编程环境，并行编译器和调试器落后，自动并行编译器满足不了程序并行化的要求。</p><p>  （2）串行编程有着冯.诺伊曼模型，而并行模型多样化，没有统一的标准。</p><p>  （3）对于串行程序而言，依托稳定的环境可较为低成本的开发通用计算程序，可以移植性好，而并行程序通常是针对某一特定问题的特殊解，通用性差。</p><p>  （4）相对于串行计算，熟悉并行编程的从业人员较少</p><ol start="3"><li>并行编程有多种实现方式，请列举并说明各个方式。</li></ol><p>​    （1）设计全新的并行语言。</p><p>​    （2）扩展串行语言的语法，使其支持并行程序特征。</p><p>​    （3）为串行语言提供可调用的并行库。</p><p>请列举你知道的并行计算框架？(要写中文含义)</p><p>​    PVP(Parallel Vector Processor，并行向量处理机)</p><p>​    SMP(Symmetric Multiprocessor，对称多处理机)</p><p>​    DSM(Distributed Shared Memory，分布式共享存储)</p><p>​    MPP(Massively Parallel Processor，大规模并行处理机)</p><p>​    NOW(Network of Workstation) 或 COW(Cluster of Workstation) 集群工作站</p><p>并行语言的实现方式？</p><p>​    设计全新的并行语言</p><p>​    扩展串行语言语法，使其支持并行特征</p><p>​    为串行语言提供可调用的并行库</p><p>请写出MPI最基本的六个函数？(不需要写参数)</p><p>​    MPI_Init()</p><p>​    MPI_Comm_size()</p><p>​    MPI_Comm_rank()</p><p>​    MPI_Send()</p><p>​    MPI_Recv()</p><p>​    MPI_Finalize()</p><p>请写出下图中函数的参数的含义？</p><p><img src="/zhouyuchen/2023/12/27/%E9%A2%98%E5%BA%93/clip_image002.png"> </p><p>请完成下面的表格？</p><table><thead><tr><th>通信模式</th><th>发送</th><th>接收</th></tr></thead><tbody><tr><td>标准通信模式</td><td>MPI_Send</td><td>MPI_Recv</td></tr><tr><td>缓存通信模式</td><td>MPI_Bsend</td><td>MPI_Recv</td></tr><tr><td>同步通信模式</td><td>MPI_Ssend</td><td>MPI_Recv</td></tr><tr><td>就绪通信模式</td><td>MPI_Rsend</td><td>MPI_Recv</td></tr></tbody></table><p>1、基于编程语言的并行计算的实现方式有哪些？（本小题5分）</p><p>答：（1）设计全新的并行语言。（1分）</p><p>​    （2）扩展串行语言的语法，使其支持并行程序特征。（2分）</p><p>​    （3）为串行语言提供可调用的并行库。（2分）</p><p>2、详述并行计算的四类设计模型。（本小题10分）</p><p>答：隐式并行、数据并行、共享变量、消息传递；</p><p>(1)隐式并行：其特点是语义简单、可移植性好，单线程，易于调试和验证正确性，但效率很低。（2.5分）</p><p>(2)数据并行：其特点是单线程、并行操作于聚合数据结构(数组)，松散同步，单一地址空间，隐式交互作用和显式数据分布。（2.5分）</p><p>(3)共享变量：其特点是多线程，异步，单一地址空间，显式同步，隐式数据分布，隐式通信。（2.5分）</p><p>(4)消息传递：其特点是多线程，异步，多地址空间，显式同步，显式通信，显式数据映射和负载分配。（2.5分）</p><p>3、相较于串行计算，并行计算的挑战有哪些？最少答四个挑战点（本小题10分）</p><p>答：（1）相对于先进的串行编程环境，并行编译器和调试器落后，自动并行编译器满足不了程序并行化的要求。（2.5分）</p><p>（2）串行编程有着冯.诺伊曼模型，而并行模型多样化，没有统一的标准。（2.5分）</p><p>（3）对于串行程序而言，依托稳定的环境可较为低成本的开发通用计算程序，可以移植性好，而并行程序通常是针对某一特定问题的特殊解，通用性差。（2.5分）</p><p>（4）相对于串行计算，熟悉并行编程的从业人员较少。（2.5分）</p><p>4、并行程序设计方式主要有哪几种并分别说明。（本小题5分）</p><p>答：实现并行编程常见方法有以下三种。但三者可混合使用，如对以SMP为节点的Cluster来说，可以在节点间进行消息传递，在节点内进行共享变量编程。（2分）</p><p>（1）线程模型：OpenMP、POSIX。（1分）</p><p>（2）消息传递模型：PVM（Parallel Virtual Machine Computing）、MPI（Message Passing Interface）。（1分）</p><p>（3）数据并行模型：HPF。（1分）</p><p>1、MPI程序一般分为几个部分？（本小题5分）</p><p>答：（1）头文件。（1分）</p><p>​    （2）变量声明（1分）</p><p>​    （3）程序开始（1分）</p><p>（4）程序体（1分）</p><p>（5）程序结束（1分）</p><p>2、详述并行计算机的5中结构模型，并写出一个各类模型中具有代表性的并行机。（本小题10分）</p><p>答：PVP、SMP、DSM、MPP、COW</p><p>(1)PVP是并行向量处理机，代表机器有银河Ⅰ（2分）</p><p>(2)SMP是共享存储对称多处理机，具有单一操作系统管理，具有共享内存及计算机的其他资源的特点，代表机器有曙光一号（2分）</p><p>(3)DSM是分布式共享存储，具有单一的操作系统和共享内存的特点，代表机器有origin3000（2分）</p><p>(4)MPP是大规模并行处理机，每个节点都拥有自己的操作系统，独立的内存。代表机器有IBM SP2（2分）</p><p>(5)COW是集群工作站，每个节点都是一个完整的计算机，每个节点通过高性能网络互相连接，代表机器有曙光2000（2分）</p><p>3、MPI程序中的输出语句和一般串行程序中的输出语句的执行结果有什么不同？不同进程对同一个内容输出，其顺序是什么？（本小题5分）</p><p>答：（1）MPI程序中的输出语句每一个进程都执行，执行时有几个进程就有几条输出语句，而串行程序中的输出语句只有本进程输出的结果。（3分）</p><p>（2）不同的进程对同一个内容输出，其顺序的随机的。（2分）</p><p>4、详述并行计算的四类设计模型。（本小题10分）</p><p>答：隐式并行、数据并行、共享变量、消息传递；</p><p>(1)隐式并行：其特点是语义简单、可移植性好，单线程，易于调试和验证正确性，但效率很低。（2.5分）</p><p>(2)数据并行：其特点是单线程、并行操作于聚合数据结构(数组)，松散同步，单一地址空间，隐式交互作用和显式数据分布。（2.5分）</p><p>(3)共享变量：其特点是多线程，异步，单一地址空间，显式同步，隐式数据分布，隐式通信。（2.5分）</p><p>(4)消息传递：其特点是多线程，异步，多地址空间，显式同步，显式通信，显式数据映射和负载分配。（2.5分）</p><p>1、Cluster：由多个组成的系统，每个节点都是一个完整的计算机，各个节点通过高性能网络相互连接。 （5分）</p><p>2、point to point communications：MPI最基本的通信模式：一对进程之间进行的消息收发操作，一个进程发送消息，另一个进程接收消息。（5分）</p><p>3、Speedup：是同一个任务在单处理器系统和并行处理器系统中运行消耗的时间的比率（5分）</p><p>4、并行度(Degree of Parallelism, DOP):同时执行的分进程数。（2分）并行粒度(Granularity): 两次并行或交互操作之间所执行的计算负载.（3分）</p><p>1、写出MPI编程中最常用的六大函数，并分别简述它们的功能。（本小题10分）</p><p>答：（1）MPI_Init()：该函数指示系统完成所有初始化工作，以备对后续MPI库的调用进行处理。（2分）</p><p>（2）MPI_Comm_rank()：获取一个通信域中的正在运行的进程（1分）</p><p>（3）MPI_Comm_size()：获取一个通信域中的进程总数。（1分）</p><p>（4）MPI_Finalize()：用于释放MPI程序所占用的系统资源，结束MPI程序。（2分）</p><p>（5）MPI Send()：用于某一个进程向另一个进程发送消息。（2分）</p><p>（6）MPI_Recv()：用于一个进程接收另一个发送的消息。（2分）</p><p>2、简要叙述：什么是MPI，MPI具有哪些特点（本小题5分）</p><p>答：Message Passing Interface(消息传递接口):是消息传递函数库的标准规范。（2分）</p><p>特点：（1）基于消息传递的通信机制 （3分 每答出1点 算1分）</p><p>（2）结合串行语言的并行库</p><p>（3）支持Fortran、C和C++常用串行语言</p><p>（4）可移植性好</p><p>（5）程序设计方式灵活、简单</p><p>（6）高性能</p><p>（7）简洁性</p><p>3、简述Map/Reduce编程模型的工作原理（本小题5分）</p><p>答：Map/Reduce编程模型的原理是：</p><p>（1）利用一个输入key/value pair集合来产生一个输出的key/value pair集合。Map/Reduce库的用户用两个函数表达这个计算：Map和Reduce。（3分）</p><p>（2）用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合。Map/Reduce库把所有具有相同中间key值I的中间value值集合在一起后传递给reduce函数。（1分）</p><p>（3）用户自定义的Reduce函数接受一个中间key的值I和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。（1分）</p><p>4、在访存模型中，还存在三种存取结构UMA、NUMA、NORMA，请分别简述这三种结构。（本小题5分）</p><p>答：（1）均匀存储器访问（UMA－Uniform Memory Access）：所有处理器均匀共享物理存储器，这里所谓均匀是指所有处理器对所有存储字具有相同的存取时间（2分）</p><p>（2）非均匀存储器访问(NUMA—Nonuniform Memory Access)：被共享的存储器在物理上是分布在所有的处理机中的，其所有本地存储器的集合就组成了全局地址空间。（2分）</p><p>（3）非远程存储器访问(NORMA — No-Remote Memory Access)：所有存储器都是私有的，仅能由其处理器所访问。（1分）</p><p>5、请简要叙述MPI的四种通信模式（本小题5分）</p><p>（1）标准模式：由MPI系统决定是等待将数据发送出去后返回，还是将消息拷贝至缓冲区然后立即返回。此时的消息发送由MPI系统在后台进行大部分MPI系统会预留一定缓冲区，当发送消息的长度小于预留缓冲区大小时，会将消息缓存然后立即返回。否则则当消息部分或全部发送完毕后返回。（2分）</p><p>（2）缓冲模式：MPI系统将消息拷贝至用户提供的缓冲区，然后立即返回；消息发送由MPI系统在后台进行，用户必须保证缓冲区的大小足够容下采用缓冲模式发送的消息 （1分）</p><p>（3）同步模式：在标准模式的基础上，要求确认接收方已经开始接收后，函数调用才返回，接收方接收该消息的缓冲区已准备好，不需要附加的系统缓冲区。（1分）</p><p>（4）就绪模式：在标准模式的基础，要求消息的发送操作开始前，已经存在对应的接收操作。（1分）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>1.下列mpi程序运行时要求启动4个进程，每个进程要求获取自己的进程号、进程运行所在的机器名称、启动的进程个数并输出。请补充适当的mpi函数.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MASTER 0</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc，<span class="hljs-type">char</span> *argv[])</span>{<br><br><span class="hljs-type">int</span> numtasks,taskid，len;<br><br><span class="hljs-type">int</span> numtasks,taskid,len；<br><br><span class="hljs-type">char</span> hostname[MPI_MAX_PROCESSOR_NAME];<br><br>MPI_Init(&amp;argc,&amp;argv);<br><br>MPI_Comm_size(MPI_COMM_WORLD,&amp;numtasks);<br><br>MPI_Comm_rank (MPI_COMM_WORLD,&amp;taskid) ;<br><br>MPI_Get_processor_name (hostname,&amp;len);<br><br><span class="hljs-built_in">printf</span> (<span class="hljs-string">"Hello from task %d on %s ! \n"</span>, taskid, hostname);<br><br><span class="hljs-keyword">if</span> (taskid == MASTER)<br><br><span class="hljs-built_in">printf</span> (<span class="hljs-string">"MASTER: Number of MPI tasks is: %d \n"</span> , numtasks);<br><br>MPI_Finalize();<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>2.编程求Sum=1+2+…+N.(要求使用MPI)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br>Int <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br><br>{<br><br><span class="hljs-type">int</span> sum,i,total;<br><br><span class="hljs-type">int</span> numprocs,myid;<br><br>MPI_Init(&amp;argc,&amp;argv);<br><br>MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);<br><br>MPI_Comm_rank (MPI_COMM_WORLD,&amp;myid) ;<br><br><span class="hljs-keyword">for</span>(i=myid+<span class="hljs-number">1</span>;i&lt;=N;i+=numprocs)<br><br>sum+=i;<br><br>MPI_Reduce(∑,&amp;total,<span class="hljs-number">1</span>,MPI_INT,MPI_SUM,<span class="hljs-number">0</span>,MPI_COMM_WORLD);<br><br>If(myid==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(“sum=%d\n”,tatal);<br><br>MPI_Finalize();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br> <br><br>}<br></code></pre></td></tr></tbody></table></figure><p>3.补全以下程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span> </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span> </span><br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_num</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *num_point,<span class="hljs-type">int</span> my_rank,MPI_Comm comm)</span>; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_pi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> num_point,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* num_in_cycle,</span><br><span class="hljs-params"></span><br><span class="hljs-params"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* local_num_point,<span class="hljs-type">int</span> comm_sz,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *total_num_in_cycle,MPI_Comm comm,<span class="hljs-type">int</span> my_rank)</span>; <br><br> <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>** argv)</span>{ <br><br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> num_in_cycle,num_point,total_num_in_cycle,local_num_point; <br><br>  <span class="hljs-type">int</span> my_rank,comm_sz; <br><br>  <span class="hljs-type">double</span> begin,end; <br><br>  MPI_Comm comm; <br><br>  **MPI_Init(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);**<span class="hljs-comment">//初始化 </span><br><br>  comm=MPI_COMM_WORLD; <br><br>   **MPI_Comm_size(comm,&amp;comm_sz);**<span class="hljs-comment">//得到进程总数 </span><br><br>  **MPI_Comm_rank(comm,&amp;my_rank);**<span class="hljs-comment">//得到进程编号 </span><br><br> <br><br>  read_num(&amp;num_point,my_rank,comm);<span class="hljs-comment">//读取输入数据 </span><br><br>  begin=MPI_Wtime();<br><br>  compute_pi(num_point,&amp;num_in_cycle,&amp;local_num_point,comm_sz,&amp;total_num_in_cycle,comm,my_rank);<br><br>  end=MPI_Wtime(); <br><br>  <span class="hljs-keyword">if</span>(my_rank==<span class="hljs-number">0</span>){ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Elapsing time: %fs\n"</span>,end-begin); } <br><br>   **MPI_Finalize();** <span class="hljs-comment">//释放资源</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><br>} <br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_num</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* num_point,<span class="hljs-type">int</span> my_rank,MPI_Comm comm)</span>{ <br><br>  **<span class="hljs-keyword">if</span>(my_rank==<span class="hljs-number">0</span>)** <span class="hljs-comment">//指定主进程执行</span><br><br>​    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"please input num in sqaure \n"</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,num_point); <br><br>  }<br><br>​    MPI_Bcast(num_point,<span class="hljs-number">1</span>,MPI_LONG_LONG,<span class="hljs-number">0</span>,comm); <br><br>} <br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_pi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> num_point,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* num_in_cycle,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* local_num_point,<span class="hljs-type">int</span> comm_sz,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *total_num_in_cycle,MPI_Comm comm,<span class="hljs-type">int</span> my_rank)</span>{<br><br>  *num_in_cycle=<span class="hljs-number">0</span>; <br><br>  *local_num_point=num_point/comm_sz; <br><br>  <span class="hljs-type">double</span> x,y,distance_squared; <br><br>  srand(time(<span class="hljs-literal">NULL</span>)); <br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; *local_num_point;i++){ <br><br>​    x=(<span class="hljs-type">double</span>)rand()/(<span class="hljs-type">double</span>)RAND_MAX; <br><br>​    x=x*<span class="hljs-number">2</span><span class="hljs-number">-1</span>; <br><br>​    y=(<span class="hljs-type">double</span>)rand()/(<span class="hljs-type">double</span>)RAND_MAX; <br><br>​    y=y*<span class="hljs-number">2</span><span class="hljs-number">-1</span>; <br><br>​    distance_squared=x*x+y*y; <br><br>​    <span class="hljs-keyword">if</span>(distance_squared&lt;=<span class="hljs-number">1</span>) <br><br>​      *num_in_cycle=*num_in_cycle+<span class="hljs-number">1</span>; <br><br>  }  <br><br>  MPI_Reduce(num_in_cycle,total_num_in_cycle,<span class="hljs-number">1</span>,MPI_LONG_LONG,MPI_SUM,<span class="hljs-number">0</span>,comm);<br><br>  <span class="hljs-keyword">if</span>(my_rank==<span class="hljs-number">0</span>){ <br><br>​    <span class="hljs-type">double</span> pi=(<span class="hljs-type">double</span>)*total_num_in_cycle/(<span class="hljs-type">double</span>)num_point*<span class="hljs-number">4</span>; <br><br>​    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the estimate value of pi is %lf\n"</span>,pi); <br><br>  } <br><br>}<br></code></pre></td></tr></tbody></table></figure><p>4.下面并行程序matrix.c的功能是利用3个进程计算两个3行3列的矩阵的乘积,请将空缺的代码补充完整，使得该程序能够编译运行并得出正确的结果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><br> <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br><br>{<br><br>​    <span class="hljs-type">int</span> process_rank, process_size;<br><br>​    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}, {<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>}};<br><br>​    <span class="hljs-type">int</span> b[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = {{<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>}, {<span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>}, {<span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>}};<br><br>​    <span class="hljs-type">int</span> c[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = {<span class="hljs-number">0</span>};<br><br>​    MPI_Status status;<br><br> <br><br>​    MPI_Init(&amp;argc, &amp;argv);<br><br>​    MPI_Comm_rank(MPI_COMM_WORLD, &amp;process_rank);<br><br>​    MPI_Comm_size(MPI_COMM_WORLD, &amp;process_size);<br><br> <br><br>​    <span class="hljs-keyword">if</span>(process_rank == <span class="hljs-number">0</span>)<br><br>​    {<br><br>​       <span class="hljs-comment">// 将矩阵后两行分别发送给两个从进程</span><br><br>​       MPI_Send(a[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">99</span>, MPI_COMM_WORLD);<br><br>​       MPI_Send(a[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">2</span>, <span class="hljs-number">99</span>, MPI_COMM_WORLD);<br><br>​        <span class="hljs-comment">// 接收两个从进程的计算结果</span><br><br>​       MPI_Recv(c[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">1</span>, <span class="hljs-number">66</span>, MPI_COMM_WORLD, &amp;status);<br><br>​       MPI_Recv(c[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">2</span>, <span class="hljs-number">66</span>, MPI_COMM_WORLD, &amp;status);<br><br>​    <br><br>​       <span class="hljs-comment">// 计算矩阵c的第一行的值</span><br><br>​       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;process_size; i++)<br><br>​           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;process_size; j++)<br><br>​              c[<span class="hljs-number">0</span>][i] += a[<span class="hljs-number">0</span>][j] * b[j][i];<br><br> <br><br>​       <span class="hljs-comment">// 输出矩阵c</span><br><br>​       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;process_size; i++)<br><br>​       {<br><br>​           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;process_size; j++)<br><br>​              <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, c[i][j]);<br><br>​           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br><br>​       }<br><br>​    }<br><br> <br><br>​    <span class="hljs-keyword">else</span><br><br>​    {   <br><br>​       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>; k&lt;process_size; k++)<br><br>​       {<br><br>​           MPI_Recv(a[k], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">99</span>, MPI_COMM_WORLD, &amp;status);<br><br>​           <span class="hljs-comment">// 计算矩阵c的第k行的值</span><br><br>​           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;process_size; i++)<br><br>​              <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;process_size; j++)<br><br>​                  c[k][i] += a[k][j] * b[j][i];<br><br>​           <span class="hljs-comment">// 将第k行的计算结果发送给主进程</span><br><br>​           MPI_Send(c[k], <span class="hljs-number">3</span>, MPI_INT, <span class="hljs-number">0</span>, <span class="hljs-number">66</span>, MPI_COMM_WORLD);<br><br>​       }<br><br>​    }<br><br> <br><br>​    MPI_Finalize();<br><br>​    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>编译命令：mpicc -o matrix matrix.c</p><p>运行命令：mpirun -np 3 ./matrix</p><p><strong>结果</strong></p><p><img src="/zhouyuchen/2023/12/27/%E9%A2%98%E5%BA%93/clip_image001.png" alt="img"> </p><p>1、补全以下程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">read_num</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *num_point,<span class="hljs-type">int</span> my_rank,MPI_Comm comm)</span>; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute_pi</span><span class="hljs-params">( )</span>; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>** argv)</span>{ <br><br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> num_in_cycle,num_point,total_num_in_cycle,local_num_point; <br><br>  <span class="hljs-type">int</span> my_rank,comm_sz; <br><br>  <span class="hljs-type">double</span> begin,end; <br><br>  MPI_Comm comm; <br><br>  **MPI_Init(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);**<span class="hljs-comment">//初始化 （3分）</span><br><br>  comm=MPI_COMM_WORLD; <br><br>   **MPI_Comm_size(comm,&amp;comm_sz);**<span class="hljs-comment">//得到进程总数 （3分）</span><br><br>   **MPI_Comm_rank(comm,&amp;my_rank);**<span class="hljs-comment">//得到进程编号 （3分）</span><br><br>**read_num(&amp;num_point,my_rank,comm);**<span class="hljs-comment">//读取输入数据 （4分）</span><br><br>  begin=MPI_Wtime();<br><br>compute_pi(num_point,&amp;num_in_cycle,&amp;local_num_point,comm_sz,<br><br>&amp;total_num_in_cycle,comm,my_rank);<br><br>  end=MPI_Wtime(); <br><br>  <span class="hljs-keyword">if</span>(my_rank==<span class="hljs-number">0</span>){ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Elapsing time: %fs\n"</span>,end-begin); } <br><br>​    **MPI_Finalize();** / <span class="hljs-comment">//释放资源（3分）</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><br>} <br><br> <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_num</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>* num_point,<span class="hljs-type">int</span> my_rank,MPI_Comm comm)</span>{ <br><br> **<span class="hljs-keyword">if</span>(my_rank==<span class="hljs-number">0</span>)** <span class="hljs-comment">//指定主进程执行（4分）</span><br><br>​    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"please input num in sqaure \n"</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,num_point); <br><br> }<br><br>​    MPI_Bcast(num_point,<span class="hljs-number">1</span>,MPI_LONG_LONG,<span class="hljs-number">0</span>,comm); <br><br>} <br><br> <br></code></pre></td></tr></tbody></table></figure><p>2、请完成下面的表格，并说明每一种通信模式的特点</p><table><thead><tr><th>通信模式</th><th>发送</th><th>接收</th></tr></thead><tbody><tr><td>标准通信模式</td><td>MPI_Send（2分）</td><td>MPI_Recv</td></tr><tr><td>缓存通信模式</td><td>MPI_Bsend（2分）</td><td>MPI_Recv</td></tr><tr><td>同步通信模式（2分）</td><td>MPI_Ssend</td><td>MPI_Recv</td></tr><tr><td>就绪通信模式（2分）</td><td>MPI_Rsend</td><td>MPI_Recv</td></tr></tbody></table><p>标准模式: 由MPI系统决定是等待将数据发送出去后返回；还是将消息拷贝至一缓冲区然后立即返回。大部分MPI系统会预留一定缓冲区，当发送消息的长度小于预留缓冲区大小时，会将消息缓存然后立即返回。否则则当消息部分或全部发送完毕后返回。发送是非本地的。（3分）</p><p>缓冲模式: 用户直接控制通信缓冲区的申请、使用和释放。对通信缓冲区的合理与正确使用是由程序设计人员自己保证的。MPI系统将消息拷贝至用户提供的缓冲区，然后立即返回；消息发送由MPI系统在后台进行用户必须保证缓冲区的大小足够容下采用缓冲模式发送的消息,发送是本地的。（3分）</p><p>同步模式：遵从三次握手协议，在标准模式的基础上，要求确认接收方已经开始接收后，函数调用才返回。本质特征是接收方接收该消息的缓冲区已准备好，不需要附加的系统缓冲区。是非本地的。（3分）</p><p>就绪模式：有客户请求,才提供服务，要求接收操作先于发送操作而被启动。发送请求仅当有匹配的接收后才能发出，否则出错。（3分）</p><p>1、补全以下程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br><br>{<br><br> <span class="hljs-type">int</span> rank,size;<br><br> <span class="hljs-type">int</span> flag,rval,i;<br><br> <span class="hljs-type">int</span> buffer_1,recv_1;<br><br> MPI_Status status,status;<br><br> <span class="hljs-type">int</span> src=<span class="hljs-number">0</span>;<br><br> <span class="hljs-type">int</span> dest=<span class="hljs-number">1</span>;<br><br> MPI_Init(&amp;argc,&amp;argv); （<span class="hljs-number">2</span>分）<br><br>MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank); （<span class="hljs-number">2</span>分）<br><br> MPI_Comm_size(MPI_COMM_WORLD,&amp;size);    （<span class="hljs-number">2</span>分）<br><br> <br><br> <span class="hljs-keyword">if</span>(size!=<span class="hljs-number">2</span>) <span class="hljs-comment">//限制当前程序仅可在线程数为2时才能进行下去，否则使用MPI_Abort退出MPI 执行环境（2分）</span><br><br> {<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*** This program uses exactly 2 processes ! not %d ***\n"</span>,size);<br><br>   MPI_Abort(MPI_COMM_WORLD,<span class="hljs-number">1</span>); <span class="hljs-comment">//1表示错误代码</span><br><br> }<br><br>   <span class="hljs-keyword">if</span>(rank==src) <span class="hljs-comment">//当前进程为发送进程（2分）</span><br><br> {<br><br>   buffer_1=<span class="hljs-number">200</span>;<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"standard MPI_send\n"</span>);<br><br>​    MPI_Send(&amp;buffer_1,<span class="hljs-number">1</span>,MPI_INT,____dest______,_____1_____,MPI_COMM_WORLD);<span class="hljs-comment">//发送进程发送整型数值，该数值来源于buffer_1    printf("MPI_Send %d data,tag=1\n",buffer_1);（每空均2分）</span><br><br> }<br><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_____rank==dest_____) <span class="hljs-comment">//当前进程为接收进程 （2分）</span><br><br> {<br><br>​    MPI_Recv(&amp;recv_1,<span class="hljs-number">1</span>,MPI_INT,_____src_____,<span class="hljs-number">1</span>,MPI_COMM_WORLD,&amp;status); （<span class="hljs-number">2</span>分）<br><br><span class="hljs-comment">//接受进程接收1个来自标签1的整型数据，并将该数据存储在recv_1中</span><br><br>​      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"MPI_Recv=%d,tag=1\n"</span>,recv_1);<br><br>  }<br><br> ______MPI_Finalize()____<span class="hljs-comment">//释放MPI占用的资源，结束MPI环境（2分）</span><br><br>}<br><br> <br></code></pre></td></tr></tbody></table></figure><h1 id="复习重点"><a href="#复习重点" class="headerlink" title="复习重点"></a>复习重点</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">例题：<br>简答题：请简要介绍 MPI 是什么？<br>综合题：<br><span class="hljs-number">1</span>、补全以下程序。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>{<br><span class="hljs-type">double</span> start_time, main_time, min_time, max_time, avg_time;<br>MPI_Init(&amp;argc, &amp;argv);<br><span class="hljs-type">int</span> rank, nprocs;<br>MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);<br>MPI_Barrier(MPI_COMM_WORLD);<br>start_time = MPI_Wtime();<br>sleep(<span class="hljs-number">30</span>);<br>main_time = MPI_Wtime() - start_time;<br>MPI_Reduce(&amp;main_time, &amp;max_time, <span class="hljs-number">1</span>, MPI_DOUBLE, MPI_MAX, <span class="hljs-number">0</span>,<br>MPI_COMM_WORLD);<br>MPI_Reduce(&amp;main_time, &amp;min_time, <span class="hljs-number">1</span>, MPI_DOUBLE, MPI_MIN,<br><span class="hljs-number">0</span>,MPI_COMM_WORLD);<br>MPI_Reduce(&amp;main_time, &amp;avg_time, <span class="hljs-number">1</span>, MPI_DOUBLE, MPI_SUM,<br><span class="hljs-number">0</span>,MPI_COMM_WORLD);<br><span class="hljs-keyword">if</span> (rank == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Time for work is Min: %lf Max: %lf Avg: %lf</span><br><span class="hljs-string">seconds\n"</span>, min_time, max_time, avg_time/nprocs);<br>MPI_Finalize();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>输出是（假设有 <span class="hljs-number">4</span> 个进程，分别执行了 <span class="hljs-number">500</span>ms、<span class="hljs-number">400</span>ms、<span class="hljs-number">600</span>ms、<span class="hljs-number">540</span>ms）<br></code></pre></td></tr></tbody></table></figure><p> <img src="/zhouyuchen/2023/12/27/%E9%A2%98%E5%BA%93/image-20231228124204498.png"></p><p>MapReduce应用场景</p><p> MapReduce是一种用于处理大规模数据集的并行计算模型和编程框架。它将数据处理任务分为两个阶段：Map（映射）和Reduce（归约）。Map阶段将输入数据集拆分成若干独立的子问题，并由多个计算节点并行处理。Reduce阶段将Map阶段的计算结果进行合并和归约，生成最终的输出结果。MapReduce适用于以下应用场景：</p><ol><li>分布式数据处理：MapReduce适用于处理大规模的分布式数据集。它可以将数据集划分为多个部分，并在多个计算节点上并行处理，从而加快数据处理速度。例如，搜索引擎可以使用MapReduce来处理海量的网页数据，进行索引构建和搜索结果排序。</li><li>批量数据处理：MapReduce适用于批量数据处理任务，其中每个数据项都可以独立处理。例如，日志分析、数据清洗、数据转换等任务可以使用MapReduce来并行处理大量的数据记录。</li><li>分布式机器学习：MapReduce可以应用于分布式机器学习任务，如训练大规模的机器学习模型。通过将训练数据划分为多个部分，在多个计算节点上并行执行模型训练的Map阶段，然后在Reduce阶段合并和更新模型参数。这样可以加快机器学习任务的训练速度。</li><li>图计算：MapReduce可以用于处理图结构数据，如社交网络分析、网络图分析等。通过将图数据划分为多个子图，Map阶段可以并行处理每个子图的计算任务，然后在Reduce阶段合并计算结果。这样可以高效地进行大规模图计算。</li></ol><p>总之，MapReduce适用于大规模数据处理和并行计算任务，包括分布式数据处理、批量数据处理、分布式机器学习和图计算等应用场景。它通过将任务分解为多个子任务并在多个计算节点上并行执行，提高了数据处理的效率和扩展性。</p></body></html>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行程序设计</title>
    <link href="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="并行程序设计"><a href="#并行程序设计" class="headerlink" title="并行程序设计"></a>并行程序设计</h1><h2 id="第三章（重点）"><a href="#第三章（重点）" class="headerlink" title="第三章（重点）"></a>第三章（重点）</h2><h3 id="1-并行编程的语言实现"><a href="#1-并行编程的语言实现" class="headerlink" title="1.并行编程的语言实现"></a>1.并行编程的语言实现</h3><p>改动越大，实现难度越大，从1~3实现难度递减</p><ol><li>设计全新的并行语言</li></ol><p>优点：并行程序实现简单、方便</p><p>缺点：没有统一的标准，设计语言的难度和工作量都很大</p><ol start="2"><li>扩展串行语言语法，使其支持并行特征</li></ol><p>将串行语言的并行扩充部分作为原来串行语言的注释(标注)，则对串行编译器来说，并行扩充部分将不起作用；对于并行编译器来说，将会根据标注要求，将串行程序转化为并行程序。</p><p>优点：相对于设计全新的并行语言，难度有所降低</p><p>缺点：需要重新开发编译器</p><ol start="3"><li>为串行语言提供可调用的并行库</li></ol><p>优点：无需重新开发编译器，编程者只需要在串行程序中加入对并行库的的调用，就可以实现并行程序的设计</p><h3 id="2-MPI-并行程序的编程模式"><a href="#2-MPI-并行程序的编程模式" class="headerlink" title="2.MPI 并行程序的编程模式"></a>2.MPI 并行程序的编程模式</h3><p>Message  Passing  Interface(消息传递接口):是消息传递函数库的标准规范</p><ul><li>MPI是一种新的库描述。</li><li>MPI是一种标准或规范的代表。不是特指某一个对它的具体实现</li><li>MPI是一种<strong>消息传递编程模型</strong>，并成为这种编程模型的代表和事实上的标准。</li></ul><h3 id="3-MPI-程序结构"><a href="#3-MPI-程序结构" class="headerlink" title="3.MPI 程序结构"></a>3.MPI 程序结构</h3><ul><li><p>MPI是一种完全基于库的语言。它不需要特殊的编译器或操作系统的调整，所有的MPI程序都有一个基本的结构。</p></li><li><p>只需要编译、链接MPI库，然后使用特殊的并行启动程序进行启动即可</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> {<br>    <span class="hljs-comment">// 初始化MPI环境</span><br>    MPI_Init(&amp;argc, &amp;argv);<br>    <span class="hljs-comment">// 获取进程总数和当前进程的标识符</span><br>    <span class="hljs-type">int</span> world_size, world_rank;<br>    MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size);<br>    MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank);<br>    <span class="hljs-comment">// 数据分配，根据进程数量划分数据</span><br>    <span class="hljs-comment">// 这部分代码会因具体应用而异</span><br>    <span class="hljs-comment">// 进行通信，根据问题需要进行数据交换</span><br>    <span class="hljs-comment">// MPI_Send, MPI_Recv, MPI_Bcast, MPI_Reduce等函数的调用</span><br>    <span class="hljs-comment">// 并行计算，每个进程处理自己负责的数据部分</span><br>    <span class="hljs-comment">// 这部分代码会因具体应用而异</span><br>    <span class="hljs-comment">// 同步操作，确保计算的一致性</span><br>    MPI_Barrier(MPI_COMM_WORLD);<br>    <span class="hljs-comment">// 结束MPI环境</span><br>    MPI_Finalize();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>上述代码包括了初始化MPI环境、数据分配、通信、计算、同步和终止等步骤</p><p>打印Hello World!</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>{<br>   MPI_Init(&amp;argc, &amp;argv);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, world!\n"</span>);<br>   MPI_Finalize();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="4-MPI-基础调用"><a href="#4-MPI-基础调用" class="headerlink" title="4.MPI 基础调用"></a>4.MPI 基础调用</h3><p>基本的MPI函数调用包括MPI_Init和MPI_Finalize。</p><p>应用程序启动之后对MPI_Init进行调用，并且必须将来自主程序的参数传递给初始化调用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">iret = MPI_Init(&amp;argc, &amp;argv);<br>iret = MPI_Finalize();<br></code></pre></td></tr></tbody></table></figure><p>int MPI_Finalize () </p><ul><li>退出MPI系统，所有进程正常退出都必须调用。表明并行代码的结束,<strong>结束除主进程外其它进程</strong>。</li><li>串行代码仍可在主进程(rank = 0)上运行，但不能再有MPI函数（包括MPI_Init()）</li></ul><h3 id="5-进程"><a href="#5-进程" class="headerlink" title="5.进程"></a>5.进程</h3><ul><li><p>大多数程序在可以通信的组件中，将所需要<strong>进程的数量</strong>和<strong>进程rank</strong>称为<strong>通信器</strong>。<strong>MPI的一个主要功能是启动远程进程</strong>，并将这些进程进行绑定起来，以便在进程之间进行消息传递。默认的<strong>通信器</strong>是MPI_COMM_WORLD，它是由MPI_Init在每个并行作业开始时设置的。</p></li><li><p>进程(Process):是一种独立的计算单元，拥有部分内存的所有权并控制用户空间的资源。</p></li><li><p>rank:是一种唯一的、可移植的标识符，用于区分进程集中的各个进程。通常这个值是0到进程数减1的整数。</p></li><li><p>序号(rank) 序号用来在一个进程组或通信子中标识一个进程. </p><ul><li>MPI程序中的进程由进程组标识/进程序号或通信子标识/进程序号所唯一确定.</li><li>序号是相对于进程组或通信子而言的: 同一个进程在不同的进程组或通信子中可以有不同的序号.进程的序号是在进程组或通信子被创建时赋予的。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Comm_size</span> <span class="hljs-params">(MPI_Comm comm<span class="hljs-comment">/*in*/</span>,<span class="hljs-type">int</span>* size<span class="hljs-comment">/*out*/</span>)</span><br><span class="hljs-comment">//获得进程个数 size</span><br><span class="hljs-comment">//指定一个通信子,也指定了一组共享该空间的进程, 这些进程组成该通信子的group.</span><br><span class="hljs-comment">//获得通信子comm中规定的group包含的进程的数量.</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Comm_rank</span> <span class="hljs-params">(MPI_Comm comm<span class="hljs-comment">/*in*/</span>,<span class="hljs-type">int</span>* rank<span class="hljs-comment">/*out*/</span>)</span><br><span class="hljs-comment">//得到本进程在通信空间中的rank值,即在组中的逻辑编号(该 rank值为0到n-1间的整数,相当于进程的ID。).</span><br></code></pre></td></tr></tbody></table></figure><p>MPI预定义的进程组和通信域</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_GROUP_NULL<br><span class="hljs-comment">//无效进程组句柄</span><br>MPI_COMM_NULL<br><span class="hljs-comment">//无效通信域句柄</span><br>MPI_GROUP_EMPTY<br><span class="hljs-comment">//有效进程组句柄，包括元素个数为0</span><br>MPI_COMM_SELF<br><span class="hljs-comment">//有效通信域句柄，包括元素仅为当前进程</span><br>MPI_COMM_WORLD<br><span class="hljs-comment">//有效通信域句柄，包括元素为所有进程！！！！！！</span><br></code></pre></td></tr></tbody></table></figure><p>MPI程序最小工作示例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>{<br>   <span class="hljs-comment">//在程序启动后初始化，包括程序参数</span><br>   MPI_Init(&amp;argc, &amp;argv);<br>   <span class="hljs-type">int</span> rank, nprocs;<br>   <span class="hljs-comment">//获取进程的rank number</span><br>   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);<br>   <span class="hljs-comment">//获取由mpirun命令确定的程序进程数量</span><br>   MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);<br>   <span class="hljs-comment">//完成MPI来同步rank，然后退出</span><br>   <span class="hljs-built_in">printf</span>(“I am Rank %d of %d\n<span class="hljs-string">", rank, nprocs);</span><br><span class="hljs-string">   MPI_Finalize();</span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">}</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231226155644186.png"></p><p><strong>输出的结果可能是任意顺序的：MPI程序由操作系统决定何时以及通过怎样的方式输出结果。</strong></p></li></ul><h3 id="6-消息传递"><a href="#6-消息传递" class="headerlink" title="6.消息传递"></a>6.消息传递</h3><p>消息传递方法的核心是<strong>点对点</strong>的消息传递，或者更准确地说，是<strong>进程对进程</strong>地消息传递。并行处理的重点是协调这些消息传递的工作。</p><p>传递</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">int</span> count, MPI_Datatype datatype, <span class="hljs-type">int</span> dest, <span class="hljs-type">int</span> tag, MPI_Comm comm)</span><br><span class="hljs-title function_">MPI_Send</span><span class="hljs-params">(A, <span class="hljs-number">10</span>, MPI_DOUBLE, <span class="hljs-number">1</span>,<span class="hljs-number">99</span>, MPI_COMM_WORLD)</span>;<br><span class="hljs-comment">//MPI_Send函数将数组A中的10个双精度浮点数发送给标识符为1的进程，消息标签为99。</span><br></code></pre></td></tr></tbody></table></figure><p>接受</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MPI_Recv</span><span class="hljs-params">(<span class="hljs-type">void</span>* buf, <span class="hljs-type">int</span> count, MPI_Datatype datatype, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> tag, MPI_Comm comm, MPI_Status* status)</span><br><span class="hljs-title function_">MPI_Recv</span><span class="hljs-params">(B, <span class="hljs-number">20</span>, MPI_DOBULE, <span class="hljs-number">0</span>, <span class="hljs-number">99</span>, MPI_COMM_WORLD,  &amp;status)</span>;<br><span class="hljs-comment">//MPI_Recv函数从标识符为0的进程接收消息，消息标签为99，将接收到的数据存储在数组B中，并使用status变量获取消息的状态信息。</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (rank != <span class="hljs-number">0</span>)<br>{<br>    <span class="hljs-comment">// 对于非根进程，发送消息到根进程（rank 0）</span><br>    <span class="hljs-built_in">strcpy</span>(message, <span class="hljs-string">"Hello World!"</span>);<br>    MPI_Send(message, <span class="hljs-built_in">strlen</span>(message)+<span class="hljs-number">1</span>, MPI_CHAR, <span class="hljs-number">0</span>, <span class="hljs-number">99</span>, MPI_COMM_WORLD);<br>} <br><span class="hljs-keyword">else</span> <br>{ <span class="hljs-comment">/* rank == 0 */</span><br>    <span class="hljs-comment">// 对于根进程，循环接收来自其他进程的消息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> source = <span class="hljs-number">1</span>; source &lt; nprocs; ++source)<br>    {<br>        <span class="hljs-comment">// 使用MPI_Recv接收来自其他进程（source）的消息</span><br>        MPI_Recv(message, <span class="hljs-number">100</span>, MPI_CHAR, source, <span class="hljs-number">99</span>, MPI_COMM_WORLD,  &amp;status);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, message);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231226163828227.png"></p><h3 id="7-阻塞"><a href="#7-阻塞" class="headerlink" title="7.阻塞"></a>7.阻塞</h3><ul><li>需要等待操作的实际完成，或至少等待MPI系统安全地备份后才返回；</li><li>MPI_Send与MPI_Recv都是阻塞的；</li><li>MPI_Send调用返回时表明数据已经发出或被MPI系统复制，随后对发送缓冲区的修改不会改变所发送的数据；</li><li>而MPI_Recv返回，则表明已完成数据接收。</li><li>函数调用是非局部的，对整个通信参与者都会有影响。</li></ul><p><strong>异步通信 非阻塞</strong></p><p>无需等待操作的实际完成，不等待工作的完成；<br>MPI_Isend与MPI_Irecv都是非阻塞的。</p><ul><li>一个发送/接收的MPI程序，必须在一个进程上发送数据，在另一个进程上接收数据。</li><li>在发送时，缓冲区必须已经完成读取并且可以释放。在接收时，缓冲区必须被填充。</li><li>如果通信中的两个进程都阻塞，就会出现挂起的情况。</li><li>当一个或多个进程在等待一个永远不会发生的事件时，也会发生挂起。</li></ul><p><strong>异步(非阻塞)调用</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Request requests[<span class="hljs-number">2</span>] = {MPI_REQUEST_NULL, MPI_REQUEST_NULL};<br><span class="hljs-comment">//发布Irecv</span><br>MPI_Irecv(xrecv, count, MPI_DOUBLE, partner_rank, tag, comm, &amp;requests[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//调用 Isend</span><br>MPI_Isend(xsend, count, MPI_DOUBLE, partner_rank, tag, comm, &amp;requests[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//等待接受和发送完成</span><br>MPI_Waitall(<span class="hljs-number">2</span>, requests, MPI_STATUSES_IGNORE);<br></code></pre></td></tr></tbody></table></figure><p><strong>混合阻塞与异步调用</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">MPI_Request request;<br><span class="hljs-comment">//发送</span><br>MPI_Isend(xsend, count, MPI_DOUBLE, partner_rank, tag, comm, &amp;request);<br><span class="hljs-comment">//接受</span><br>MPI_Recv(xrecv, count, MPI_DOUBLE, partner_rank, tag, comm, MPI_STATUS_IGNORE);<br><span class="hljs-comment">//释放请求</span><br>MPI_Request_free(&amp;request);<br></code></pre></td></tr></tbody></table></figure><h3 id="8-通信域"><a href="#8-通信域" class="headerlink" title="8.通信域"></a>8.通信域</h3><p>通信域（Communicator）是一个逻辑上的组，用于定义一组进程之间的通信关系。MPI通信域定义了进程之间的通信上下文，进程可以在其中进行消息传递和同步操作。</p><p>MPI提供了两种类型的通信域：<code>MPI_COMM_WORLD</code>和自定义通信域。</p><ol><li><strong>MPI_COMM_WORLD</strong>是MPI的默认通信域，包含了运行MPI程序的所有进程。它是在MPI初始化时自动创建的，并且可以通过<strong>MPI_COMM_WORLD</strong>常量来引用。在<strong>MPI_COMM_WORLD</strong>中，所有进程都可以相互通信。</li><li>自定义通信域是通过调用MPI函数创建的。通过自定义通信域，你可以将进程划分为不同的组，每个组具有自己的通信上下文。自定义通信域可以用于实现更复杂的通信模式，例如组间通信或子集内的通信。</li></ol><h2 id="第四章（重点）"><a href="#第四章（重点）" class="headerlink" title="第四章（重点）"></a>第四章（重点）</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1.同步"></a>1.同步</h3><ul><li><p>MPI_Barrier函数的作用是阻塞进程，直到通信域comm中的所有进程都调用了该函数，才会继续往下执行。它用于确保在某一点上所有进程都达到了同步状态，即所有进程都执行到了该函数，并且在所有进程都执行完该函数之前，没有进程可以继续往下执行。</p></li><li><p>MPI_Barrier函数通常用于同步进程的执行，以确保在某个点上所有进程都达到了同步状态。它可以用于控制进程间的顺序执行，或者用于确保在某个操作之前或之后所有进程都已完成某个阶段的工作。</p></li></ul><p>整体同步并行计算模型(Bulk Synchronous Parallel, BSP)：</p><ul><li>并发计算步骤：进程进行局部异步计算，局部并行计算可以与通信重叠；</li><li>通信步骤：进程之间相互交换数据；</li><li>同步屏障步骤：当进程到达同步屏障时，等待所有其它进程到达这个屏障，然后进行另一组超级步骤</li></ul><h3 id="2-聚合通信"><a href="#2-聚合通信" class="headerlink" title="2.聚合通信"></a>2.聚合通信</h3><ul><li>MPI具有丰富的聚合通信调用集。</li><li>聚合通信将对MPI通信器中的一组进程进行操作。</li><li>操作部分进程时，可以为MPI_COMM_WORLD的子集创建自己的MPI通信器。然后，可在聚合通信中使用通信器来代替MPI_COMM_WORLD。</li><li>大多数聚合通信都是对数据执行操作的。</li><li>参加聚合通信的进程和聚合通信的上下文，由该聚合通信调用的通信域限定。<br>聚合通信的三大功能：通信、同步和计算。<ul><li>通信：完成组内数据的传输。</li><li>同步：实现组内所有进程在执行次序上进行协调，使得组内所有进程在特定某一点在执行进度上取得一致。</li><li>计算：对给定的数据完成一定的操作。</li></ul></li></ul><p>按通信的方向不同，分为：一对多通信，多对一通信，多对多通信。</p><ul><li>一对多聚合通信：一个称为ROOT的进程向其他所有进程发送消息。常见的一对多通信的例子是广播。</li><li>多对一聚合通信：一个称为ROOT的进程接收来自其他所有进程的消息。常见的多对一通信的例子是收集。</li><li>多对多通信：每一个进程都向其他所有进程发送消息或者接收来自其他所有进程发送的消息。</li></ul><h3 id="3-MPI-数据类型"><a href="#3-MPI-数据类型" class="headerlink" title="3.MPI 数据类型"></a>3.MPI 数据类型</h3><p>目的：移植，方便使用（抽象，不连续数据的传送）<br>分为：预定义数据类型 和 派生数据类型<br>MPI是强数据类型的</p><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231226194256003.png"></p><h3 id="4-MPI-派生数据类型（自定义）"><a href="#4-MPI-派生数据类型（自定义）" class="headerlink" title="4.MPI 派生数据类型（自定义）"></a>4.MPI 派生数据类型（自定义）</h3><p>派生数据类型：通常是用户根据程序的需要，在原始数据类型的基础上定义适合自身程序的数据处理方式，又称为用户自定义数据类型或抽象数据类型</p><p>目的</p><ul><li>异构计算: 不同系统有不同的数据表示格式。MPI预先定义一些基本数据类型，在实现过程中以这些基本数据类型为桥梁进行转换。</li><li>派生数据类型:允许消息来自不连续的和类型不一致的存储区域，如数组散元与结构类型等的传送。</li></ul><p>特点</p><ul><li>派生数据类型在一条非连续存储或具有混合类型的消息中提供了一种可移植和优雅的解决方法。</li><li>派生数据类型在发送数据过程中提供了一种高效的方法，即当数据从一个单处理器分发到多个处理器上时，不需要任何中间缓冲区。</li><li>派生数据类型都是在基本MPI数据类型的基础之上生成的。</li><li>MPI提供了许多不同的产生派生数据类型的<strong>例程</strong>,又叫类型生成器，每个例程都针对某一类数据，比如：连续数据、非连续数据、非连续的混合类型的数据。</li><li>每一个派生数据类型在使用之前都必须commit。</li><li>MPI例程MPI_TYPE_EXTENT在涉及任何对齐问题时用于计算偏移很有用。</li></ul><p>四种常用的定义(构造)新数据类型的方法</p><ul><li>MPI_Type_contiguous(连续复制的类型生成器)</li><li>MPI_Type_vector(向量数据类型的生成器)</li><li>MPI_Type_indexed(索引数据类型的生成器)</li><li>MPI_Type_struct(结构数据类型的生成器)</li><li>MPI_Type_contiguous: 将一个连续的数据块转换为一种类型；<br>MPI_Type_vector: 通过跨步数据块创建一个类型；<br>MPI_Type_create_subarray: 创建较大数组的矩形子集；<br>MPI_Type_indexd或者MPI_Type_Create_hindexed: 创建一组长度和位移描述的不规矩索引。为了提高通用性，hindexed版本中，通过字节而不是数据类型来表示位移。<br>MPI_Type_create_struct: 创建一种数据类型，以可移植方式将数据项封装在结构中。在这种方式中，考虑到了编译器的填充。</li></ul><h3 id="5-ghost-cell-基本原理"><a href="#5-ghost-cell-基本原理" class="headerlink" title="5.ghost cell 基本原理"></a>5.ghost cell 基本原理</h3><ul><li>ghost cell是用来连接相邻处理器上的网格的机制，用于对来自相邻处理器上的值进行缓存，从而减少需要的通信操作。</li><li>ghost cell技术是MPI中实现分布式存储并行性的最重要方法。</li><li>一旦程序被并行化，一个相似的外部区域将被添加进来，用于保存相邻网格的值。<br>这些cell不是真正的cell，只是用于减少通信成本的一种辅助手段，所以被称为ghost cell。<br>ghost cell的真实数据存储在相邻的处理器上，而本地拷贝只是一个虚值。</li><li>ghost cell更新或者交换指的是ghost cell中的信息变更，当并行程序执行的多个进程需要更新来自相邻进程的真实值时才会发生ghost cell更新或者交换。</li></ul><p>ghost cell交换(续)</p><ul><li>在C语言中，行数据时连续的，而列数据是由行大小的跨度隔开的。</li><li>行发送可以使用MPI_Send调用发送连续数组。</li><li>为列发送单独值的代价相当高，因此需要以某种方式将他们组合在一起再发送。</li><li>可以使用MPI_Pack调用来打包列数据实现。</li></ul><h3 id="6-笛卡尔拓扑基础"><a href="#6-笛卡尔拓扑基础" class="headerlink" title="6.笛卡尔拓扑基础"></a>6.笛卡尔拓扑基础</h3><p>MPI的笛卡尔拓扑可以将进程进行坐标划分，将进程映射到二维、三维，甚至多维网格。</p><p>MPI_Dims_create：在笛卡尔网格中创建处理器的除法。<br>MPI_Cart_create：创建要附加到的拓扑信息的新通信器。<br>MPI_Cart_coords：确定在组中给定排名的笛卡尔拓扑中的进程共同点。<br>MPI_Cart_shift：返回移动的源和目标排名，给定移动方向和量。</p><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231226205715445-17035954415368.png"></p><h2 id="第五章（重点）"><a href="#第五章（重点）" class="headerlink" title="第五章（重点）"></a>第五章（重点）</h2><h3 id="1-MapReduce-基本概念"><a href="#1-MapReduce-基本概念" class="headerlink" title="1.MapReduce 基本概念"></a>1.MapReduce 基本概念</h3><p>MapReduce是一种编程范式（programming paradigm），用于大规模数据集（大于1TB）的并行运算。 </p><p>MapReduce的名字源于这个模型中的两项核心操作：Map（映射）和 Reduce（化简）</p><p>模式的思想是通过<strong>自动分割</strong>将要执行的问题(程序)、拆解成**Map(映射)<strong>和</strong>Reduce(化简)**的方式。</p><p>分而治之</p><p>MapReduce 是 Apache Hadoop 的核心。 术语“MapReduce”指的是 Hadoop 程序执行的两个不同的独立任务。 第一个是映射作业，它接受一组数据，并将其转换为另一组数据，其中各个元素分解为元组（键/值对）</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><ul><li>MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：Map和Reduce。</li><li>用户自定义的Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合。</li><li>MapReduce库把所有具有相同中间key值的中间value值I集合在一起后传递给reduce函数。 </li></ul><p>用户自定义的Reduce函数接受一个中间key的值I和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。一般的，每次Reduce函数调用只产生0或1个输出value值。通常我们通过一个迭代器把中间value值提供给Reduce 函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合。</p><p>简单概括的说：MapReduce是将一个大作业拆分为多个小作业的框架（大作业和小作业应该本质是一样的，只是规模不同），用户需要做的就是决定拆成多少份，以及定义作业本身。 </p><h3 id="3-处理流程"><a href="#3-处理流程" class="headerlink" title="3.处理流程"></a>3.处理流程</h3><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231226213852081.png"></p><h3 id="4-词频统计"><a href="#4-词频统计" class="headerlink" title="4.词频统计"></a>4.词频统计</h3><p>如果我们想统计下过去10年计算机论文出现最多的几个单词，看看大家都在研究些什么，那我收集好论文后，该怎么办呢？<br><strong>方法一</strong>：我可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。<br>这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。<br><strong>方法二</strong>：写一个多线程程序，并发遍历论文。<br>这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。</p><p><strong>方法三</strong>：把作业交给多个计算机去完成。<br>    我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。<br><strong>方法四</strong>：让MapReduce来帮帮我们吧！<br>    Map/Reduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。</p><p>统计词频的Map/Reduce函数的核心代码非常简短，主要就是实现Map和Reduce函数。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">　　<span class="hljs-built_in">map</span>(String key, String value): <br>　　<span class="hljs-comment">// key: document name </span><br>　　<span class="hljs-comment">// value: document contents </span><br>　　<span class="hljs-keyword">for</span> each word w in value: <br>　　EmitIntermediate(w, <span class="hljs-string">"1"</span>); <br>　　reduce(String key, Iterator values): <br>　　<span class="hljs-comment">// key: a word </span><br>　　<span class="hljs-comment">// values: a list of counts </span><br>　　<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <br>　　<span class="hljs-keyword">for</span> each v in values: <br>　　result += ParseInt(v); <br>　　Emit(AsString(result)); <br><span class="hljs-comment">//说明：map函数接受的键是文件名，值是文件的内容，map逐个遍历单词，每遇到一个单词w，就产生一个中间键值对&lt;w, “1”&gt;，这表示单词w咱又找到了一个；Map/Reduce将键相同（都是单词w）的键值对传给reduce函数，这样reduce函数接受的键就是单词w，值是一串“1”（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些“1”累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统。 </span><br></code></pre></td></tr></tbody></table></figure><h3 id="5-结构"><a href="#5-结构" class="headerlink" title="5.结构"></a>5.结构</h3><p> map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p><p>map函数：接受一个键值对(key-value pair)，产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</p><p>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h3><p>共享内存型：即在多处理器的计算机系统中，可以被不同计算单元访问的内存。</p><p>分布式内存型：即每个计算单元都有单独的内存，计算单元之间的数据访问通过互连网络传输，这一并行架构具有较强的可扩展性，但程序开发难度较高</p><p>混合型内存型：即结合了共享内存和分布式内存的方式，各计算单元内实现共享内存，计算单元间采用分布式内存方式形成计算集群</p><p><strong>OpenMP对应共享内存模型</strong></p><h3 id="2-OpenMP并行编程方法"><a href="#2-OpenMP并行编程方法" class="headerlink" title="2.OpenMP并行编程方法"></a>2.OpenMP并行编程方法</h3><p><strong>#pragma omp parallel for  -为外循环添加OpenMP线程</strong></p><p>随着多核心架构的不断发展，<strong>线程级的并行</strong>成为影响软件性能的关键因素</p><p>OpenMP是被广泛使用的<strong>线程和共享内存并行</strong>开放标准之一</p><p>OpenMP的并行化实现是通过嵌入程序源代码中的编译制导语句来实现的，所添加的编译制导语句可以视为程序设计语言的<strong>并行化拓展</strong>，<strong>支持数据的共享和私有化</strong>，<strong>支持并行区域划分</strong>、<strong>工作共享和同步</strong>等机制</p><p>编译OpenMP并行化程序时，需要编译器支持，并添加编译选项。如GCC编译时添加-fopenmp</p><p>编译：gcc -fopenmp -o ./vecadd_opt1 vecadd_opt1.c timer.c</p><h3 id="3-SIMD"><a href="#3-SIMD" class="headerlink" title="3.SIMD"></a>3.SIMD</h3><p>SSE(Streaming SIMD Extensions，<strong>单指令多数据</strong>流扩展)指令集最早出现在Pentium系列处理器中，主要用于处理单精度浮点数。</p><p>MMX(MultiMediaeXtensions，多媒体扩展)指令集是Intel基于x86架构融合SIMD思想于1962年推出的第一个真正意义上的向量化指令集拓展，可以提高图形图像处理能力，同样也适用于大量复杂数据的并行处理。</p><p>在编程中，使用 SIMD 模型可以通过以下方式实现：</p><ol><li><strong>SIMD 指令集：</strong><br> 现代处理器通常支持 SIMD 指令集，如Intel的SSE（Streaming SIMD Extensions）和AVX（Advanced  Vector Extensions），以及ARM的NEON（Advanced  SIMD）。这些指令集提供了一组特殊指令，用于同时处理多个数据元素。</li><li><strong>向量化编程：</strong><br> 向量化编程是一种将代码重写为使用 SIMD 指令的技术。通过使用适当的编译器指示或手动优化代码，可以将循环和计算操作转换为 SIMD 操作，以实现并行计算。</li><li><strong>SIMD 库和框架：</strong><br> 一些编程库和框架提供了对 SIMD 模型的抽象和封装，以简化向量化编程。例如，Intel的IPP（Integrated Performance  Primitives）、OpenCV（Open Source Computer Vision Library）和NumPy（Numerical  Python）等库都提供了对 SIMD 操作的支持。</li></ol><p>使用 SIMD 模型时需要注意以下几点：</p><ul><li>数据的并行性：SIMD 模型适用于具有数据并行性的任务，即可以同时处理多个独立的数据元素。</li><li>数据对齐：在使用 SIMD 指令时，数据通常需要对齐到特定的边界，以获得最佳性能。</li><li>数据依赖性：如果数据之间存在依赖性，使得它们不能同时处理，那么 SIMD 可能无法提供性能优势。</li></ul><h3 id="4-MPI-并行编程方法"><a href="#4-MPI-并行编程方法" class="headerlink" title="4.MPI 并行编程方法"></a>4.MPI 并行编程方法</h3><p><strong>#pragma omp simd  -为内循环添加SIMD向量化</strong></p><p>MPI_THREAD_SINGLE—只执行一个线程(标准MPI)<br><strong>MPI_THREAD_FUNNELED—多线程，但只有主线程进行MPI调用（推荐）</strong><br>MPI_THREAD_SERIALIZED—多线程，但每次只有一个线程进行MPI调用<br>MPI_THREAD_MULTIPLE—多线程，并且多个线程对MPI进行调用</p><h3 id="5-内存分配"><a href="#5-内存分配" class="headerlink" title="5.内存分配"></a>5.内存分配</h3><ol><li><strong>本地内存分配（Local Memory Allocation）：</strong><br> 每个MPI进程都有自己的本地内存，可以使用标准的内存分配函数（如malloc、calloc等）在本地分配内存。本地内存分配的内存只能在本地进程中使用，无法直接在其他进程中访问。如果需要在不同进程之间共享数据，就需要使用MPI提供的通信操作来传输数据。</li><li><strong>分布式内存分配（Distributed Memory Allocation）：</strong><br> 在MPI中，通常使用分布式内存模型，即每个进程有自己的内存空间，进程之间的内存是独立的。分布式内存分配可以通过使用MPI提供的特定函数来实现，如MPI_Alloc_mem和MPI_Win_allocate等。这些函数可以在多个进程之间分配共享内存，以便进行进程间的数据交换和通信。</li></ol><p><img src="/zhouyuchen/2023/12/25/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20231227170013111.png"></p></body></html>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender</title>
    <link href="/zhouyuchen/2023/12/03/blender/"/>
    <url>/zhouyuchen/2023/12/03/blender/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h1><p>视图控制 按住 ~   +   数字</p><p>独立显示  /</p><p>位移     G          后面可以加上xyz</p><p>旋转     R          后面可以加上xyz </p><p>缩放     S          后面可以加上xyz</p><p>编辑视图 ctrl + tab</p><p>6 编辑点线面</p><p> alt Z 透视</p><p>CTRL B 倒角 用于创作圆角</p><p>右键平滑着色可以使用插值顶点法线，网格面的边缘会变得模糊，看起来很光滑</p><p>x 删除</p><p>alt  shift 循环切割线选中</p><p>shift D 复制</p><p>扳手工具添加修改器 添加镜像，选择吸管吸取镜像中心</p><p>物体-&gt;设置原点-&gt;几何中心  设置物体旋转轴心的方式</p></body></html>]]></content>
    
    
    <categories>
      
      <category>建模工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agisoft Metashape</title>
    <link href="/zhouyuchen/2023/09/18/Metashape/"/>
    <url>/zhouyuchen/2023/09/18/Metashape/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Agisoft-Metashape等使用"><a href="#Agisoft-Metashape等使用" class="headerlink" title="Agisoft Metashape等使用"></a>Agisoft Metashape等使用</h1><h2 id="Metashape使用"><a href="#Metashape使用" class="headerlink" title="Metashape使用"></a>Metashape使用</h2><ol><li>新建项目，将图片资源拖入堆块（Chunk）中</li><li>选择工作流程（Workflow）中的对齐照片（Align Photos）可选精度，目的是为了将导入的素材形成链接点描点拼接</li><li>选择移动区域（Move Region)调整区域，排除多余的点</li><li>再次选择工作流程中创建点云（build dense cloud）再次生成深度图</li><li>形成深度图后，双击左侧工作区中点云查看</li><li>选择工作流程中的生成网格（Build Mesh）选择点云更加精细</li><li>选择工作区中的3D Model优化多余的点</li><li>选择工作流程中的生成纹理（Build Texture），可选纹理大小数量</li><li>选择文件导出模型，同时选中纹理导出</li></ol><h3 id="离散点删除"><a href="#离散点删除" class="headerlink" title="离散点删除"></a>离散点删除</h3><p>在对齐照片后通过使用自由选择或者矩形工具先将不需要的离散点删除</p><p>调整移动区域大小重新规定计算点</p><p>重置视图可以移动到中心位置</p><h2 id="Upscayl"><a href="#Upscayl" class="headerlink" title="Upscayl"></a>Upscayl</h2><ul><li><strong>REAL-ESRGAN：</strong>提高图片的清晰度；</li><li><strong>RemaCRI：</strong>增强图片效果；</li><li><strong>UltraMix Balanced：</strong>提高图片色彩饱和度；</li><li><strong>UltraSharp：</strong>提高图片清晰度和锐化边缘；</li><li><strong>Digital Art：</strong>提高颜色和纹理细节；</li><li><strong>Sharpen Image：</strong>只锐化处理；</li></ul><p>注意在系统中开启：</p><p><img src="/zhouyuchen/2023/09/18/Metashape/image-20230925112737882.png"></p><p>测试记录：</p><ol><li><p>   图片记录（5张图）</p></li><li><p>96DPI放大4倍（9600x12800，3M，10分钟）</p></li><li><p>96DPI放大8倍（12000x16000，5M，15分钟）</p></li><li><p>300DPI（2400x3200，3M，15分钟）   300DPI放大后变为（1）</p></li><li><p>   建模记录</p></li><li><pre><code class="hljs"> 5张图建模总时长在20分钟左右，DPI大，时间长</code></pre></li><li><p>   （3）点云数量多于（1，2）</p></li><li><p>   （1）和（2）建模清晰度并无太大差异  （3）清晰度低</p></li><li><p>总结</p><ol><li>   每张图优化时长在3分钟左右，</li><li>   15cm大小一面至少需要4面整体，4面细节，位置需以球面等距拍摄</li></ol></li></ol><h2 id="DOTween"><a href="#DOTween" class="headerlink" title="DOTween"></a>DOTween</h2><p><strong>解压缩</strong>到 Unity Assets 文件夹中</p><p>使用的每个类/脚本中<strong>导入 DOTween 的命名空间：</strong></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br></code></pre></td></tr></tbody></table></figure><p>初始化以设置一些全局选项，DOTween 将使用默认设置自动初始化：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">DOTween.Init(autoKillMode, useSafeMode, logBehaviour);<br></code></pre></td></tr></tbody></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><img src="/zhouyuchen/Metashape/splash_lambda.png" alt="img"></p><p><img src="/zhouyuchen/Metashape/splash_shortcuts.png" alt="img"></p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//目标点（1，1，1），时长秒</span><br>DoMove(Vector3.one, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//X,Y,Z移动</span><br>DOMoveX<br><span class="hljs-comment">//旋转</span><br>DORotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">140</span>,<span class="hljs-number">140</span>, <span class="hljs-number">140</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment">//放大</span><br>DOScale<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Metashape</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Metashape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D</title>
    <link href="/zhouyuchen/2023/09/18/Unity3D/"/>
    <url>/zhouyuchen/2023/09/18/Unity3D/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="LateUpdate和Update"><a href="#LateUpdate和Update" class="headerlink" title="LateUpdate和Update"></a>LateUpdate和Update</h2><p>两者都是每帧调用，执行顺序不同</p><p>无论有多少个update函数，都要等update函数执行完才能再执行lateupdate</p><p>Lateupdate一般放相机处理</p><p>update放画面控制逻辑</p><p>update在渲染每一帧的时候调用。但是fixupdate一般是在固定的时间频率调用。这个时间不一定是每一帧的时间。fixupdate调用不受帧率的影响</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Unity3D</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#</title>
    <link href="/zhouyuchen/2023/06/01/C#/"/>
    <url>/zhouyuchen/2023/06/01/C#/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="C-学习入门"><a href="#C-学习入门" class="headerlink" title="C#学习入门"></a>C#学习入门</h1><h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h3><p>C# 是在 .Net 框架开发期间开发的。</p><p>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><p>主要功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li><strong>委托（Delegates）和事件管理（Events Management）</strong></li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><p>注意以下几点：</p><ul><li>C# 是大小写敏感的。</li><li>所有的语句和表达式必须以分号（;）结尾。</li><li>程序的执行从 Main 方法开始。</li><li>与 Java 不同的是，文件名可以不同于类的名称。</li></ul><h3 id="与C不同的基本语法"><a href="#与C不同的基本语法" class="headerlink" title="与C不同的基本语法"></a>与C不同的基本语法</h3><h4 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h4><p>在任何 C# 程序中的第一条语句都是：</p><p>由于使用 <code>using</code> 指令，因此程序可以使用 <code>Console.WriteLine</code> 作为 <code>System.Console.WriteLine</code> 的简写。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<span class="hljs-comment">//一个程序可以包含多个using语句</span><br></code></pre></td></tr></tbody></table></figure><h4 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h4><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System -  CTS）中所有数据类型的终极基类。Object 是 System.Object  类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><h4 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h4><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></tbody></table></figure><h4 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h4><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">String str = <span class="hljs-string">"runoob.com"</span>;<br></code></pre></td></tr></tbody></table></figure><p>一个 @引号字符串：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-string">@"runoob.com"</span>;<br></code></pre></td></tr></tbody></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@"C:\Windows"</span>;<br></code></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">"C:\\Windows"</span>;<br></code></pre></td></tr></tbody></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@"&lt;script type=""text/javascript""&gt;</span><br><span class="hljs-string">    &lt;!--</span><br><span class="hljs-string">    --&gt;</span><br><span class="hljs-string">&lt;/script&gt;"</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C#类型转换"></a>C#类型转换</h3><p>C#类型转换与C很类似，隐式转换和显示转换（强转）</p><p><a href="https://www.runoob.com/csharp/csharp-type-conversion.html">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C#变量"></a>C#变量</h3><h4 id="接受来自用户的值"><a href="#接受来自用户的值" class="headerlink" title="接受来自用户的值"></a>接受来自用户的值</h4><p><strong>System</strong> 命名空间中的 <strong>Console</strong> 类提供了一个函数 **ReadLine()**，用于接收来自用户的输入，并把它存储到一个变量中。</p><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> num;<br>num = Convert.ToInt32(Console.ReadLine());<br></code></pre></td></tr></tbody></table></figure><p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p><h3 id="C-常量运算符与C类似"><a href="#C-常量运算符与C类似" class="headerlink" title="C#常量运算符与C类似"></a>C#常量运算符与C类似</h3><p>需要注意的是</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car)  // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”);      StringReader r = obj as StringReader;</td></tr></tbody></table><h3 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h3><p>internal：同一个程序集的对象可以访问；</p><p>protected internal：访问限于当前程序集或派生自包含类的类型。也就是包括protected 和 internal</p><p><img src="/zhouyuchen/2023/06/01/C#/image-20230712222252009.png"></p><h3 id="C-方法"><a href="#C-方法" class="headerlink" title="C#方法"></a>C#方法</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)<br>{<br>   Method Body<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</p><p><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</p><p><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</p><p><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</p><p><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>{<br>    <span class="hljs-comment">//方法主体</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h4><p>通过方法名调用</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全</p><p>即使在函数内改变了值，值也没有发生任何的变化。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>{<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>    {<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>        {...}<br>    }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    {<br>        ...<br>        <span class="hljs-built_in">int</span> ret;<br>        <span class="hljs-comment">//调用 FindMax 方法</span><br>        ret = n.FindMax(a, b);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>{<br>&nbsp; &nbsp;<span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>&nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<br>&nbsp; &nbsp; &nbsp; }&nbsp; <br>&nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.swap(a, b);<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp;}<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h4><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br></code></pre></td></tr></tbody></table></figure><h4 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h4><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.getValue(<span class="hljs-keyword">out</span> a)<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br></code></pre></td></tr></tbody></table></figure><p>通过用户输入值再输出</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> y </span>)</span><br>      {<br>          Console.WriteLine(<span class="hljs-string">"请输入第一个值： "</span>);<br>          x = Convert.ToInt32(Console.ReadLine());<br>          Console.WriteLine(<span class="hljs-string">"请输入第二个值： "</span>);<br>          y = Convert.ToInt32(Console.ReadLine());<br>      }<br></code></pre></td></tr></tbody></table></figure><h3 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i; <span class="hljs-comment">//默认值0</span><br><span class="hljs-built_in">int</span>? ii; <span class="hljs-comment">//默认值nul</span><br></code></pre></td></tr></tbody></table></figure><h4 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h4><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br></code></pre></td></tr></tbody></table></figure><h4 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/* 初始化数组 n 中的元素 */</span>        <br><span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ )<br>{<br>   n[i] = i + <span class="hljs-number">100</span>;<br>}<br><span class="hljs-comment">/* 输出每个数组元素的值 */</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> j <span class="hljs-keyword">in</span> n )<br>{<br>   <span class="hljs-built_in">int</span> i = j<span class="hljs-number">-100</span>;<br>   Console.WriteLine(<span class="hljs-string">"Element[{0}] = {1}"</span>, i, j);<br>}<br></code></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs result">Element[0] = 100<br>Element[1] = 101<br>Element[2] = 102<br>...<br></code></pre></td></tr></tbody></table></figure><h3 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h3><h4 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h4><p>String 类有以下两个属性：</p><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table><h4 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h4><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator,        string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table><p>完整方法参考MSDN库</p><p>C# 结构体、枚举、类与C相同不再赘述</p><p>类的继承以  子类 ：父类 方式继承</p><p>多重继承以  子类：父类，父类  方式继承</p></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU</title>
    <link href="/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/"/>
    <url>/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>GPU（Graphics Processing Unit）图形处理器与CPU（Central Processing Unit）相比具有：</p><ol><li>高并行结构，因此在处理图形数据和复杂算法效率更高</li><li>更多的ALU（Arithmetic Logical Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，适合对密集型数据并行处理</li><li>CPU执行计算时是时间片轮转算法，GPU具有多个处理器核，在一个时刻可以并行处理多个数据 </li><li>流式并行计算模式，对每个数据进行独立计算，任意元素不依赖其他同类元素</li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>GPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希算法</title>
    <link href="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>哈希算法</strong>（Hash 算法，散列算法，消息摘要算法）将任意长度的二进制值映射为较短的固定长度的二进制值 ，这个小的二进制值称为哈希值。</p><p>简单来说就是通过哈希值快速定位到想要查找的记录，而不是通过表中存放的关键字来比较查找。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>哈希表是根据设定的哈希函数和处理冲突方法将<strong>一组关键字</strong>映射到<strong>一个有限的地址区间</strong>上，作为记录在表中的<strong>存储位置</strong>，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</li><li>通过将哈希算法应用到<strong>任意数量</strong>的数据会得到的<strong>固定大小</strong>的结果。如果输入数据中有变化，则哈希也会发生变化。哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”。</li><li>它是一种<strong>单向密码体制</strong>,即它是一个从明文到密文的不可逆的映射。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。</li><li>是一种基于Hash函数的文件构造方法，可对记录快速随机存取。把任意长关键字映射为一个固定长度的哈希值，一 般用于鉴权、认证、加密、索引等。其主要优点是<strong>运算简单</strong>，<strong>预处理时间较短</strong>，<strong>内存消耗低</strong>，匹配查找<strong>速度快</strong>，便于维护和刷新，支持匹配规则数多等。</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>如果对一个字符串数组进行查询。最快的检索办法是通过数组的下标进行检索，但是对于这种场景，只能从头查到尾，从而查询出目标元素。因此最坏情况下时间复杂度为O(n)，但是使用Hash可以将时间复杂度降为O(1)。</p><p>Hash表采用一个映射函数 function: key -&gt; address 将关键字映射到该记录在表中的存储位置，在想要查找该记录时，可以直接根据关键字和<strong>映射关系</strong>计算出该记录在表中的存储位置，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置（存储位置只是表中的存储位置，并不是实际的物理地址）称作为<strong>Hash地址</strong>。</p><p>比如上述例子中，假如字符串数组采用Hash表存储，则当想要找到字符串对应的信息时，直接根据字符串和Hash函数计算出 Hash 地址即可。所谓的 Hash 算法就是将字符串转换为数字的算法。例如我们可以将字符串数组的各个字符的ASCII码计算出，作为Hash表的地址，当需要哪个字符串时候就根据数字之间查找出，当然这是最笨的Hash算法。</p><h2 id="Hash函数设计"><a href="#Hash函数设计" class="headerlink" title="Hash函数设计"></a>Hash函数设计</h2><ol><li>直接定址法</li></ol><p>取关键字或者关键字的某个线性函数为 Hash 地址，即address(key) = a * key + b; 如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000(其中a = 1)作为Hash地址。</p><ol start="2"><li>平方取中法</li></ol><p>对关键字进行平方计算，取结果的中间几位作为 Hash 地址。如有以下关键字序列 {421，423，436} ，平方之后的结果为 {177241，178929，190096} ，那么可以取中间的两位数 {72，89，00} 作为 Hash 地址。</p><ol start="3"><li>折叠法</li></ol><p>将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。如图书的 ISBN 号为 8903-241-23，可以将address(key)=89+03+24+12+3 作为 Hash 地址。</p><ol start="4"><li>除留取余法</li></ol><p>如果知道 Hash 表的最大长度为 m，可以取不大于m的最大质数 p，然后对关键字进行取余运算，address(key)=key % p。这里 p 的选取非常关键，p 选择的好的话，能够最大程度地减少冲突，p 一般取不大于m的最大质数。</p><ol start="5"><li>基数转换法</li></ol><p>将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中若干为作为X的哈希值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。</p><ol start="6"><li>随机数法</li></ol><p>设定哈希函数为:H(key)=Random(key)其中，Random为伪随机函数</p><p>此法适于：对长度不等的关键字构造哈希函数。</p><ol start="7"><li>字符串数值哈希法</li></ol><p>把字符串的前10个字符的ASCⅡ值之和对N取摸作为Hash地址，只要N较小，Hash地址将较均匀分布[0，N]区间内。对于N很大的情形，可使用ELFHash(ExecutableandLinkingFormat,ELF,可执行链接格式)函数，它把一个字符串的绝对长度作为输入，并通过一种方式把字符的十进制值结合起来，对长字符串和短字符串都有效，这种方式产生的位置可能不均匀分布。</p><ol start="8"><li>旋转法</li></ol><p>旋转法是将数据的键值中进行旋转。旋转法通常并不直接使用在哈希函数上，而是搭配其他哈希函数使用。</p><h2 id="Hash-冲突及解决方案"><a href="#Hash-冲突及解决方案" class="headerlink" title="Hash 冲突及解决方案"></a>Hash 冲突及解决方案</h2><p>因为我们是用字符串数组对哈希值进行定值，有可能不同键值所得到的索引值相同，这里就是冲突。如不同的字符串可能ASCII总和是相同的，显然出现的这种情况是不合理的，解决该冲突的方法就是改变数据结构。我们将数组内的元素改变为一个链表，这样就能容下足够多的元素了，冲突问题也能得到解决。具体如何解决请看下面的链地址法。</p><ol><li>开放定址法</li></ol><p>发生冲突时，使用某种探测技术在 Hash 表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash 表长为14，Hash 函数为 address(key) = key % 11，当插入12，13，25时可以直接插入，而当插入 23 时，地址 1 被占用了（因为 12%11 和 23%11 的结果相同）。此时沿着地址 1 依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将 23 插入其中。</p><ol start="2"><li>链地址法</li></ol><p>采用数组和链表相结合的数据结构，将 Hash 地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如下图最左边是数组结构，数组内的元素为链表结构。</p><p><img src="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20230330224717657.png"></p><h2 id="Hash-表的用处以及优劣"><a href="#Hash-表的用处以及优劣" class="headerlink" title="Hash 表的用处以及优劣"></a>Hash 表的用处以及优劣</h2><ol><li>找出两文件找出重复的元素</li></ol><p>假设有两个文件，文件中均包含一些短字符串，字符串个数分别为n。它们是有重复的字符串，现在需要找出所有重复的字符串。</p><p>最笨的解决办法可能是：遍历文件 1 中的每个元素，取出每一个元素分别去文件 2 中进行查找，这样的时间复杂度为O（n^2）。</p><p>但是借助 Hash 表可以有一种相对巧妙的方法，分别遍历文件 1 中的元素和文件 2 中的元素，然后放入 Hash Table 中，对于遍历的每一个元素我们只要简单的做一下计数处理即可。最后遍历整个 Hash 列表，找出所有个数大于 1 的元素即为重复的元素。</p><ol start="2"><li>找出两文件找出出现次数最多的元素</li></ol><p>同找出两文件找出重复的元素这样的问题解决方案类似，只是在最后遍历的时找计数最大的元素，即为出现次数最多的元素。</p><ol start="3"><li>路由算法</li></ol><p>多线程处理数据的场景下，通常需要将一个数据集分给不同的线程进行处理，同时要保证，相同的元素需要分到相同的处理线程上。这其实这个就是一个很典型的 Hash 值应用场景，对于很多的计算引擎默认都是用 Hash 算法去解决这个问题。因为相同元素的 Hash 值相同，那么我们可以取 Hash 之后进行模运算，运算结果分配到不同的线程。</p><p>优点</p><p>哈希表的效率非常高，查找、插入、删除操作只需要接近常量的时间即0(1）的时间级。如果需要在一秒种内查找上千条记录通常使用哈希表，哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。如果不需要遍历数据，不二的选择。</p><p>缺点</p><p>它是基于数组的，数组创建后难于扩展。有些情况下，哈希表被基本填满时，性能下降得非常严重，所以开发者必须要清楚表中将要存储的数据量。或者也可以定期地把数据转移到更大的哈希表中，不过这个过程耗时相对比较大。</p><p>注意点</p><p>在设计Hash算法的时候。一定要保证相同字符串产生的 Hash 值相同，同时要尽量的减小Hash冲突的发生，这样才算是好的 hash 算法。</p><h2 id="哈希加盐"><a href="#哈希加盐" class="headerlink" title="哈希加盐"></a>哈希加盐</h2><p>我们知道，系统保存用户的密码时，一般不会直接保存下密码，而是通过md5加密后保存；</p><p>md5加密原理：Orz</p><p>md5已经是一种十分安全的加密方法了，但是通过彩虹表依旧可以破解（彩虹表原理），那么我们伟大机智的程序员们就想出了在密码后加一段序列然后再md5加密的方法，这个后面加上的序列就是所谓的 “ 盐 ” 。</p><p>具体的流程是：</p><p>用户注册时：</p><ol><li><p>用户在网站注册时提供ID与口令</p></li><li><p>系统随机为用户分配盐值</p></li><li><p>盐值插入口令后进行hash</p></li><li><p>将ID，hash值与盐值存入数据库</p></li></ol><p>身份验证时：</p><ol><li><p>用户提供ID与口令</p></li><li><p>系统在数据库中通过用户提供的ID查找HASH值与盐值</p></li><li><p>将盐值插入用户提供的口令后进行HASH</p></li><li><p>将HASH值与数据库中的HASH值比较，相等则验证成功，反之验证失败</p></li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache</title>
    <link href="/zhouyuchen/2023/02/08/Cache/"/>
    <url>/zhouyuchen/2023/02/08/Cache/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>CPU的运行速度是远远高于读写内存速度的，以当前嵌入式普遍使用的mcu来说，主频也普遍在几百Mhz，但是要知道使用的主存储器使用的动态存储器（DRAM）其存储速度在10Mhz左右。这样，如果指令和数据都存储在主存储器中，内存的速度会严重制约整个系统的性能。因此，为了解决内存速度低下，Cache就被引入了。可以说 Cache 是连接 CPU 和内存的桥梁。 </p><p>Cache全部是由硬件实现的，其不仅对于应用程序员是透明的，对系统程序员也是透明的，其是由速度与cpu速度相近的SRAM构成（Cahce和内存都是用的SRAM，那么速度为什么不同这是因为离CPU距离不同越近总线读写速度越快）。现在的处理器一般是通过多级缓存的组织形式来达到性能和功能的最优。但是其实对于多级cache还是一级cache，其原理是一致的，了解其原理后，多级和一级没有什么功能上的差异。</p><h2 id="Cache功能"><a href="#Cache功能" class="headerlink" title="Cache功能"></a>Cache功能</h2><p>cache是一种<strong>高速缓冲存储器</strong>，是为了解决CPU和主存之间速度不匹配而采用的一项重要技术</p><h2 id="Cache原理"><a href="#Cache原理" class="headerlink" title="Cache原理"></a>Cache原理</h2><p>cache原理是基于程序运行中具有的<strong>空间</strong>局限性和<strong>时间</strong>局限性特征。</p><p>空间局限性：在最近的未来要用到的信息(指令和数据)，很有可能与现在正在使用的信息在存储空间上是邻近的，如：数组元素、顺序执行的指令代码</p><p>时间局限性：在最近的未来要用到的信息，很可能是现在正在使用的信息，  如：循环结构的指令代码</p><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放在Cache中</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/zhouyuchen/2023/02/02/Redis/"/>
    <url>/zhouyuchen/2023/02/02/Redis/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是C语言开发的一个开源高性能键值对的<strong>内存数据库</strong>，可以用来做数据库、缓存、消息中间件等场景，是一种NoSQL(not-only sql,非关系型数据库)的数据库。</p><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>优秀的性能，数据是存储在内存中，读写速度非常快，可支持并发10W QPS(一般指每秒查询率)</li><li>单线程但进程，是线程安全的，采用IO 多路复用制</li><li>可作为分布式锁</li><li>支持五种数据类型</li><li>支持数据持久化到磁盘</li><li>可以作为消息中间件使用，支持消息发布及订阅</li></ul><h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。       </li></ul><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>每个 hash 可以存储 23^2 -1 键值对（40多亿）。</p><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表最多可存储  23^2 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis  zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><table><thead><tr><th align="center">类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td align="center">String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td align="center">Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td align="center">List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td align="center">Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td align="center">Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><p>Redis中文文档链接: <a href="http://www.redis.cn/documentation.html">http://www.redis.cn/documentation.html</a></p><p>Redis英文文档 <a href="https://redis.io/topics/data-types">https://redis.io/topics/data-types</a></p><p>Redis官网:<a href="http://redis.io/">http://redis.io/</a></p><p>Redis官方文档:<a href="http://redis.io/documentation">http://redis.io/documentation</a></p></body></html>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是冒泡排序的改进，之所以快速是由于运用了<strong>分治法</strong></p><p>主要思路：</p><ol><li>选择一个数为基准点</li><li>从左往右，将数与基准点相比较，同时从右往左将数与基准点相比较</li><li>当左边的数比基准点大时，同时右边的数比基准点小时，把两数交换</li><li>此时左边的数都小于基准点，右边的数都大于基准点。此时以基准点拆分成2队，重复执行步骤2，3，4</li></ol><p>如下是<strong>一次快排</strong>图解，选用了中点（pivot）作为基准点</p><p><img src="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/a.png"></p><p>下面用个简单的实例说明：</p><p><img src="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20230317124246696.png"></p><p>这是以20作为了基准点，进行一次快排的过程</p><p>之后以20为基准点分为左右两队再进行快排便可以得到结果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>{<br>    <span class="hljs-type">int</span> i = left, j = right;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-comment">// 基准点</span><br>    <span class="hljs-type">int</span> pivot;<br><br>    pivot = arr[(i + j) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt;= j)<br>    {<br>        <span class="hljs-comment">// 从左到右边找到大于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[i] &lt; pivot)<br>        {<br>            i++;<br>        }<br>        <span class="hljs-comment">// 从右到左边找到小于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[j] &gt; pivot)<br>        {<br>            j--;<br>        }<br>        <span class="hljs-comment">// 如果i&lt;=j则互换元素</span><br>        <span class="hljs-keyword">if</span> (i &lt;= j)<br>        {<br>            temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (left &lt; j)<br>    {<br>        quick_sort(arr, left, j);<br>    }<br>    <span class="hljs-keyword">if</span> (i &lt; right)<br>    {<br>        quick_sort(arr, i, right);<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">21</span>, <span class="hljs-number">2</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>};<br>    <span class="hljs-type">int</span> i, len;<br>    len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    quick_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i]);<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔</title>
    <link href="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>经典递归问题：汉诺塔</p><p>汉诺塔的本质（x，y，z三根柱）：</p><ol><li>将n-1层从x移动到y</li><li>将第n层从x移动到z</li><li>将n-1层从y移动到z    </li></ol><p>三步解决</p><p>因此用递归的方法，只需考虑2层时候的代码（把第一层看作是n-1层，第二层看作是n层）</p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(1).png"></p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(2).png"></p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(3).png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span><br>{<br>    <span class="hljs-comment">//判断n的层数，如果为一层直接移动x到z</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c ---&gt;  %c\n"</span>, x, z);<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<span class="hljs-comment">//当n！=1时候，将再次调用函数，移动n-1层：x到y，也就是把y和z互换</span><br>        hanoi(n - <span class="hljs-number">1</span>, x, z, y);<br>        <span class="hljs-comment">//移动第n层：x到z</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c ---&gt;  %c\n"</span>, x, z);<br>        <span class="hljs-comment">//最后移动n-层：y到z</span><br>        hanoi(n - <span class="hljs-number">1</span>, y, x, z);<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入汉诺塔的层数：\n"</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    hanoi(n, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汉诺塔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git问题记录</title>
    <link href="/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Git问题记录"><a href="#Git问题记录" class="headerlink" title="Git问题记录"></a>Git问题记录</h1><p>本文章记录使用Git遇到的问题，方便以后的查阅解决</p><h2 id="撤消尚未推送的Git合并"><a href="#撤消尚未推送的Git合并" class="headerlink" title="撤消尚未推送的Git合并"></a>撤消尚未推送的Git合并</h2><p>通过git-reset - 重置当前HEAD到指定的状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard <br>git reset --hard ORIG_HEAD<br>git reset --merge ORIG_HEAD<br></code></pre></td></tr></tbody></table></figure><ol><li>没有进行合并提交，所以<code>git reset --hard</code>是<code>git reset --hard HEAD</code>的同义词，它清除了索引文件和工作树上的混乱。</li><li>“pull “或 “merge “总是在<code>ORIG_HEAD</code>中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。</li><li>在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。 运行<code>git reset --hard ORIG_HEAD</code>可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。 <code>git reset --merge</code>会保留你的本地修改。</li></ol><h2 id="恢复已经删除的提交"><a href="#恢复已经删除的提交" class="headerlink" title="恢复已经删除的提交"></a>恢复已经删除的提交</h2><p>当需要恢复已经删除的提交记录时候</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br>git rest --hard commitID<br>git push origin HEAD --force<br></code></pre></td></tr></tbody></table></figure><ol><li>通过reflog找到删除的提交的ID</li><li>执行上述命令，加上提交的ID即可恢复</li><li>本地退回后强制推送到远程仓库</li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/zhouyuchen/2023/01/02/React/"/>
    <url>/zhouyuchen/2023/01/02/React/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>这篇博客是记录我react入门学习笔记，供我自己参考。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>React：用于构建用户界面的JavaScript库（将数据渲染为HTML视图的JS库）</p><h3 id="为什么要学"><a href="#为什么要学" class="headerlink" title="为什么要学"></a>为什么要学</h3><ol><li>原生JS操作DOM繁琐，效率低。</li><li>原生JS操作DOM会使浏览器大量重绘重排。</li><li>原生JS没有组件化的编码方案，代码复用率低。</li></ol><p>React特点：</p><ol><li>采用组件化模式，<strong>声明式编码</strong>，提高开发效率和组件复用率。</li><li>React Native 中可以使用React语法进行<strong>移动端开发</strong></li><li>使用<strong>虚拟DOM</strong>和优秀的<strong>Diffing算法</strong>，尽量减少与真实DOM的交互 </li></ol><h2 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h2><p>核心库必须先引入</p><p>babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p><p>react下载官网：<a href="http://react-cn.github.io/react/downloads.html">http://react-cn.github.io/react/downloads.html</a></p><p><strong>官方提供的：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引入react核心库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react@16/umd/react.development.js"</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入babel，用于jsx转为js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/@babel/standalone/babel.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>Staticfile CDN 的 React CDN 库：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>用JSX（JS+XML）创建虚拟DOM</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">"test"</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/babel"</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//创建虚拟DOM,不要写引号</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello,react<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//渲染虚拟DOM到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'test'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><p>用JS创建虚拟DOM</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;<br><span class="hljs-comment">//创建虚拟DOM,不要写引号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'h1'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'title'</span> }, <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, {}, <span class="hljs-string">'hello React'</span>))<br><span class="hljs-comment">//渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'test'</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>可以看出JSX使用就如同写HTML一样方便，但是如果要嵌套多个标签，JS会大量增加重复的代码</p><p>关于虚拟DOM：</p><ol><li>本质是Object对象</li><li>虚拟DOM属性少，真实DOM属性多，因为虚拟DOM是React内部使用，无需那些多余的属性</li><li>虚拟DOM最终会被React转换为真实DOM，呈现在页面上</li></ol><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ol><li><p>定义虚拟DOM时，不要写引号。</p></li><li><p>标签混入JS表达式时用{}。</p></li><li><p>样式类名指定不要用class，用className</p></li><li><p>内联样式，要用style=的形式去写</p></li><li><p>虚拟DOM必须只有一个根标签</p></li><li><p>标签必须闭合</p></li><li><p>标签首字符</p><p>1）若<strong>小写字母</strong>开头，则将标签转为html中<strong>同名元素</strong>，若html中无，则报错</p><p>2）若<strong>大写字母</strong>开头，react渲染<strong>对应的组件</strong>，若组件未定义，则报错</p></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>JSX使用JavaScript表达式，表达式写在花括号 <strong>{}</strong> 中</p><p>在 JSX 中不能使用 <strong>if else</strong> 语句，但可以使用 <strong>conditional (三元运算)</strong> 表达式来替代。以下实例中如果变量 <strong>i</strong> 等于 <strong>1</strong> 浏览器将输出 <strong>true</strong>, 如果修改 i 的值，则会输出 <strong>false</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{i == 1 ? 'True!' : 'False'}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type="text/babel"&gt;<br>    console.log(this)//此处this是undefined 因为babel编译后开启了严格模式<br>    function MyComponent() {<br>        return &lt;h1&gt;函数定义的组件&lt;/h1&gt;<br>    }<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById("test"))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>执行ReactDOM.render(<mycomponent>…)</mycomponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由函数定义的，随后调用函数，将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type="text/babel"&gt;<br>    class MyComponent extends React.Component {<br>        render() {<br>            console.log(this)//MyComponent实例<br>            return &lt;h1&gt;我是类定义的组件&lt;/h1&gt;<br>        }<br>    }<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById("test"))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>执行ReactDOM.render(<mycomponent>…)</mycomponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由类定义的，随后new该类的实例，并通过该实例调用到原型上的render方法</li><li>将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state是组件对象的重要属性，值是对象（可以包含多个key-value的组合）</p><p>React的组件被看为”状态机“，通过更新组件的state来更新对象对应的页面显示（重新渲染组件，不需要操作DOM）</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>[^自定义function中默认开启了严格模式，所以function中的this为undefined]:</p><ol><li><p>组件中的render方法中的this为实例对象</p></li><li><p>组件自定义的方法中的this为undefined解决方式：</p><ol><li>强制绑定this：通过函数对象的bind(this)</li><li>箭头函数</li></ol></li><li><p>状态数据，不能直接修改或者更新</p></li></ol><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>state 和 props 主要的区别在于 <strong>props</strong> 是不可变的，而 state 可以根据与用户交互来改变。 state 来更新和修改数据，子组件只能通过 props 来传递数据。</p></body></html>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>807</title>
    <link href="/zhouyuchen/2022/12/22/807/"/>
    <url>/zhouyuchen/2022/12/22/807/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="807"><a href="#807" class="headerlink" title="807"></a>807</h1><h2 id="15年"><a href="#15年" class="headerlink" title="15年"></a>15年</h2><p><img src="/zhouyuchen/2022/12/22/807/15_1.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/15_2.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/15_3.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/15_4.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/15_5.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/15_6.jpg"></p><h2 id="16年"><a href="#16年" class="headerlink" title="16年"></a>16年</h2><p><img src="/zhouyuchen/2022/12/22/807/16_1.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/16_2.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/16_3.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/16_4.jpg"></p><h2 id="17年"><a href="#17年" class="headerlink" title="17年"></a>17年</h2><p><img src="/zhouyuchen/2022/12/22/807/17_1.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/17_2.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/17_3.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/17_4.jpg"></p><h2 id="18年"><a href="#18年" class="headerlink" title="18年"></a>18年</h2><p><img src="/zhouyuchen/2022/12/22/807/18_1.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/18_2.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/18_3.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/18_4.jpg"></p><h2 id="19年"><a href="#19年" class="headerlink" title="19年"></a>19年</h2><p><img src="/zhouyuchen/2022/12/22/807/19_1.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/19_2.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/19_3.jpg"></p><p><img src="/zhouyuchen/2022/12/22/807/19_4.jpg"></p></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>809</title>
    <link href="/zhouyuchen/2022/12/22/809/"/>
    <url>/zhouyuchen/2022/12/22/809/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="809"><a href="#809" class="headerlink" title="809"></a>809</h1><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p><img src="/zhouyuchen/2022/12/22/809/8(11).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(12).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(13).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(14).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(15).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(8).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(9).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/8(10).jpg"></p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p><img src="/zhouyuchen/2022/12/22/809/1(1).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/1(2).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/1(3).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/1(4).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/1(5).jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/1(6).jpg"></p><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p><img src="/zhouyuchen/2022/12/22/809/182.jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/183.jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/184.jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/185.jpg"></p><p><img src="/zhouyuchen/2022/12/22/809/186.jpg"></p></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C算法记录</title>
    <link href="/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="C算法记录"><a href="#C算法记录" class="headerlink" title="C算法记录"></a>C算法记录</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>{<br>    <span class="hljs-comment">//定义一个静态的全局变量，用于存放数组下标，大小为2</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>]={<span class="hljs-number">0</span>};<span class="hljs-comment">//int *res=(int*)malloc(sizeof(int)*2);</span><br>    <span class="hljs-comment">//返回值大小</span><br>    *returnSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//暴力遍历所有方法，默认为有解，i只需遍历到数组倒数第二个值，j跟随i的变化而变化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++){<br>            <span class="hljs-comment">//将每一种可能与target比较</span><br>            <span class="hljs-keyword">if</span>(*(nums+i)+*(nums+j)==target){<br>                <span class="hljs-comment">//存入res数组中并且返回</span><br>                res[<span class="hljs-number">0</span>]=i;<br>                res[<span class="hljs-number">1</span>]=j;<br>                <span class="hljs-keyword">return</span> res;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>错误记录：</strong></p><p>​    使用int res[2]</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line <span class="hljs-number">207</span>: Char <span class="hljs-number">3</span>: runtime error: load of null pointer of type <span class="hljs-string">'int'</span> [__Serializer__.c]<br></code></pre></td></tr></tbody></table></figure><p>​    空指针异常</p><p>​    力扣提示Note: The returned array must be malloced, assume caller calls free().</p><p>​    因为函数返回的是指针地址指向函数内的局部变量数组，在函数退出时，数组的存储空间会被销毁，此时去访问该地址就会出现这个错误。</p><p><strong>解决办法：</strong></p><p>​    使用malloc函数，当malloc函数被调用时，它会沿空闲链表寻找一个可以满足需求的内存块，然后把所需大小的内存块分配给用户，剩下的返回到链表上。free函数被调用时，它将释放的内存块连接到空闲链表上。</p><p>​    malloc函数声明：void *malloc (int size)；向系统申请分配size字节的内存空间。</p><p>​    因为malloc返回是void类型指针，因此使用时候要强制转换为int：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *res=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*sizeNums);<br></code></pre></td></tr></tbody></table></figure><p>​    </p></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExcelReader</title>
    <link href="/zhouyuchen/2022/12/08/ExcelReader/"/>
    <url>/zhouyuchen/2022/12/08/ExcelReader/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="ExcelReader"><a href="#ExcelReader" class="headerlink" title="ExcelReader"></a>ExcelReader</h1><h2 id="用户导入"><a href="#用户导入" class="headerlink" title="用户导入"></a>用户导入</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping("/import")</span><br>        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">imp</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception {<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br>                <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> ExcelUtil.getReader(inputStream);<br>                <span class="hljs-comment">// 方式1：(推荐) 通过 javabean的方式读取Excel内的对象，但是要求表头必须是英文，跟javabean的属性要对应起来</span><br><span class="hljs-comment">//        List&lt;User&gt; list = reader.readAll(User.class);</span><br><br>                <span class="hljs-comment">// 方式2：忽略表头的中文，直接读取表的内容</span><br>                List&lt;List&lt;Object&gt;&gt; list = reader.read(<span class="hljs-number">1</span>);<br>                List&lt;User&gt; users = CollUtil.newArrayList();<br>                <span class="hljs-keyword">for</span> (List&lt;Object&gt; row : list) {<br>                        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                        user.setUsername(row.get(<span class="hljs-number">0</span>).toString());<br>                        user.setPassword(row.get(<span class="hljs-number">1</span>).toString());<br>                        users.add(user);<br>                }<br>                userService.saveBatch(users);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br></code></pre></td></tr></tbody></table></figure><h2 id="用户导出"><a href="#用户导出" class="headerlink" title="用户导出"></a>用户导出</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping("/export")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 从数据库查询出所有的数据</span><br>        List&lt;User&gt; list = userService.list();<br>        <span class="hljs-comment">// 通过工具类创建writer 写出到磁盘路径</span><br><span class="hljs-comment">//        ExcelWriter writer = ExcelUtil.getWriter(filesUploadPath + "/用户信息.xlsx");</span><br>        <span class="hljs-comment">// 在内存操作，写出到浏览器</span><br>        <span class="hljs-type">ExcelWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> ExcelUtil.getWriter(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//自定义标题别名</span><br>        writer.addHeaderAlias(<span class="hljs-string">"username"</span>, <span class="hljs-string">"用户名"</span>);<br>        writer.addHeaderAlias(<span class="hljs-string">"password"</span>, <span class="hljs-string">"密码"</span>);<br><br>        <span class="hljs-comment">// 一次性写出list内的对象到excel，使用默认样式，强制输出标题</span><br>        writer.write(list, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 设置浏览器响应的格式</span><br>        response.setContentType(<span class="hljs-string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8"</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> URLEncoder.encode(<span class="hljs-string">"用户信息"</span>, <span class="hljs-string">"UTF-8"</span>);<br>        response.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;filename="</span> + fileName + <span class="hljs-string">".xlsx"</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        writer.flush(out, <span class="hljs-literal">true</span>);<br>        out.close();<br>        writer.close(); <br>    }<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExcelReader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-plus</title>
    <link href="/zhouyuchen/2022/12/04/Mybatis-plus/"/>
    <url>/zhouyuchen/2022/12/04/Mybatis-plus/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="Spring-Boot-集成Mybatis-plus"><a href="#Spring-Boot-集成Mybatis-plus" class="headerlink" title="Spring Boot 集成Mybatis-plus"></a>Spring Boot 集成Mybatis-plus</h2><p>在pom.xml引入Mybatis-plus </p><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>创建MybatisPlusConfig （我用的是MySQL数据库）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guanli.xitong.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan("你的mapper的reference")</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> {<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> {<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<span class="hljs-comment">//使用MySQL</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>编写 Mapper 包下的 <code>UserMapper</code>接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; {}<br></code></pre></td></tr></tbody></table></figure><p>即可开始使用</p><p>下面是例子（分页查询）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询 mybatis plus</span><br><span class="hljs-meta">@GetMapping("/")</span><br><span class="hljs-keyword">public</span> IPage&lt;User&gt; <span class="hljs-title function_">findPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer pageNum,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> Integer pageSize,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(defaultValue = "")</span> String username,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> (defaultValue = <span class="hljs-string">""</span>)</span>String nikename,<br>                            <span class="hljs-meta">@RequestParam(defaultValue = "")</span> String address) {<br>    IPage&lt;User&gt;page=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum,pageSize);<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">"username"</span>,username);<br>    queryWrapper.like(<span class="hljs-string">"nikename"</span>,nikename);<br>    queryWrapper.like(<span class="hljs-string">"address"</span>,address);<span class="hljs-comment">//通过Mybatis-plus的methods可知自动拼接条件查询</span><br>    <span class="hljs-keyword">return</span> userService.page(page, queryWrapper);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Mybatis-plus代码生成器"><a href="#Mybatis-plus代码生成器" class="headerlink" title="Mybatis-plus代码生成器"></a>Mybatis-plus代码生成器</h2><h3 id="java-sql-SQLException-No-suitable-driver-found"><a href="#java-sql-SQLException-No-suitable-driver-found" class="headerlink" title="java.sql.SQLException: No suitable driver found"></a>java.sql.SQLException: No suitable driver found</h3><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689644096.jpg"></p><p>原因是因为mysql-connector-java依赖版本太低，或者没有导入，换成高版本即可(我这使用的是8.0.17)</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>还需要导入的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意和你的Mybatis-plus版本号一致--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>完整配置代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>    String url= <span class="hljs-string">"jdbc:mysql://localhost:3306/你的数据库名称?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8"</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"你的数据库用户名"</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"你的数据库密码"</span>;<br>    FastAutoGenerator.create(url, username, password)<br>            .globalConfig(builder -&gt; {<br>                builder.author(<span class="hljs-string">"你的名字"</span>) <span class="hljs-comment">// 设置作者</span><br>                        .fileOverride() <span class="hljs-comment">// 覆盖已生成文件</span><br>                        .outputDir(<span class="hljs-string">"...\\java\\"</span>); <span class="hljs-comment">// 指定输出目录</span><br>            })<br>            .packageConfig(builder -&gt; {<br>                builder.parent(<span class="hljs-string">"com.xx.xx"</span>) <span class="hljs-comment">// 设置父包名</span><br>                        .moduleName(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 设置父包模块名 </span><br>                        .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="hljs-string">"...mapper\\"</span>)); <span class="hljs-comment">// 设置mapperXml生成路径 copy mapper reference</span><br>            })<br>            .strategyConfig(builder -&gt; {<br>                builder.entityBuilder().enableLombok();<span class="hljs-comment">//开启Lombok</span><br>                builder.controllerBuilder().enableHyphenStyle()  <span class="hljs-comment">// 开启驼峰转连字符</span><br>                    .enableRestStyle();  <span class="hljs-comment">// 开启生成@RestController 控制器</span><br>                builder.addInclude(<span class="hljs-string">"你的数据库表名"</span>) <span class="hljs-comment">// 设置需要生成的表名</span><br>                        .addTablePrefix(<span class="hljs-string">"t_"</span>, <span class="hljs-string">"b_"</span>); <span class="hljs-comment">// 设置过滤表前缀</span><br>            })<br>            .execute();<br>}<br></code></pre></td></tr></tbody></table></figure><p>配置完后运行main方法即可看到生成的代码框架</p><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689725109.jpg"></p><h3 id="CRUD模板"><a href="#CRUD模板" class="headerlink" title="CRUD模板"></a>CRUD模板</h3><p>在mybatis-plus-generator-版本号.jar（我这里是3.5.1）</p><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689933873.jpg"></p><p>选择controller.java.vm复制到resource包下的templates中</p><p>导包：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><br><span class="hljs-keyword">import</span> $!{<span class="hljs-keyword">package</span>.Service}.$!{table.serviceName};<br><span class="hljs-keyword">import</span> ${<span class="hljs-keyword">package</span>.Entity}.${entity};<br></code></pre></td></tr></tbody></table></figure><p>在文件最后的end下加入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ${table.serviceName} ${table.entityPath}Service;<br><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ${entity} ${table.entityPath})</span> {<span class="hljs-comment">//保存或者更新</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.saveOrUpdate(${table.entityPath});<br>        }<br><br><span class="hljs-meta">@DeleteMapping("/{id}")</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> {<span class="hljs-comment">//删除</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.removeById(id);<br>        }<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> List&lt;${entity}&gt; findAll() {<span class="hljs-comment">//查询所有</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.list();<br>        }<br><br><span class="hljs-meta">@GetMapping("/{id}")</span><br><span class="hljs-keyword">public</span> ${entity} findOne(<span class="hljs-meta">@PathVariable</span> Integer id) {<span class="hljs-comment">//按照ID查询</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.getById(id);<br>        }<br><br><span class="hljs-meta">@GetMapping("/page")</span><br><span class="hljs-keyword">public</span> Page&lt;${entity}&gt; findPage(<span class="hljs-meta">@RequestParam</span> Integer pageNum,<span class="hljs-comment">//分页</span><br><span class="hljs-meta">@RequestParam</span> Integer pageSize) {<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum, pageSize),queryWrapper);<br>        }<br><br><span class="hljs-meta">@PostMapping("/del/batch")</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Integer&gt; ids)</span> {<span class="hljs-comment">//批量删除</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.removeBatchByIds(ids);<br>        }<br></code></pre></td></tr></tbody></table></figure><p>运行之前的main方法即可生成</p><p>其他模板同理！</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot跨域</title>
    <link href="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/"/>
    <url>/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="SpringBoot跨域"><a href="#SpringBoot跨域" class="headerlink" title="SpringBoot跨域"></a>SpringBoot跨域</h1><p>在前端访问后端出现跨域问题时候</p><p><img src="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/image-20230202115339681-16753100243391.png" alt="image-20230202115339681"></p><p>通过创建一个CorsConfig .java配置文件来解决，重启即可跨域访问，前端无需配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<br><span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> {<br><br><span class="hljs-comment">// 当前跨域请求最大有效时长。这里默认1天</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>    corsConfiguration.addAllowedOrigin(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 1 设置访问源地址，即为前端的地址</span><br>    corsConfiguration.addAllowedHeader(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 2 设置访问源请求头</span><br>    corsConfiguration.addAllowedMethod(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 3 设置访问源请求方法</span><br>    corsConfiguration.setMaxAge(MAX_AGE);<br>    source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, corsConfiguration); <span class="hljs-comment">// 4 对接口配置跨域设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>}<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git上传仓库</title>
    <link href="/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <url>/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="使用Git上传到码云仓库"><a href="#使用Git上传到码云仓库" class="headerlink" title="使用Git上传到码云仓库"></a>使用Git上传到码云仓库</h1><p>在码云新建仓库后</p><p>在需要上传的文件夹右键点击Git Bush Here</p><p>git init进行初始化</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init <br></code></pre></td></tr></tbody></table></figure><p>点击克隆，复制你仓库的HTTPS路径，输入git remote add origin + 复制路径</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin<br></code></pre></td></tr></tbody></table></figure><p>git pull origin master 命令，将码云上的仓库pull到本地文件夹</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></tbody></table></figure><p>git add . （. 表示所有的）或者 git add + 文件名 ，将文件保存到暂存区</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></tbody></table></figure><p>git commit -m “文件描述”</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m<br></code></pre></td></tr></tbody></table></figure><p>git push origin master ，推送到码云仓库</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></tbody></table></figure><p>刷新即可</p></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Git</title>
    <link href="/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/"/>
    <url>/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="了解Git"><a href="#了解Git" class="headerlink" title="了解Git"></a>了解Git</h1><p>Git（读音为/gɪt/）是一个开源的<strong>分布式</strong>版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h2 id="Git和SVN区别"><a href="#Git和SVN区别" class="headerlink" title="Git和SVN区别"></a>Git和SVN区别</h2><ol><li>核心区别：Git是分布式的，SVN不是</li><li>Git按照元数据方式存储，SVN按照文件方式存储</li><li>Git分支有多种使用方法，例如：创建、切换、合并、删除、跟踪等等，SVN仅仅是另一个文件目录</li><li>Git没有全局的版本号，SVN有</li><li>Git内容存储使用SHA-1哈希算法，有效确保代码内容的完整性</li></ol><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。 </li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h2><p>工作区：你电脑看到的目录</p><p>暂存区：一般存放在.git/index，所以又称为索引（index或者stage）</p><p>版本库：隐藏的.git目录</p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支意味着从开发主线分离出来，而且在不影响主线的情况下同时继续工作</p><p>Git分支分支实际上是指向更改快照的指针</p><p>创建分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch (branchname)<br></code></pre></td></tr></tbody></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (branchname)<br></code></pre></td></tr></tbody></table></figure><p>合并分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge <br></code></pre></td></tr></tbody></table></figure><p>列出分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></tbody></table></figure><p>创建分支并且切换到该分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b (branchname)<br></code></pre></td></tr></tbody></table></figure><p>删除分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (branchname)<br></code></pre></td></tr></tbody></table></figure><p>如果合并发现冲突需要手动修改</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add<br>git commit<br></code></pre></td></tr></tbody></table></figure><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log //查看历史提交记录<br>git log --oneline //查看历史记录的简洁的版本<br>git log --graph //查看历史中什么时候出现了分支、合并<br>git log --reverse --oneline //逆向显示所有日志<br>git log --author //查找指定用户的提交日志<br>git blame &lt;file&gt; //以列表的形式查看指定文件的历史修改记录<br></code></pre></td></tr></tbody></table></figure><h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><p>为什么要使用标签，直接commit不好吗？</p><p>标签即为版本库的一个快照，通过添加标签，可以更加方便查找到版本号：</p><p>commit号可能是51234c…</p><p>标签可以是v1.0</p><p>当达到一个重要阶段，并且希望更加方便记住这个提交，可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v1.0 //-a意为创建一个带有注解的标签，可以不加<br></code></pre></td></tr></tbody></table></figure><p>查看已有标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag<br></code></pre></td></tr></tbody></table></figure><p>删除标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d 版本号<br></code></pre></td></tr></tbody></table></figure><p>查看该标签修改的内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git show 版本号<br></code></pre></td></tr></tbody></table></figure><h2 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h2><p>这是一个Git的图形界面工具（GUI），SourceTree 简化了开发者与代码仓库之间的 Git 操作方式，我们可以通过界面菜单很方便的处理 Git 操作，而不需要通过命令。</p><p>可以在 Sourcetree 官网 <a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a> 直接点击下载按钮来下载，根据提示安装。</p></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>了解Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS方法</title>
    <link href="/zhouyuchen/2022/02/04/JS%E6%96%B9%E6%B3%95/"/>
    <url>/zhouyuchen/2022/02/04/JS%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="JS方法"><a href="#JS方法" class="headerlink" title="JS方法"></a>JS方法</h1><p>备忘一下常用的JS方法</p><h2 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...numbers</span>){<br>    <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">reduce</span>(preValue,currentValue)=&gt;{<br>        <span class="hljs-keyword">return</span> preValue + currentValue<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣</title>
    <link href="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/"/>
    <url>/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160612408.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160645305.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160658443.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160719623.png"></p><p>主要是先建立2个指针，一个指针移动，一个指针返回值，通过carry表示进位，如果为1就进位，如果为0就直接返回。</p><h2 id="指针滑动窗口"><a href="#指针滑动窗口" class="headerlink" title="指针滑动窗口"></a>指针滑动窗口</h2><p>java的方法：</p><ul><li>```java<br>string.charAt(i)<br>//用于返回string字符串i位置的字符HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()<br>map.put(“key”,1)<br>string key=”apple”<br>boolean contains=map.containsKey(key)<br>//用于比较key值是否包含指定的值<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```java <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<span class="hljs-comment">//最长子串长度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左下标，i相当于滑动窗口右下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++){<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">containsKey</span>(s.<span class="hljs-built_in">charAt</span>(i))){<span class="hljs-comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span><br>                left = Math.<span class="hljs-built_in">max</span>(left,map.<span class="hljs-built_in">get</span>(s.<span class="hljs-built_in">charAt</span>(i)) + <span class="hljs-number">1</span>);       <span class="hljs-comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span><br>            }        <span class="hljs-comment">//map.get('a')=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span><br>            map.<span class="hljs-built_in">put</span>(s.<span class="hljs-built_in">charAt</span>(i),i);      <span class="hljs-comment">//再更新map中a映射的下标</span><br>            max = Math.<span class="hljs-built_in">max</span>(max,i-left+<span class="hljs-number">1</span>);     <span class="hljs-comment">//比较两个参数的大小</span><br>        }<br>        <span class="hljs-keyword">return</span> max;<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></body></html>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装</title>
    <link href="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/"/>
    <url>/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h1><p>由于node版本太低，记录一下更新node</p><p>node中文下载地址：：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/12.jpg"></p><p>对应电脑系统选择（windows）</p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/1673433881757.jpg"></p><p>通过</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">where node<br></code></pre></td></tr></tbody></table></figure><p>查看自己node安装位置</p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/1673434014083.jpg"></p><p>将文件内容全部替换为压缩包内容即可</p><p>查看是否成功：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
