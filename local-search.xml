<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>矩阵向量</title>
    <link href="/zhouyuchen/2024/04/24/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F/"/>
    <url>/zhouyuchen/2024/04/24/%E7%9F%A9%E9%98%B5%E5%90%91%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="矩阵向量"><a href="#矩阵向量" class="headerlink" title="矩阵向量"></a>矩阵向量</h1><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><p>矩阵缩放</p><p><img src="/zhouyuchen/.io//image-20240424173456304.png" alt="image-20240424173456304"></p><p>修改对角线的值</p><p><img src="/zhouyuchen/.io//image-20240424173512613.png" alt="image-20240424173512613"></p><p>旋转</p><p><img src="/zhouyuchen/.io//image-20240424173521492.png" alt="image-20240424173521492"></p><p><img src="/zhouyuchen/.io//image-20240424173623412.png" alt="image-20240424173623412"></p><p>移动</p><p><img src="/zhouyuchen/.io//image-20240424173747943.png" alt="image-20240424173747943"></p>]]></content>
    
    
    <categories>
      
      <category>矩阵向量</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵向量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析</title>
    <link href="/zhouyuchen/2024/04/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1/"/>
    <url>/zhouyuchen/2024/04/23/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="KMP百元买百鸡-蛮力法"><a href="#KMP百元买百鸡-蛮力法" class="headerlink" title="KMP百元买百鸡-蛮力法"></a>KMP百元买百鸡-蛮力法</h2><h2 id="减治、分治思想、选择问题、假币问题、约瑟夫问题"><a href="#减治、分治思想、选择问题、假币问题、约瑟夫问题" class="headerlink" title="减治、分治思想、选择问题、假币问题、约瑟夫问题"></a>减治、分治思想、选择问题、假币问题、约瑟夫问题</h2><h2 id="棋盘覆盖、循环日程安排、最近点对"><a href="#棋盘覆盖、循环日程安排、最近点对" class="headerlink" title="棋盘覆盖、循环日程安排、最近点对"></a>棋盘覆盖、循环日程安排、最近点对</h2><h2 id="动态规划、数据问题、最长递增子序列、背包问题、动态规则表、算法策略"><a href="#动态规划、数据问题、最长递增子序列、背包问题、动态规则表、算法策略" class="headerlink" title="动态规划、数据问题、最长递增子序列、背包问题、动态规则表、算法策略"></a>动态规划、数据问题、最长递增子序列、背包问题、动态规则表、算法策略</h2><h2 id="贪心、图着色、背包问题思想伪代码时间复杂度"><a href="#贪心、图着色、背包问题思想伪代码时间复杂度" class="headerlink" title="贪心、图着色、背包问题思想伪代码时间复杂度"></a>贪心、图着色、背包问题思想伪代码时间复杂度</h2><h2 id="回溯-n皇后-剪枝-约束条件-图着色-背包问题"><a href="#回溯-n皇后-剪枝-约束条件-图着色-背包问题" class="headerlink" title="回溯 n皇后 剪枝 约束条件 图着色 背包问题"></a>回溯 n皇后 剪枝 约束条件 图着色 背包问题</h2><p>判断题 填空题 选择题 （总共40分）；综合题目（60分-4题）</p>]]></content>
    
    
    <categories>
      
      <category>算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p>半监督学习：监督学习和无监督学习</p><p>监督学习：数据有标签、一般为回归或分类</p><p>无监督学习：数据无标签、一般为聚类或若干降维任务</p><p>强化学习：序列数据决策学习、一般为从环境交互中学习</p><p>在无监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些<br>内在结构;</p><p>在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果</p><p>常见的应用场景包括关联规则的学习以及聚类等。常见算法包括Apriori算法和k-Means算法</p><p>半监督学习是介于监督学习与无监督学习之间一种机器学习方式，主要考虑如可利用<strong>少量的标注样本</strong>和<strong>大量的未标注样本</strong>进行训练和分类的问题;</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p><strong>中值是奇数个中间的值或者偶数个中间两个数的平均值。</strong></p><p>已知一组价格数据：15,21,24,21,25,4,8,34,28<br>现用等深（深度为3）分箱方法对其进行平滑，以对数据中的噪声进行处理。</p><p>首先进行排序：</p><p>排序后价格:4，8，15，21，21，24 ，25，28，34</p><p>划分为等高度：</p><p>Bin1：4，8，15</p><p>Bin2：21，21，24</p><p>Bin3：25，28，34</p><p>根据Bin均值进行平滑</p><p>Bin1：9，9，9</p><p>Bin2：22，22，22</p><p>Bin3：29，29，29</p><p>根据Bin边界进行平滑</p><p>Bin1：4，4，15</p><p>Bin2：21，21，24</p><p>Bin3：25，25，34</p><p>根据Bin中值进行平滑</p><p>Bin1：8，8，8</p><p>Bin2：21，21，21</p><p>Bin3：28，28，28</p><p>已知一组价格数据:15,21,24,21,25,4,8,34,28现用等宽(宽度为10)分箱方法对其进行平滑，以对数据中的噪声进行处理。</p><p><strong>由于数据范围是从最小值4到最大值34，数据范围的总宽度是34 - 4 = 30。要分为3个等宽的区间，每个区间的宽度将是30 / 3 = 10。即要求箱中数据之差不能超过10</strong></p><ul><li>第一个区间：4 - 13（包括头尾）</li><li>第二个区间：15 - 24（包括头尾）</li><li>第三个区间：28 - 37（包括头尾）</li></ul><p>结果:<br>先排序:4，8，15，21，21，24，25，28，34</p><p>划分为等宽度箱子</p><p>Bin1：4，8</p><p>Bin2：15，21，21，24，25</p><p>Bin3：28，34</p><p>根据Bin均值进行平滑</p><p>Bin1：6，6</p><p>Bin2：21，21，21，21，21</p><p>Bin3：31，31</p><p>根据Bin边界进行平滑</p><p>Bin1：4，8</p><p>Bin2：15，25，25，25，25</p><p>Bin3：28，34</p><p>根据Bin中值进行平滑</p><p>Bin1：6，6</p><p>Bin2：21，21，21，21，21</p><p>Bin3：31，31</p><p><strong>ppt第二章p28</strong></p><p><strong>纯度</strong></p><p>可以通过以下公式计算：</p><script type="math/tex; mode=display">P = \frac{\text{多数类别的实例数}}{\text{总实例数}}</script><p>数据规范化：将数据按比例进行缩放，使之落入一个特定的区域，以消除数值型属性因大小不一而造成的挖掘结果的偏差</p><p>最小-最大规范化</p><p>零-均值规范化（z-score规范化）</p><p>小数定标规范化</p><p><strong>最小—最大规范化</strong>：假定minA和maxA分别为属性A的最小和最大值，则通过下面公式将A的值映射到区间[new_min, new_max]中的v’：</p><script type="math/tex; mode=display">v' = \frac{(v - \min_A) \times (\text{new\_max} - \text{new\_min})}{(\max_A - \min_A)} + \text{new\_min}</script><p>例：假定属性income的最小与最大值分别为$12000和$98000，可根据最小—最大规范化方法将其范围映射到[0,1]：<br>如：属性值$73600将变换为：</p><script type="math/tex; mode=display">v' = \frac{(73600 - 12000) \times (1 - 0)}{98000 - 12000} + \text{0}=0.716</script><p><strong>零-均值规范化（z-score规范化）</strong></p><script type="math/tex; mode=display">𝑣′=\frac{𝑣−𝑚𝑒𝑎𝑛𝐴}{standard_− 𝑑𝑒𝑣𝐴}</script><p>其中，meanA、standard-devA分别为属性A取值的均值和标准差</p><p>例：假定属性income的平均值与标准差分别为$54000和$16000，使用z-score规范化，则属性值$73600将变换为：</p><script type="math/tex; mode=display">𝑣′=\frac{73600−54000}{16000}=1.225</script><p><strong>小数定标规范化</strong></p><script type="math/tex; mode=display">𝑣′=\frac𝑣{10^𝑗 }</script><p>其中，j是使 Max(|  v’ |)&lt;1的最小整数</p><p><strong>例：</strong>假定A的取值范围[-986, 917]，则A的最大绝对值为986，为使用小数定标规范化，用1000（即j=3）除每个值，这样-986被规范化为-0.986。</p><p><img src="/zhouyuchen/.io//image-20240416112557044.png" alt="image-20240416112557044"></p><h2 id="信息增益ID3"><a href="#信息增益ID3" class="headerlink" title="信息增益ID3"></a>信息增益ID3</h2><p>选择具有最高信息增益的属性作为分裂属性</p><p>假设有两个类,P和N </p><p>让样本集S包含类P的p个元素以及类N的n个元素</p><p>识别S中一个样本是否属于P或N所需要的平均信息量为</p><script type="math/tex; mode=display">I(p, n) = -\frac{p}{p + n} \log_2\left(\frac{p}{p + n}\right) - \frac{n}{p + n} \log_2\left(\frac{n}{p + n}\right)</script><p>对于离散随机变量 ，其熵定义同下</p><p>当熵公式推广到多个类别时，其形式保持不变，只是需要对所有可能的类别进行求和。对于离散随机变量 X，如果它有 k 个不同的取值 x1,x2,…,xk，每个取值的概率分别为 p(x1),p(x2),…,p(xk)，那么熵 H(X) 的公式为</p><script type="math/tex; mode=display">E(X) = -\sum_{i=1}^{k} p(x_i) \log_2 p(x_i)</script><script type="math/tex; mode=display">信息增益：Gain(A)=I(p,n)-E(A)</script><p>例如总共有14个样本，最终结果9是，5否，带入上面公式</p><script type="math/tex; mode=display">I(9, 5) = -\frac{9}{14} \log_2\left(\frac{9}{14}\right) - \frac{5}{14} \log_2\left(\frac{5}{14}\right)=0.940</script><hr><p><strong>例题</strong></p><p>请按照ID3决策树分类算法，采用信息增益作为节点的选择指标，筛选出基于以下训练数据所生成的决策树的根节点，请详细写出计算步骤。</p><div class="table-container"><table><thead><tr><th style="text-align:center">不浮出水面是否可以生存</th><th style="text-align:center">是否有脚璞</th><th style="text-align:center">属于鱼类</th></tr></thead><tbody><tr><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr></tbody></table></div><ol><li>计算未分类前的熵,总共有5个样本，是2个,否3个</li></ol><script type="math/tex; mode=display">熵(总)=I(2,3) = -\frac{2}{5} \log_2\left(\frac{2}{5}\right) - \frac{3}{5} \log_2\left(\frac{3}{5}\right)=0.971</script><ol><li>分别计算按不浮出水面是否可以生存和是否有脚蹊进行分类后的信息嫡。</li></ol><p>先按不浮出水面是否可以生存进行分类：是中有2是1否；否中有0是2否</p><script type="math/tex; mode=display">熵(是否可以生存_是)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28</script><script type="math/tex; mode=display">熵(是否可以生存_否)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28</script><script type="math/tex; mode=display">E=熵(是否可以生存)=\frac{3}{5}*0.28+\frac{2}{5}*0=0.17</script><script type="math/tex; mode=display">信息增益=熵(总)-熵(是否可以生存)=0.971-0.17=0.801</script><ol><li>是否有脚蹊进行分类：是中2是2否；否中有0是1否</li></ol><script type="math/tex; mode=display">熵(是否可以生存_是)=I(2,2) = -\frac{2}{4} \log_2\left(\frac{2}{4}\right) - \frac{2}{4} \log_2\left(\frac{2}{4}\right)=1</script><script type="math/tex; mode=display">熵(是否可以生存_否)=I(0,1) = -\frac{0}{1} \log_2\left(\frac{0}{1}\right) - \frac{1}{1} \log_2\left(\frac{1}{1}\right)=0</script><script type="math/tex; mode=display">熵(是否可以生存)=\frac{4}{5}*1+\frac{1}{5}*0=0.8</script><script type="math/tex; mode=display">信息增益=熵(总)-熵(是否可以生存)=0.971-0.8=0.171</script><p><strong>信息增益更大，区分样本的能力更强</strong>，更具有代表性,故根节点为”不浮出水面是否可以生存”</p><p><strong>基尼指标Gini指标</strong></p><p>( G ) 是基尼指数，( p_i ) 是第 ( i ) 个类别的样本占比，( n ) 是类别的总数</p><p>类似于信息增益，Gini指标越小，则为最优特征，指数越大，样本不确定性就越大</p><script type="math/tex; mode=display">G = 1 - \sum_{i=1}^{n} p_i^2</script><p>在特征A条件下，集合D的基尼指数</p><script type="math/tex; mode=display">G(D|A) = \sum_{j=1}^{k} \frac{|D_j|}{|D|} G(D_j)</script><p><img src="/zhouyuchen/.io//image-20240416140851945.png" alt="image-20240416140851945"></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>避免过分拟合的两种方法</p><ul><li>先剪枝: 通过提前停止树的构造而对树剪枝<br>很难选取一个合适的阈值</li><li>后剪枝: 由完全生成的树剪去子树.通过删除节点的分枝并用树叶替换它而剪掉给定节点的子树.树叶用被替换的子树中最频繁的类标记</li></ul><p><strong>CART使用的代价复杂度剪枝算法</strong></p><p>使用Gini系数，求得权重</p><p>在特征A条件下，集合D的基尼指数</p><p><a href="https://blog.csdn.net/weixin_45116749/article/details/129261511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%86%B3%E7%AD%96%E6%A0%91cart%E8%AE%A1%E7%AE%97%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-129261511.142^v100^pc_search_result_base4&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45116749/article/details/129261511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%86%B3%E7%AD%96%E6%A0%91cart%E8%AE%A1%E7%AE%97%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-129261511.142^v100^pc_search_result_base4&amp;spm=1018.2226.3001.4187</a></p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>贝叶斯定理公式</p><p>朴素的概念：假设样本特征彼此独立，没有相关关系。而这在现实中不存在，但用这个方法来分类效果很好</p><p>P(B) </p><ul><li>表示在没有训练数据前假设A拥有的初始概率。P(A)被称为A的先验概率.</li></ul><p>P(B|A) </p><ul><li>P(A|B)表示假设B成立时A的概率</li><li>机器学习中我们关心的是P(B|A)，即给定A时B的成立的概率，称为B的后验概率</li></ul><script type="math/tex; mode=display">P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}</script><p>因此P(B|A)如下</p><script type="math/tex; mode=display">P(B|A) = \frac{P(A|B) \cdot P(B)}{P(A)}</script><p>​    P(B|A)随着P(B)和P(A|B)的增长而增长，随着P(A)的增长而减少，即如果A独立于B时被观察到的可能性越大，那么B对A的支持度越小.</p><p>贝叶斯全概率公式</p><script type="math/tex; mode=display">P(A) = \sum_{i=1}^{n} P(A|B_i) \cdot P(B_i)</script><p>例题</p><p> <img src="/zhouyuchen/.io//image-20240416194507458.png" alt="image-20240416194507458"></p><p>求出所有概率最后相乘，选择更大的</p><p><img src="/zhouyuchen/.io//image-20240416194539654.png" alt=" "></p><p><img src="/zhouyuchen/.io//image-20240416194554820.png" alt="image-20240416194554820"></p><p>例题</p><p>用公式展开，并使用全概率公式将分母展开</p><p>给出P(R)=0.4    P(W|R)=0.9    P(W|~R)=0.2    P(~R)=0.6</p><script type="math/tex; mode=display">\begin{aligned}P(R|W)&=\frac{P(W|R)P(R)}{P(W)} \\&=\frac{P(W|R)P(R)}{P(W|R)P(R)+P(W|\neg R)P(\neg R)}\\&=\frac{0.9\times0.4}{0.9\times0.4+0.2\times0.6}=0.75\end{aligned}</script><p>例题公式推导</p><script type="math/tex; mode=display">P(W|S) = \frac{P(W \cap S)}{P(S)}</script><script type="math/tex; mode=display">P(W \cap S) = P((W \cap S) \cap R) + P((W \cap S) \cap \sim R)</script><p>由于下面</p><script type="math/tex; mode=display">P(A \mid B) = \frac{P(A \cap B)}{P(B)}</script><p>因此得到</p><script type="math/tex; mode=display">P(W \cap S) = P(W \mid R,S) \cdot P(R \mid S) + P(W \mid \sim R,S) \cdot P(\sim R \mid S)</script><p>所以</p><script type="math/tex; mode=display">P(W \cap S) = P(W \mid R,S) \cdot P(R ) + P(W \mid \sim R,S) \cdot P(\sim R)</script><p><img src="/zhouyuchen/.io//image-20240416205205173.png" alt="image-20240416205205173"></p><h2 id="分类器验证方法"><a href="#分类器验证方法" class="headerlink" title="分类器验证方法"></a>分类器验证方法</h2><p>交叉验证</p><ul><li>CV是用来验证分类器的性能一种统计分析方法，将原始数据(dataset)进行分组,一部分做为训练集(train set)，另一部分做为验证集(validation set),首先用训练集对分类器进行训练,再利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标</li></ul><p>K-折交叉验证</p><ul><li>将原始数据分成K组(一般是均分)，将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标</li><li>K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性</li></ul><p>留一验证LOO-CV</p><ul><li><p>如果设原始数据有N个样本,那么LOO-CV就是N-CV,即 每个样本单独作为验证集,其余的N-1个样本作为训练集,所以LOO-CV会得到N个模型,用这N个模型最终的验证集的分类准确率的平均数作为此下LOO-CV分类器的性能指标</p></li><li><p>相比于前面的K-CV,LOO-CV有两个明显的优点: ①a.每一回合中几乎所有的样本皆用于训练模型,因此最接近原始样本的分布,这样评估所得的结果比较可靠。 ②b.实验过程中没有随机因素会影响实验数据,确保实验过程是可以被复制的</p></li><li><p>LOO-CV的缺点则是计算成本高,因为需要建立的模型数量与原始数据样本数量相同,当原始数据样本数量相当多时,LOO-CV在实作上几乎就是不现实的,除非每次训练分类器得到模型的速度很快,或是可以用并行化计算减少计算所需的时间. </p></li></ul><h2 id="分类器性能评价"><a href="#分类器性能评价" class="headerlink" title="分类器性能评价"></a>分类器性能评价</h2><p>主对角线：被正确分类的正例个数(TP个)和    被正确分类的负例个数(TN个)</p><p>副对角线：被错误分类的正例个数(FP个)和    被错误分类的负例个数(FN个)</p><div class="table-container"><table><thead><tr><th></th><th>预测正例</th><th>预测负例</th></tr></thead><tbody><tr><td>实际正例</td><td>TP (真正例)PP</td><td>FN (假反例)PN</td></tr><tr><td>实际负例</td><td>FP (假正例)NP</td><td>TN (真反例)NN</td></tr></tbody></table></div><ul><li><p>准确率：总样本预测对了个数</p><script type="math/tex; mode=display">\text{Accuracy} = \frac{\text{TP} + \text{TN}}{\text{TP} + \text{TN} + \text{FP} + \text{FN}}</script></li><li><p>查准率(Precision)：也叫<strong>精确率</strong>，预测为正的中实际为正的有多少。（正确分类的正例个数占分类为正例的实例个数的比例）</p></li></ul><script type="math/tex; mode=display">\text{Precision} = \frac{\text{TP}}{\text{TP} + \text{FP}}</script><ul><li>查全率(Recall)：也叫<strong>召回率</strong>，在所有实际为正例的样本中，正确分类的正例个数占实际正例个数的比例。</li></ul><script type="math/tex; mode=display">\text{Recall} = \frac{\text{TP}}{\text{TP} + \text{FN}}</script><ul><li>F1值：查全率与查询率的调和平均数</li></ul><script type="math/tex; mode=display">F1 = 2 \times \frac{P \times R}{P + R}</script><ul><li>误分率<script type="math/tex; mode=display">\text{误分率} = \frac{\text{FP} + \text{FN}}{\text{TP} + \text{TN} + \text{FP} + \text{FN}}</script></li></ul><p><strong>ROC</strong></p><p>ROC图形，根据混合矩阵，定义两个概念：</p><p>错误的正例率(False Positive Rate,FPR)=FP/N=错误预测为正/原本为负</p><p>正确的正例率(True Positive Rate.TPR)=TP/P=正确预测为正/原本为正</p><p>ROC图形是一个二维图形，横轴为<strong>FPR</strong>，纵轴为TPR，直观的展示FPR与TPR之间的对应关系</p><p>FPR</p><script type="math/tex; mode=display">\text{FPR} = \frac{\text{FP}}{\text{FP} + \text{TN}}</script><p>TPR</p><script type="math/tex; mode=display">\text{TPR} = \frac{\text{TP}}{\text{TP} + \text{FN}}</script><p><strong>AUC</strong></p><p>ROC曲线下的面积，是一个具体数值，数值越大，模型越好</p><ul><li>AUC =1，是完美的分类器，该模型至少存在一个值，可以将正负样本完美的划分开</li><li>0.5&lt;AUC&lt;1，优于随机猜测，数值越大，分类器越好</li><li>AUC=0.5，相当于随机猜测，模型没有预测价值</li><li>AUC&lt;0.5，比随机猜测要差，然而若反向预测，该模型也可优于随机猜测</li></ul><p><strong>预测概率和阈值</strong></p><p>模型预测概率大于阈值判定为正，反之为负</p><p>例题</p><p><img src="/zhouyuchen/.io//image-20240417151554970.png" alt="image-20240417151554970"></p><p>混淆矩阵画法</p><p><img src="/zhouyuchen/.io//image-20240417140040656.png" alt="image-20240417140040656"></p><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul><li>无监督的分类</li><li>不要训练集合</li><li>聚类算法会将数据集中的样本划分成为若干个通常不相交的子集，每一个子集我们称之为“簇”。</li><li>在聚类过程自动形成簇结构后,我们会发现每个簇里会存在一些潜在的概念，比如“黄种人”、“白种人”，“女性”、“男性”，这些是我们事先未知的，这些概念也是由使用者来把握和命名的。</li></ul><h2 id="k均值聚类算法"><a href="#k均值聚类算法" class="headerlink" title="k均值聚类算法"></a>k均值聚类算法</h2><p>k-means：k均值聚类算法,其中每个簇都用该簇中对象的均值来表示  </p><p>k-medoids：k中心点聚类算法，其中每个簇用接近簇中心的一个对象来表示</p><p>CLARANS：大型数据库中的划分聚类算法</p><p>步骤</p><ul><li><p>先定义总共有多少个类/簇(cluster)</p></li><li><p>将每个簇心(cluster centers)随机定在一个点上将每个数据点关联到最近簇中心所属的簇上</p></li><li>对于每一个簇找到其所有关联点的中心点(取每一个点坐标的平均值)</li><li>将上述点变为新的簇心</li><li>不停重复，直到每个簇所拥有的点不变</li></ul><p><img src="/zhouyuchen/.io//image-20240417162108117.png" alt="image-20240417162108117"></p><p><img src="/zhouyuchen/.io//image-20240417162122926.png" alt="image-20240417162122926"></p><p>例题</p><p><img src="/zhouyuchen/.io//image-20240417164313560.png" alt="image-20240417164313560"></p><p>k均值优点</p><ul><li>聚类时间快</li></ul><p>缺点</p><ul><li>用户必须事先指定聚类簇的个数</li><li>常常终止于局部最优</li><li>只适用于数值属性聚类(计算均值有意义)</li><li>对噪声和异常数据也很敏感</li><li>不同的初始值，结果可能不同</li><li>不适合发现非凸面形状的簇</li></ul><p>k-means利用簇内点的均值或加权平均值ci（质心）作为类Ci的代表点。对数值属性数据有较好的几何和统计意义。对孤立点是敏感的，如果具有极大值，就可能大幅度地扭曲数据的分布</p><p>k-medoids(k-中心点)算法是为消除这种敏感性提出的，它选择类中位置最接近类中心的对象(称为中心点)作为类的代表点，目标函数仍然可以采用平方误差准则</p><p>PAM（Partitioning Around Medoids，围绕中心点的划分）是最早提出的k中心点算法之一</p><p>当使用 k-medoids 算法进行聚类时，以下是完整的步骤：</p><div class="table-container"><table><thead><tr><th></th><th>k均值</th><th>k中心点</th></tr></thead><tbody><tr><td>初始化</td><td>从数据集中随机选择 k 个点作为初始的聚类中心</td><td>same</td></tr><tr><td>分配数据点到最近的聚类中心</td><td>计算它与每个聚类中心之间的距离（通常使用欧氏距离），将该点分配给距离最近的聚类中心所在的簇。</td><td>same</td></tr><tr><td>更新中心点</td><td>对于每个簇，计算该簇中所有数据点的均值，并将该均值作为新的聚类中心。</td><td>对于每个簇，选择一个新的中心点以最小化该簇中所有点到该中心点的总距离。具体步骤如下：对于当前簇中的每个点，将该点作为新的中心点，计算所有其他点到该新中心点的总距离。 选择使总距离最小的点作为该簇的新中心点</td></tr><tr><td>重复迭代直到收敛</td><td>重复步骤二和步骤三</td><td>same</td></tr><tr><td>收敛条件</td><td>k-均值算法会在聚类中心不再改变或达到最大迭代次数时收敛</td><td>same</td></tr></tbody></table></div><p><strong>PAM</strong></p><p>假如空间中的五个点｛A、Ｂ、Ｃ、Ｄ、Ｅ｝如图1所示，各点之间的距离关系如表1所示，根据所给的数据对其运行PAM算法实现划分聚类（设<em>k</em>=2）。 样本点间距离如下表所示</p><div class="table-container"><table><thead><tr><th>样本点</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>2</td><td>2</td><td>3</td></tr><tr><td>B</td><td>1</td><td>0</td><td>2</td><td>4</td><td>3</td></tr><tr><td>C</td><td>2</td><td>2</td><td>0</td><td>1</td><td>5</td></tr><tr><td>D</td><td>2</td><td>4</td><td>1</td><td>0</td><td>3</td></tr><tr><td>E</td><td>3</td><td>3</td><td>5</td><td>3</td><td>0</td></tr></tbody></table></div><p>第一步 建立阶段：假如从5个对象中随机抽取的2个中心点为{A，B},则样本被划分为{A、C、D}和{B、E}</p><p>第二步 交换阶段：假定中心点A、B分别被非中心点C、D、E替换，根据PAM算法需要计算下列代价TCAC、 TCAD、 TCAE、TCBC、TCBD、 TCBE。</p><p>以TCAC为例说明计算过程</p><p>a)当A被C替换以后，A不再是一个中心点，因为A离B比A离C近，A被分配到B中心点代表的簇，CAAC=<em>d</em>(<em>A</em>,<em>B</em>)-<em>d</em>(<em>A</em>,<em>A</em>)=1</p><p>b)B是一个中心点，当A被C替换以后，B不受影响，CBAC=0</p><p>a)C原先属于A中心点所在的簇，当A被C替换以后，C是新中心点，符合PAM算法代价函数的第二种情况<em>C**CAC</em>=<em>d</em>(<em>C</em>,<em>C</em>)-<em>d</em>(<em>C</em>,<em>A</em>)=0-2=-2</p><p>b)D原先属于A中心点所在的簇，当A被C替换以后，离D最近的中心点是C，根据PAM算法代价函数的第二种情况<em>C**DAC</em>=<em>d</em>(<em>D</em>,<em>C</em>)-<em>d</em>(<em>D</em>,<em>A</em>)=1-2=-1</p><p>c)E原先属于B中心点所在的簇，当A被C替换以后，离E最近的中心仍然是 B，根据PAM算法代价函数的第三种情况<em>C**EAC</em>=0</p><p>因此，<em>TC**AC</em>=<em>C**AAC</em>+ <em>C**BAC</em>+ <em>C**cAC</em>+ <em>C<strong>DAC</strong>+ C**EAC</em> <em>=1+0-2-1+0=-2。</em></p><p>重复迭代，找到T最小值</p><p>PAM算法的时间复杂度通常是O(k(n-k)^2)，其中n是数据集中的对象数，k是聚类的数量。由于迭代的次数可能很多，PAM算法的复杂性很高，所以不适合大型数据库</p><p><strong>CLARANS</strong></p><p>CLARANS方法在搜索的每一步都以某种随机方式进行采样，其聚类过程可描述成一个图的搜索，图中的每个节点是一个潜在的解，即k个中心点的集合<br>在替换一个中心对象后所获得的新第一就称为当前聚类的邻居，随机产生的聚类邻居数由用户限制<br>若发现一个更好的邻居(具有较低的方差)，CLARANS算法就移动到这一邻居节点然后再开始重新搜索,否则当前节点就形成了一个局部最优<br>若发现一个局部最优，CLARANS方法就随机选择节点重新开始搜索新的局部最优</p><p>优点<br>不用限制在局部区域搜索<br>只检查节点的邻居的样本，效率高</p><h2 id="层次方法"><a href="#层次方法" class="headerlink" title="层次方法"></a><strong>层次方法</strong></h2><p>层次方法hierachical methods创建给定数据对象集的层次分解。根据层次的分解的形成方式，层次的方法可以分类为<strong>凝聚的</strong>或<strong>分裂的</strong>方法</p><p><strong>凝聚法</strong>，也称<strong>自底向上</strong>的方法，开始将每个对象形成单独的组，然后逐次合并相近的对象或组，直到所有的组合并为一个（层次的最顶层），或者满足某个终止条件</p><p><strong>分裂法</strong>，也称<strong>自顶向下</strong>的方法，开始将所有的对象置于一个簇中，每次迭代，簇分裂为更小的簇，直到最终每个对象在一个簇中，或者满足某个终止条件</p><p>比较常用的算法<br>DIANA（Divisive ANAlysis） ：<br>   分裂层次聚类算法<br>AGENES（AGglomerative NESting）：<br>   凝聚层次聚类算法<br>BIRCH：<br>   利用层次方法的平衡迭代规约和</p><p><img src="/zhouyuchen/.io//image-20240418200310246.png" alt="image-20240418200310246"></p><p><strong>单链接</strong>（single-link）方法，其每个簇可以用簇中所有对象代表，簇间的相似度用属于不同簇中最近的数据点对之间的相似度来度量<br>也称为最短距离法，定义簇的邻近度为取自不同簇的所有点对的俩个最近的点之间的邻近度</p><p><strong>全链接</strong>取自不同簇中的俩个最远的点之间邻近度作为簇的邻近度，或者使用图的术语，不同的结点子集中俩个结点之间的最长边</p><p><strong>组平均</strong>（average linkage method）类间所有样本点的平均距离<br>该法利用了所有样本的信息，被认为是较好的系统聚类法</p><ul><li>当算法使用最小距离dmin（Ci，Cj）衡量簇间距离时，有时称它为最近邻聚类算法<br>如果当最近的簇之间的距离超过某个任意的阈值是聚类过程就会终止，则成其为单连接算法</li><li>使用最小距离度量的凝聚层次聚类算法也成为最小生成树算法</li><li>当算法使用最大距离dmax（Ci，Cj）衡量簇间距离时，有时称它为最远邻聚类算法（farthest-neighbor clustering algorithm）</li><li>如果当最近的簇之间的最大距离超过某个任意的阈值是聚类过程就会终止，则成其为全连接算法（complete-linkage algorithm）</li></ul><p><img src="/zhouyuchen/.io//image-20240418203651419.png" alt="image-20240418203651419"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>按相关的程度可分为完全相关、不完全相关和不相关。一般的相关现象是不完全相关。<br>按相关的方向可分为：正相关和负相关。<br>按相关的形式可分为：线性相关和非线性相关。<br>按变量多少可分为：单相关、复相关和偏相关。一个变量对另一变量的相关关系，称为单相关；一个变量对两个以上变量的相关关系时，称为复相关；在某一现象与多种现象相关的场合，当假定其他变量不变时，其中两个变量的相关关系称为偏相关。　</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>深度学习的基本思想：通过堆叠多层的网络结构和非线性变换，组合低层特征以实现对输入数据的分级表达。<br>强化学习并没有提供直接的监督信号来指导智能体（agent）的行为。</p><p>强化学习的关键要素:</p><ul><li>强化学习的关键要素有：<strong>环境、奖赏、动作和状态</strong>。有了这些要素，就可以建立一个强化学习模型；</li><li>强化学习解决的问题是：针对一个具体问题，得到一个最优策略，使得在该策略下获得的长期回报最大；</li><li>策略：在系列状态下，采取的动作或动作概率。</li></ul><p>状态（state）：</p><ul><li>就是指当前agent所处的状态。</li></ul><p>策略（policy）：就是指agent在特定状态下的动作依据，是从state到action的映射。</p><ul><li>确定策略：某一状态下的确定动作               ；</li><li>随机策略：以概率来描述，即某一状态下执行这一动作的概率                                         </li></ul><p>动作（action）：</p><ul><li>来自于动作空间，每个状态通过采取动作进行状态转移；</li><li>执行动作的目的是达到最大化期望奖赏，直到最终算法收敛，所得到的策略就是一系列action的序列数据。</li></ul><p>奖赏（reward）：</p><ul><li>奖赏通常被记作Rt，表示第t个时间步的返回奖励值。所有强化学习都是基于奖赏假设的。</li><li>奖赏通常为一个标量。</li><li>注意：回报（return）是奖赏（reward）的累积。</li></ul><p>行为策略（ b(s)  ）：</p><ul><li>用来指导个体产生与环境进行实际交互行为的策略；</li><li>实际采样的策略。</li></ul><p>目标策略（ Π(s)  ）：</p><ul><li>用来评价状态或行为价值的策略（或待优化的策略）。</li></ul><p>环境模型：理解环境或感知环境<br>更新方式：回合更新或单步更新<br>求解方式：基于价值或基于策略<br>策略使用：同策略或异策略</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划本质上是多阶段决策过程</p><p>特点</p><ul><li>根据过程的特征可以将过程按空间、时间等标志分为若干互相联系又互相区别的阶段</li><li>在每一个阶段都需要做出决策，从而使得整个过程达到最好的效果</li><li>在处理各阶段决策的选取上，不仅只依赖于当前面临的状态，而且还要注意对以后的发展，即从全局考虑解决局部的问题</li><li>当各个阶段的决策确定后，就组成了一个决策序列，因而就决定了整个过程的一条活动路线</li></ul><p><strong>多阶段决策问题</strong>是把一个问题看作是一个<strong>前后关联</strong>具有<strong>链状结构</strong>的<strong>多阶段过程</strong>，也称为<strong>序贯决策过程</strong>。</p><p>动态规划把一个问题的过程，恰当地分为若干个相互联系的<strong>阶段</strong>，以便于按一定的次序去求解。</p><p>描述阶段的变量称为<strong>阶段变量</strong>,常用k表示。阶段的划分，一般是根据<strong>时间和空间的自然特征</strong>来进行的，但要便于问题转化为多阶段决策</p><p><strong>状态</strong>表示<strong>每个阶段开始</strong>时所处的自然状况或客观条件。</p><p>能用动态规划方法求解的多阶段决策过程是一类特殊的多阶段决策过程，即状态具有<strong>无后效性的多阶段决策过程</strong></p><p><strong>它可以把一个n 维决策问题变换为n个一维最优化问题</strong></p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>1.什么是机器学习？<br> 机器学习：本质上就是让计算机自己在数据中学习规律，并根据所得到的规律对未来数据进行预测。</p><p>2.机器学习基本分类：监督学习、无监督学习。</p><ul><li><p>监督学习：监督学习是根据已有数据集，知道输入和输出结果之间的关系，然后根据这种已知关系训练得到一个最优模型。也就是说，在监督学习中，我们的训练数据应该既有特征又有标签，然后通过训练，使得机器能自己找到特征和标签之间的联系，然后在面对没有标签的数据时可以判断出标签。</p></li><li><p>无监督学习：我们需要用某种算法去训练无标签的训练集从而能让我们我们找到这组数据的潜在结构。无监督学习大致可以分为<strong>聚类</strong>和<strong>降维</strong>两大类。</p></li></ul><p>3.机器模型<br>机器学习模型分为<strong>参数化模型</strong>和<strong>非参数化</strong>模型。</p><ul><li>非参数化模型一般没有优化目标函数，利用某种算法和结构建立模型，比如K近邻、决策树等。</li><li>参数化模型中定义了或多或少的参数，通过参数计算模型的输出，通过定义某种优化目标函数，利用数据去调整(训练)参数，比如线性回归、支持向量机、贝叶斯网络、神经网络等。本书侧重于参数化模型。</li></ul><p>4.监督学习模型和无监督学习模型有哪些？</p><p>监督学习模型：<br>（1） 线性回归（Linear Regression）： 用于解决回归问题，建立输入特征与连续目标变量之间的线性关系。</p><p>（2）逻辑回归（Logistic Regression）： 用于解决分类问题，将输入映射到概率输出，并进行二分类或多分类。</p><p>（3）决策树（Decision Trees）： 通过树状结构进行决策，可用于分类和回归任务。</p><p>（4）支持向量机（Support Vector Machines，SVM）： 用于分类和回归，通过找到将不同类别分开的最优超平面。</p><p>（5）k近邻算法（k-Nearest Neighbors，KNN）： 根据输入实例的邻近实例来进行分类或回归。<br>无监督学习模型：</p><p>（1）K均值聚类（K-Means Clustering）： 用于将数据集划分为K个不同的组（簇）。</p><p>（2）层次聚类（Hierarchical Clustering）： 将数据集划分为具有层次结构的簇。</p><p>（3）主成分分析（Principal Component Analysis，PCA）： 用于降低数据维度，发现数据的主要成分。</p><p>（4）独立成分分析（Independent Component Analysis，ICA）： 寻找数据中的独立源，用于盲源分离。</p><p>（5）自编码器： 用于学习数据的紧凑表示，常用于降维和特征学习。</p><p>5.监督机器学习模型通常将有标注的数据集分割为<strong>训练集</strong>和<strong>测试集</strong>。训练集用于训练模型，获得模型的最佳参数，测试集用于度量模型训练后的性能。</p><p>6.损失函数：<br>  损失函数是这样一类函数: 当模型对样本的分类正确时，不产生损失或产生较小的损失，反之，根据其离谱程度，将带来一定甚至很大损失。通过选择合理的参数，使得整个数据产生的总体损失最小化。这个过程被称为训练(training)，也称有监督学习。</p><p>损失函数衡量的是模型预测能力的好坏。</p><p>1.机器学习：<br>是人工智能的一种分支，让计算机从数据中学习和改进，以完成某种任务，目标是让计算机在经验中学习，自动发现模式和规律，并运用规律进行预测和决策</p><p>2.过拟合及缓解方法：<br>指模型在训练数据集上表现良好，但在新数据或测试集上表现不好的现象。通常是由于模型过于复杂，使得模型在训练的过程中过分注重与特定细节，而没有真正掌握数据的底层结构和一般规律<br>缓解方法：增加训练数据量，提供更多的数据样本供模型学习，减少过拟合的风险；降低模型的复杂度，减少模型的自由度；或者通过正则化限制模型的学习能力</p><p>3.有监督和无监督学习：<br>有监督的学习是指模型在训练数据中，每个样本都有对应的标签和目标输出，模型通过学习输入与输出的映射关系进行预测和决策<br>无监督的学习是指模型在训练数据中，每个样本没有对应的标签和目标输出，模型通过学习数据的内在结构和相似性进行聚类、降维或异常检测等任务</p><p>4.查准率和查全率：<br>查准率又称精确率，是指在预测为正类的样本中真正类所占的比例，衡量分类模型在某一分类预测上的准确性。<br>查全率又称召回率，是指在实际为正类的样本中真正类所占的比例，衡量分类模型在某一分类预测上的完整性。</p><p>5.P-R曲线怎么对学习器进行比较<br>P-R曲线是以P查准率为横轴，R查全率为纵轴绘制的曲线。通过改变分类的阈值来得到不同的P-R点，比较不同学习器的性能，可以通过曲线下的面积AUC，越接近1越好，或者F1-score来判断</p><p>6.真正例率和假正例率<br>真正例率（TPR）是表示实际为正例的样本中被正确预测为正例的比例，TPR=TP/TP+FN<br>假正例率（FPR）是表示实际为负例的样本中 被错误预测为正例的比例，FPR=FP/FP+TN</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender</title>
    <link href="/zhouyuchen/2023/12/03/blender/"/>
    <url>/zhouyuchen/2023/12/03/blender/</url>
    
    <content type="html"><![CDATA[<h1 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h1><p>视图控制 按住 ~   +   数字</p><p>独立显示  /</p><p>位移     G          后面可以加上xyz</p><p>旋转     R          后面可以加上xyz </p><p>缩放     S          后面可以加上xyz</p><p>编辑视图 ctrl + tab</p><p>6 编辑点线面</p><p> alt Z 透视</p><p>CTRL B 倒角 用于创作圆角</p><p>右键平滑着色可以使用插值顶点法线，网格面的边缘会变得模糊，看起来很光滑</p><p>x 删除</p><p>alt  shift 循环切割线选中</p><p>shift D 复制</p><p>扳手工具添加修改器 添加镜像，选择吸管吸取镜像中心</p><p>物体-&gt;设置原点-&gt;几何中心  设置物体旋转轴心的方式</p>]]></content>
    
    
    <categories>
      
      <category>建模工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agisoft Metashape</title>
    <link href="/zhouyuchen/2023/09/18/Metashape/"/>
    <url>/zhouyuchen/2023/09/18/Metashape/</url>
    
    <content type="html"><![CDATA[<h1 id="Agisoft-Metashape等使用"><a href="#Agisoft-Metashape等使用" class="headerlink" title="Agisoft Metashape等使用"></a>Agisoft Metashape等使用</h1><h2 id="Metashape使用"><a href="#Metashape使用" class="headerlink" title="Metashape使用"></a>Metashape使用</h2><ol><li>新建项目，将图片资源拖入堆块（Chunk）中</li><li>选择工作流程（Workflow）中的对齐照片（Align Photos）可选精度，目的是为了将导入的素材形成链接点描点拼接</li><li>选择移动区域（Move Region)调整区域，排除多余的点</li><li>再次选择工作流程中创建点云（build dense cloud）再次生成深度图</li><li>形成深度图后，双击左侧工作区中点云查看</li><li>选择工作流程中的生成网格（Build Mesh）选择点云更加精细</li><li>选择工作区中的3D Model优化多余的点</li><li>选择工作流程中的生成纹理（Build Texture），可选纹理大小数量</li><li>选择文件导出模型，同时选中纹理导出</li></ol><h3 id="离散点删除"><a href="#离散点删除" class="headerlink" title="离散点删除"></a>离散点删除</h3><p>在对齐照片后通过使用自由选择或者矩形工具先将不需要的离散点删除</p><p>调整移动区域大小重新规定计算点</p><p>重置视图可以移动到中心位置</p><h2 id="Upscayl"><a href="#Upscayl" class="headerlink" title="Upscayl"></a>Upscayl</h2><ul><li><strong>REAL-ESRGAN：</strong>提高图片的清晰度；</li><li><strong>RemaCRI：</strong>增强图片效果；</li><li><strong>UltraMix Balanced：</strong>提高图片色彩饱和度；</li><li><strong>UltraSharp：</strong>提高图片清晰度和锐化边缘；</li><li><strong>Digital Art：</strong>提高颜色和纹理细节；</li><li><strong>Sharpen Image：</strong>只锐化处理；</li></ul><p>注意在系统中开启：</p><p><img src="/zhouyuchen/.io//image-20230925112737882.png" alt></p><p>测试记录：</p><ol><li>图片记录（5张图）<ol><li>96DPI放大4倍（9600x12800，3M，10分钟）</li><li>96DPI放大8倍（12000x16000，5M，15分钟）</li><li>300DPI（2400x3200，3M，15分钟）   300DPI放大后变为（1）</li></ol></li><li><p>建模记录</p><ol><li>5张图建模总时长在20分钟左右，DPI大，时间长</li><li>（3）点云数量多于（1，2）</li><li>（1）和（2）建模清晰度并无太大差异  （3）清晰度低</li></ol></li><li><p>总结</p><ol><li>每张图优化时长在3分钟左右，</li><li>15cm大小一面至少需要4面整体，4面细节，位置需以球面等距拍摄</li></ol></li></ol><h2 id="DOTween"><a href="#DOTween" class="headerlink" title="DOTween"></a>DOTween</h2><p><strong>解压缩</strong>到 Unity Assets 文件夹中</p><p>使用的每个类/脚本中<strong>导入 DOTween 的命名空间：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br></code></pre></td></tr></table></figure><p>初始化以设置一些全局选项，DOTween 将使用默认设置自动初始化：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">DOTween.Init(autoKillMode, useSafeMode, logBehaviour);<br></code></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><img src="/zhouyuchen/.io//splash_lambda.png" alt="img"></p><p><img src="/zhouyuchen/.io//splash_shortcuts.png" alt="img"></p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//目标点（1，1，1），时长秒</span><br>DoMove(Vector3.one, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//X,Y,Z移动</span><br>DOMoveX<br><span class="hljs-comment">//旋转</span><br>DORotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">140</span>,<span class="hljs-number">140</span>, <span class="hljs-number">140</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment">//放大</span><br>DOScale<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Metashape</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Metashape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D</title>
    <link href="/zhouyuchen/2023/09/18/Unity3D/"/>
    <url>/zhouyuchen/2023/09/18/Unity3D/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="LateUpdate和Update"><a href="#LateUpdate和Update" class="headerlink" title="LateUpdate和Update"></a>LateUpdate和Update</h2><p>两者都是每帧调用，执行顺序不同</p><p>无论有多少个update函数，都要等update函数执行完才能再执行lateupdate</p><p>Lateupdate一般放相机处理</p><p>update放画面控制逻辑</p><p>update在渲染每一帧的时候调用。但是fixupdate一般是在固定的时间频率调用。这个时间不一定是每一帧的时间。</p><h2 id="光影"><a href="#光影" class="headerlink" title="光影"></a>光影</h2><p>区域光（Area）烘焙后相当于生成一张贴图，可以删除光源</p><p>烘焙光对一般动态物体没有影响</p><h3 id="体积雾学习笔记"><a href="#体积雾学习笔记" class="headerlink" title="体积雾学习笔记"></a>体积雾学习笔记</h3><p>Volumetric Fog放在camera下</p>]]></content>
    
    
    <categories>
      
      <category>Unity3D</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#</title>
    <link href="/zhouyuchen/2023/06/01/C#/"/>
    <url>/zhouyuchen/2023/06/01/C#/</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习入门"><a href="#C-学习入门" class="headerlink" title="C#学习入门"></a>C#学习入门</h1><h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h3><p>C# 是在 .Net 框架开发期间开发的。</p><p>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><p>主要功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li><strong>委托（Delegates）和事件管理（Events Management）</strong></li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><p>注意以下几点：</p><ul><li>C# 是大小写敏感的。</li><li>所有的语句和表达式必须以分号（;）结尾。</li><li>程序的执行从 Main 方法开始。</li><li>与 Java 不同的是，文件名可以不同于类的名称。</li></ul><h3 id="与C不同的基本语法"><a href="#与C不同的基本语法" class="headerlink" title="与C不同的基本语法"></a>与C不同的基本语法</h3><h4 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h4><p>在任何 C# 程序中的第一条语句都是：</p><p>由于使用 <code>using</code> 指令，因此程序可以使用 <code>Console.WriteLine</code> 作为 <code>System.Console.WriteLine</code> 的简写。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<span class="hljs-comment">//一个程序可以包含多个using语句</span><br></code></pre></td></tr></table></figure><h4 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h4><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System -  CTS）中所有数据类型的终极基类。Object 是 System.Object  类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><h4 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h4><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h4 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h4><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">String str = <span class="hljs-string">&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-string">@&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;C:\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;C:\\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="hljs-string">    &lt;!--</span><br><span class="hljs-string">    --&gt;</span><br><span class="hljs-string">&lt;/script&gt;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C#类型转换"></a>C#类型转换</h3><p>C#类型转换与C很类似，隐式转换和显示转换（强转）</p><p><a href="https://www.runoob.com/csharp/csharp-type-conversion.html">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C#变量"></a>C#变量</h3><h4 id="接受来自用户的值"><a href="#接受来自用户的值" class="headerlink" title="接受来自用户的值"></a>接受来自用户的值</h4><p><strong>System</strong> 命名空间中的 <strong>Console</strong> 类提供了一个函数 <strong>ReadLine()</strong>，用于接收来自用户的输入，并把它存储到一个变量中。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> num;<br>num = Convert.ToInt32(Console.ReadLine());<br></code></pre></td></tr></table></figure><p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p><h3 id="C-常量运算符与C类似"><a href="#C-常量运算符与C类似" class="headerlink" title="C#常量运算符与C类似"></a>C#常量运算符与C类似</h3><p>需要注意的是</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>\</td><td></td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A \</td><td>B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car)  // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”);      StringReader r = obj as StringReader;</td></tr></tbody></table></div><h3 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h3><p>internal：同一个程序集的对象可以访问；</p><p>protected internal：访问限于当前程序集或派生自包含类的类型。也就是包括protected 和 internal</p><p><img src="/zhouyuchen/.io//image-20230712222252009.png" alt></p><h3 id="C-方法"><a href="#C-方法" class="headerlink" title="C#方法"></a>C#方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)<br>&#123;<br>   Method Body<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</p><p><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</p><p><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</p><p><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</p><p><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>&#123;<br>    <span class="hljs-comment">//方法主体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h4><p>通过方法名调用</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全</p><p>即使在函数内改变了值，值也没有发生任何的变化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>        &#123;...&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        ...<br>        <span class="hljs-built_in">int</span> ret;<br>        <span class="hljs-comment">//调用 FindMax 方法</span><br>        ret = n.FindMax(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>   &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>      &#123;<br>         ...<br>      &#125;  <br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.swap(a, b);<br>         ...<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h4><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>         ...<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h4><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.getValue(<span class="hljs-keyword">out</span> a)<br>         ...<br>      &#125;<br></code></pre></td></tr></table></figure><p>通过用户输入值再输出</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> y </span>)</span><br>      &#123;<br>          Console.WriteLine(<span class="hljs-string">&quot;请输入第一个值： &quot;</span>);<br>          x = Convert.ToInt32(Console.ReadLine());<br>          Console.WriteLine(<span class="hljs-string">&quot;请输入第二个值： &quot;</span>);<br>          y = Convert.ToInt32(Console.ReadLine());<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i; <span class="hljs-comment">//默认值0</span><br><span class="hljs-built_in">int</span>? ii; <span class="hljs-comment">//默认值nul</span><br></code></pre></td></tr></table></figure><h4 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h4><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br></code></pre></td></tr></table></figure><h4 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/* 初始化数组 n 中的元素 */</span>        <br><span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ )<br>&#123;<br>   n[i] = i + <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-comment">/* 输出每个数组元素的值 */</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> j <span class="hljs-keyword">in</span> n )<br>&#123;<br>   <span class="hljs-built_in">int</span> i = j<span class="hljs-number">-100</span>;<br>   Console.WriteLine(<span class="hljs-string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, i, j);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs result">Element[0] = 100<br>Element[1] = 101<br>Element[2] = 102<br>...<br></code></pre></td></tr></table></figure><h3 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h3><h4 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h4><p>String 类有以下两个属性：</p><div class="table-container"><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table></div><h4 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h4><div class="table-container"><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator,        string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table></div><p>完整方法参考MSDN库</p><p>C# 结构体、枚举、类与C相同不再赘述</p><p>类的继承以  子类 ：父类 方式继承</p><p>多重继承以  子类：父类，父类  方式继承</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><img src="/zhouyuchen/.io//image-20240311201304749.png" alt></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> counter;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    StartCoroutine(<span class="hljs-string">&quot;myCoroutine&quot;</span>);<br>    print(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (counter &lt; <span class="hljs-number">10</span>)<br>        print(<span class="hljs-string">&quot;帧数：&quot;</span> + counter++);<br><br>&#125;<br><span class="hljs-function">IEnumerator <span class="hljs-title">myCoroutine</span>()</span><br>&#123;<br>    print(<span class="hljs-string">&quot;步骤1&quot;</span>);<br>    <span class="hljs-comment">// 挂起，控制权返回原来的语句,直到下一帧,逐帧动态</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <br>    print(<span class="hljs-string">&quot;步骤2&quot;</span>);<br>    print(<span class="hljs-string">&quot;步骤3&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/zhouyuchen/.io//image-20240311210341910.png" alt></p><p><img src="/zhouyuchen/.io//image-20240311211543512.png" alt></p><h2 id="c-快捷键"><a href="#c-快捷键" class="headerlink" title="c#快捷键"></a>c#快捷键</h2><ul><li>快速对齐：ctrl+Ｋ + D<br>快速弹出智能提示：ctrl + J<br>快速<strong>注释</strong>：ctrl +K+C<br>取消所选的注释：ctrl + K+ U<br>折叠冗余代码：#region 和 #endregion<br><strong>输入svm然后按Tab键会生成Main函数；</strong><br>ctrl+K+S 三个键一起按，会调出代码段；选中多行后，然后按以上三个快捷键，按下Tab，代码段会自动包括选中代码，就可以进行相关的操作。比如加上region等。<br> 单行选中： Shift+Home：选中当前坐标到行首的代码；Shift+End选中当前坐标到行尾的代码；<br>折叠代码：ctrl+M + O，用来查看代码结构是否规整。<br>展开折叠代码： ctrl + M + L<br>展开或折叠光标所在的的代码块：ctrl + M+ M<br>转到定义：F12<br>F7 从设计界面切转到后台代码。Shift+F7 从后台代码切换到设计界面。<br>自动给字段加属性，封装属性的快捷键：Ctrl+R+E。<br>删除整行：ctrl + L<br>F9 添加、消除断点；Shift+Ctrl+F9取消所有断点。</li><li><strong>复制当前行 ctrl D</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU</title>
    <link href="/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/"/>
    <url>/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>GPU（Graphics Processing Unit）图形处理器与CPU（Central Processing Unit）相比具有：</p><ol><li>高并行结构，因此在处理图形数据和复杂算法效率更高</li><li>更多的ALU（Arithmetic Logical Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，适合对密集型数据并行处理</li><li>CPU执行计算时是时间片轮转算法，GPU具有多个处理器核，在一个时刻可以并行处理多个数据 </li><li>流式并行计算模式，对每个数据进行独立计算，任意元素不依赖其他同类元素</li></ol>]]></content>
    
    
    <categories>
      
      <category>GPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希算法</title>
    <link href="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>哈希算法</strong>（Hash 算法，散列算法，消息摘要算法）将任意长度的二进制值映射为较短的固定长度的二进制值 ，这个小的二进制值称为哈希值。</p><p>简单来说就是通过哈希值快速定位到想要查找的记录，而不是通过表中存放的关键字来比较查找。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>哈希表是根据设定的哈希函数和处理冲突方法将<strong>一组关键字</strong>映射到<strong>一个有限的地址区间</strong>上，作为记录在表中的<strong>存储位置</strong>，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</li><li>通过将哈希算法应用到<strong>任意数量</strong>的数据会得到的<strong>固定大小</strong>的结果。如果输入数据中有变化，则哈希也会发生变化。哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”。</li><li>它是一种<strong>单向密码体制</strong>,即它是一个从明文到密文的不可逆的映射。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。</li><li>是一种基于Hash函数的文件构造方法，可对记录快速随机存取。把任意长关键字映射为一个固定长度的哈希值，一 般用于鉴权、认证、加密、索引等。其主要优点是<strong>运算简单</strong>，<strong>预处理时间较短</strong>，<strong>内存消耗低</strong>，匹配查找<strong>速度快</strong>，便于维护和刷新，支持匹配规则数多等。</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>如果对一个字符串数组进行查询。最快的检索办法是通过数组的下标进行检索，但是对于这种场景，只能从头查到尾，从而查询出目标元素。因此最坏情况下时间复杂度为O(n)，但是使用Hash可以将时间复杂度降为O(1)。</p><p>Hash表采用一个映射函数 function: key -&gt; address 将关键字映射到该记录在表中的存储位置，在想要查找该记录时，可以直接根据关键字和<strong>映射关系</strong>计算出该记录在表中的存储位置，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置（存储位置只是表中的存储位置，并不是实际的物理地址）称作为<strong>Hash地址</strong>。</p><p>比如上述例子中，假如字符串数组采用Hash表存储，则当想要找到字符串对应的信息时，直接根据字符串和Hash函数计算出 Hash 地址即可。所谓的 Hash 算法就是将字符串转换为数字的算法。例如我们可以将字符串数组的各个字符的ASCII码计算出，作为Hash表的地址，当需要哪个字符串时候就根据数字之间查找出，当然这是最笨的Hash算法。</p><h2 id="Hash函数设计"><a href="#Hash函数设计" class="headerlink" title="Hash函数设计"></a>Hash函数设计</h2><ol><li>直接定址法</li></ol><p>取关键字或者关键字的某个线性函数为 Hash 地址，即address(key) = a * key + b; 如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000(其中a = 1)作为Hash地址。</p><ol><li>平方取中法</li></ol><p>对关键字进行平方计算，取结果的中间几位作为 Hash 地址。如有以下关键字序列 {421，423，436} ，平方之后的结果为 {177241，178929，190096} ，那么可以取中间的两位数 {72，89，00} 作为 Hash 地址。</p><ol><li>折叠法</li></ol><p>将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。如图书的 ISBN 号为 8903-241-23，可以将address(key)=89+03+24+12+3 作为 Hash 地址。</p><ol><li>除留取余法</li></ol><p>如果知道 Hash 表的最大长度为 m，可以取不大于m的最大质数 p，然后对关键字进行取余运算，address(key)=key % p。这里 p 的选取非常关键，p 选择的好的话，能够最大程度地减少冲突，p 一般取不大于m的最大质数。</p><ol><li>基数转换法</li></ol><p>将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中若干为作为X的哈希值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。</p><ol><li>随机数法</li></ol><p>设定哈希函数为:H(key)=Random(key)其中，Random为伪随机函数</p><p>此法适于：对长度不等的关键字构造哈希函数。</p><ol><li>字符串数值哈希法</li></ol><p>把字符串的前10个字符的ASCⅡ值之和对N取摸作为Hash地址，只要N较小，Hash地址将较均匀分布[0，N]区间内。对于N很大的情形，可使用ELFHash(ExecutableandLinkingFormat,ELF,可执行链接格式)函数，它把一个字符串的绝对长度作为输入，并通过一种方式把字符的十进制值结合起来，对长字符串和短字符串都有效，这种方式产生的位置可能不均匀分布。</p><ol><li>旋转法</li></ol><p>旋转法是将数据的键值中进行旋转。旋转法通常并不直接使用在哈希函数上，而是搭配其他哈希函数使用。</p><h2 id="Hash-冲突及解决方案"><a href="#Hash-冲突及解决方案" class="headerlink" title="Hash 冲突及解决方案"></a>Hash 冲突及解决方案</h2><p>因为我们是用字符串数组对哈希值进行定值，有可能不同键值所得到的索引值相同，这里就是冲突。如不同的字符串可能ASCII总和是相同的，显然出现的这种情况是不合理的，解决该冲突的方法就是改变数据结构。我们将数组内的元素改变为一个链表，这样就能容下足够多的元素了，冲突问题也能得到解决。具体如何解决请看下面的链地址法。</p><ol><li>开放定址法</li></ol><p>发生冲突时，使用某种探测技术在 Hash 表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash 表长为14，Hash 函数为 address(key) = key % 11，当插入12，13，25时可以直接插入，而当插入 23 时，地址 1 被占用了（因为 12%11 和 23%11 的结果相同）。此时沿着地址 1 依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将 23 插入其中。</p><ol><li>链地址法</li></ol><p>采用数组和链表相结合的数据结构，将 Hash 地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如下图最左边是数组结构，数组内的元素为链表结构。</p><p><img src="/zhouyuchen/.io//image-20230330224717657.png" alt></p><h2 id="Hash-表的用处以及优劣"><a href="#Hash-表的用处以及优劣" class="headerlink" title="Hash 表的用处以及优劣"></a>Hash 表的用处以及优劣</h2><ol><li>找出两文件找出重复的元素</li></ol><p>假设有两个文件，文件中均包含一些短字符串，字符串个数分别为n。它们是有重复的字符串，现在需要找出所有重复的字符串。</p><p>最笨的解决办法可能是：遍历文件 1 中的每个元素，取出每一个元素分别去文件 2 中进行查找，这样的时间复杂度为O（n^2）。</p><p>但是借助 Hash 表可以有一种相对巧妙的方法，分别遍历文件 1 中的元素和文件 2 中的元素，然后放入 Hash Table 中，对于遍历的每一个元素我们只要简单的做一下计数处理即可。最后遍历整个 Hash 列表，找出所有个数大于 1 的元素即为重复的元素。</p><ol><li>找出两文件找出出现次数最多的元素</li></ol><p>同找出两文件找出重复的元素这样的问题解决方案类似，只是在最后遍历的时找计数最大的元素，即为出现次数最多的元素。</p><ol><li>路由算法</li></ol><p>多线程处理数据的场景下，通常需要将一个数据集分给不同的线程进行处理，同时要保证，相同的元素需要分到相同的处理线程上。这其实这个就是一个很典型的 Hash 值应用场景，对于很多的计算引擎默认都是用 Hash 算法去解决这个问题。因为相同元素的 Hash 值相同，那么我们可以取 Hash 之后进行模运算，运算结果分配到不同的线程。</p><p>优点</p><p>哈希表的效率非常高，查找、插入、删除操作只需要接近常量的时间即0(1）的时间级。如果需要在一秒种内查找上千条记录通常使用哈希表，哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。如果不需要遍历数据，不二的选择。</p><p>缺点</p><p>它是基于数组的，数组创建后难于扩展。有些情况下，哈希表被基本填满时，性能下降得非常严重，所以开发者必须要清楚表中将要存储的数据量。或者也可以定期地把数据转移到更大的哈希表中，不过这个过程耗时相对比较大。</p><p>注意点</p><p>在设计Hash算法的时候。一定要保证相同字符串产生的 Hash 值相同，同时要尽量的减小Hash冲突的发生，这样才算是好的 hash 算法。</p><h2 id="哈希加盐"><a href="#哈希加盐" class="headerlink" title="哈希加盐"></a>哈希加盐</h2><p>我们知道，系统保存用户的密码时，一般不会直接保存下密码，而是通过md5加密后保存；</p><p>md5加密原理：Orz</p><p>md5已经是一种十分安全的加密方法了，但是通过彩虹表依旧可以破解（彩虹表原理），那么我们伟大机智的程序员们就想出了在密码后加一段序列然后再md5加密的方法，这个后面加上的序列就是所谓的 “ 盐 ” 。</p><p>具体的流程是：</p><p>用户注册时：</p><ol><li><p>用户在网站注册时提供ID与口令</p></li><li><p>系统随机为用户分配盐值</p></li><li><p>盐值插入口令后进行hash</p></li><li><p>将ID，hash值与盐值存入数据库</p></li></ol><p>身份验证时：</p><ol><li><p>用户提供ID与口令</p></li><li><p>系统在数据库中通过用户提供的ID查找HASH值与盐值</p></li><li><p>将盐值插入用户提供的口令后进行HASH</p></li><li><p>将HASH值与数据库中的HASH值比较，相等则验证成功，反之验证失败</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache</title>
    <link href="/zhouyuchen/2023/02/08/Cache/"/>
    <url>/zhouyuchen/2023/02/08/Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>CPU的运行速度是远远高于读写内存速度的，以当前嵌入式普遍使用的mcu来说，主频也普遍在几百Mhz，但是要知道使用的主存储器使用的动态存储器（DRAM）其存储速度在10Mhz左右。这样，如果指令和数据都存储在主存储器中，内存的速度会严重制约整个系统的性能。因此，为了解决内存速度低下，Cache就被引入了。可以说 Cache 是连接 CPU 和内存的桥梁。 </p><p>Cache全部是由硬件实现的，其不仅对于应用程序员是透明的，对系统程序员也是透明的，其是由速度与cpu速度相近的SRAM构成（Cahce和内存都是用的SRAM，那么速度为什么不同这是因为离CPU距离不同越近总线读写速度越快）。现在的处理器一般是通过多级缓存的组织形式来达到性能和功能的最优。但是其实对于多级cache还是一级cache，其原理是一致的，了解其原理后，多级和一级没有什么功能上的差异。</p><h2 id="Cache功能"><a href="#Cache功能" class="headerlink" title="Cache功能"></a>Cache功能</h2><p>cache是一种<strong>高速缓冲存储器</strong>，是为了解决CPU和主存之间速度不匹配而采用的一项重要技术</p><h2 id="Cache原理"><a href="#Cache原理" class="headerlink" title="Cache原理"></a>Cache原理</h2><p>cache原理是基于程序运行中具有的<strong>空间</strong>局限性和<strong>时间</strong>局限性特征。</p><p>空间局限性：在最近的未来要用到的信息(指令和数据)，很有可能与现在正在使用的信息在存储空间上是邻近的，如：数组元素、顺序执行的指令代码</p><p>时间局限性：在最近的未来要用到的信息，很可能是现在正在使用的信息，  如：循环结构的指令代码</p><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放在Cache中</p>]]></content>
    
    
    <categories>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/zhouyuchen/2023/02/02/Redis/"/>
    <url>/zhouyuchen/2023/02/02/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是C语言开发的一个开源高性能键值对的<strong>内存数据库</strong>，可以用来做数据库、缓存、消息中间件等场景，是一种NoSQL(not-only sql,非关系型数据库)的数据库。</p><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>优秀的性能，数据是存储在内存中，读写速度非常快，可支持并发10W QPS(一般指每秒查询率)</li><li>单线程但进程，是线程安全的，采用IO 多路复用制</li><li>可作为分布式锁</li><li>支持五种数据类型</li><li>支持数据持久化到磁盘</li><li>可以作为消息中间件使用，支持消息发布及订阅</li></ul><h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。       </li></ul><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>每个 hash 可以存储 23^2 -1 键值对（40多亿）。</p><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表最多可存储  23^2 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis  zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td style="text-align:center">String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—-</td></tr><tr><td style="text-align:center">Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td style="text-align:center">List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td style="text-align:center">Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td style="text-align:center">Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table></div><p>Redis中文文档链接: <a href="http://www.redis.cn/documentation.html">http://www.redis.cn/documentation.html</a></p><p>Redis英文文档 <a href="https://redis.io/topics/data-types">https://redis.io/topics/data-types</a></p><p>Redis官网:<a href="http://redis.io/">http://redis.io/</a></p><p>Redis官方文档:<a href="http://redis.io/documentation">http://redis.io/documentation</a></p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是冒泡排序的改进，之所以快速是由于运用了<strong>分治法</strong></p><p>主要思路：</p><ol><li>选择一个数为基准点</li><li>从左往右，将数与基准点相比较，同时从右往左将数与基准点相比较</li><li>当左边的数比基准点大时，同时右边的数比基准点小时，把两数交换</li><li>此时左边的数都小于基准点，右边的数都大于基准点。此时以基准点拆分成2队，重复执行步骤2，3，4</li></ol><p>如下是<strong>一次快排</strong>图解，选用了中点（pivot）作为基准点</p><p>xxxxxxxxxx class Solution {    public int lengthOfLongestSubstring(String s) {        if (s.length()==0) return 0;        HashMap<Character, integer> map = new HashMap<Character, integer>();        int max = 0;//最长子串长度        int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标        for(int i = 0; i &lt; s.length(); i ++){            if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。                left = Math.max(left,map.get(s.charAt(i)) + 1);       //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移            }        //map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位            map.put(s.charAt(i),i);      //再更新map中a映射的下标            max = Math.max(max,i-left+1);     //比较两个参数的大小        }        return max;            }}java </Character,></Character,></p><p>下面用个简单的实例说明：</p><p><img src="/zhouyuchen/.io//image-20230317124246696.png" alt></p><p>这是以20作为了基准点，进行一次快排的过程</p><p>之后以20为基准点分为左右两队再进行快排便可以得到结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = left, j = right;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-comment">// 基准点</span><br>    <span class="hljs-type">int</span> pivot;<br><br>    pivot = arr[(i + j) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt;= j)<br>    &#123;<br>        <span class="hljs-comment">// 从左到右边找到大于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[i] &lt; pivot)<br>        &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 从右到左边找到小于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[j] &gt; pivot)<br>        &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 如果i&lt;=j则互换元素</span><br>        <span class="hljs-keyword">if</span> (i &lt;= j)<br>        &#123;<br>            temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &lt; j)<br>    &#123;<br>        quick_sort(arr, left, j);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; right)<br>    &#123;<br>        quick_sort(arr, i, right);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">21</span>, <span class="hljs-number">2</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-type">int</span> i, len;<br>    len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    quick_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔</title>
    <link href="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>经典递归问题：汉诺塔</p><p>汉诺塔的本质（x，y，z三根柱）：</p><ol><li>将n-1层从x移动到y</li><li>将第n层从x移动到z</li><li>将n-1层从y移动到z    </li></ol><p>三步解决</p><p>因此用递归的方法，只需考虑2层时候的代码（把第一层看作是n-1层，第二层看作是n层）</p><p><img src="/zhouyuchen/.io//(1" alt>.png)</p><p><img src="/zhouyuchen/.io//(2" alt>.png)</p><p><img src="/zhouyuchen/.io//(3" alt>.png)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span><br>&#123;<br>    <span class="hljs-comment">//判断n的层数，如果为一层直接移动x到z</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c ---&gt;  %c\n&quot;</span>, x, z);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//当n！=1时候，将再次调用函数，移动n-1层：x到y，也就是把y和z互换</span><br>        hanoi(n - <span class="hljs-number">1</span>, x, z, y);<br>        <span class="hljs-comment">//移动第n层：x到z</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c ---&gt;  %c\n&quot;</span>, x, z);<br>        <span class="hljs-comment">//最后移动n-层：y到z</span><br>        hanoi(n - <span class="hljs-number">1</span>, y, x, z);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入汉诺塔的层数：\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    hanoi(n, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汉诺塔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git问题记录</title>
    <link href="/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git问题记录"><a href="#Git问题记录" class="headerlink" title="Git问题记录"></a>Git问题记录</h1><p>本文章记录使用Git遇到的问题，方便以后的查阅解决</p><h2 id="撤消尚未推送的Git合并"><a href="#撤消尚未推送的Git合并" class="headerlink" title="撤消尚未推送的Git合并"></a>撤消尚未推送的Git合并</h2><p>通过git-reset - 重置当前HEAD到指定的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard <br>git reset --hard ORIG_HEAD<br>git reset --merge ORIG_HEAD<br></code></pre></td></tr></table></figure><ol><li>没有进行合并提交，所以<code>git reset --hard</code>是<code>git reset --hard HEAD</code>的同义词，它清除了索引文件和工作树上的混乱。</li><li>“pull “或 “merge “总是在<code>ORIG_HEAD</code>中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。</li><li>在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。 运行<code>git reset --hard ORIG_HEAD</code>可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。 <code>git reset --merge</code>会保留你的本地修改。</li></ol><h2 id="恢复已经删除的提交"><a href="#恢复已经删除的提交" class="headerlink" title="恢复已经删除的提交"></a>恢复已经删除的提交</h2><p>当需要恢复已经删除的提交记录时候</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br>git rest --hard commitID<br>git push origin HEAD --force<br></code></pre></td></tr></table></figure><ol><li>通过reflog找到删除的提交的ID</li><li>执行上述命令，加上提交的ID即可恢复</li><li>本地退回后强制推送到远程仓库</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/zhouyuchen/2023/01/02/React/"/>
    <url>/zhouyuchen/2023/01/02/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>这篇博客是记录我react入门学习笔记，供我自己参考。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>React：用于构建用户界面的JavaScript库（将数据渲染为HTML视图的JS库）</p><h3 id="为什么要学"><a href="#为什么要学" class="headerlink" title="为什么要学"></a>为什么要学</h3><ol><li>原生JS操作DOM繁琐，效率低。</li><li>原生JS操作DOM会使浏览器大量重绘重排。</li><li>原生JS没有组件化的编码方案，代码复用率低。</li></ol><p>React特点：</p><ol><li>采用组件化模式，<strong>声明式编码</strong>，提高开发效率和组件复用率。</li><li>React Native 中可以使用React语法进行<strong>移动端开发</strong></li><li>使用<strong>虚拟DOM</strong>和优秀的<strong>Diffing算法</strong>，尽量减少与真实DOM的交互 </li></ol><h2 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h2><p>核心库必须先引入</p><p>babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p><p>react下载官网：<a href="http://react-cn.github.io/react/downloads.html">http://react-cn.github.io/react/downloads.html</a></p><p><strong>官方提供的：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引入react核心库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入babel，用于jsx转为js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Staticfile CDN 的 React CDN 库：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用JSX（JS+XML）创建虚拟DOM</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">&quot;test&quot;</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//创建虚拟DOM,不要写引号</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello,react<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//渲染虚拟DOM到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>用JS创建虚拟DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-comment">//创建虚拟DOM,不要写引号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;, <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello React&#x27;</span>))<br><span class="hljs-comment">//渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>可以看出JSX使用就如同写HTML一样方便，但是如果要嵌套多个标签，JS会大量增加重复的代码</p><p>关于虚拟DOM：</p><ol><li>本质是Object对象</li><li>虚拟DOM属性少，真实DOM属性多，因为虚拟DOM是React内部使用，无需那些多余的属性</li><li>虚拟DOM最终会被React转换为真实DOM，呈现在页面上</li></ol><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ol><li><p>定义虚拟DOM时，不要写引号。</p></li><li><p>标签混入JS表达式时用{}。</p></li><li><p>样式类名指定不要用class，用className</p></li><li><p>内联样式，要用style=的形式去写</p></li><li><p>虚拟DOM必须只有一个根标签</p></li><li><p>标签必须闭合</p></li><li><p>标签首字符</p><p>1）若<strong>小写字母</strong>开头，则将标签转为html中<strong>同名元素</strong>，若html中无，则报错</p><p>2）若<strong>大写字母</strong>开头，react渲染<strong>对应的组件</strong>，若组件未定义，则报错</p></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>JSX使用JavaScript表达式，表达式写在花括号 <strong>{}</strong> 中</p><p>在 JSX 中不能使用 <strong>if else</strong> 语句，但可以使用 <strong>conditional (三元运算)</strong> 表达式来替代。以下实例中如果变量 <strong>i</strong> 等于 <strong>1</strong> 浏览器将输出 <strong>true</strong>, 如果修改 i 的值，则会输出 <strong>false</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;i == 1 ? &#x27;True!&#x27; : &#x27;False&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type=&quot;text/babel&quot;&gt;<br>    console.log(this)//此处this是undefined 因为babel编译后开启了严格模式<br>    function MyComponent() &#123;<br>        return &lt;h1&gt;函数定义的组件&lt;/h1&gt;<br>    &#125;<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>执行ReactDOM.render(<MyComponent>…)</MyComponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由函数定义的，随后调用函数，将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type=&quot;text/babel&quot;&gt;<br>    class MyComponent extends React.Component &#123;<br>        render() &#123;<br>            console.log(this)//MyComponent实例<br>            return &lt;h1&gt;我是类定义的组件&lt;/h1&gt;<br>        &#125;<br>    &#125;<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>执行ReactDOM.render(<MyComponent>…)</MyComponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由类定义的，随后new该类的实例，并通过该实例调用到原型上的render方法</li><li>将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state是组件对象的重要属性，值是对象（可以包含多个key-value的组合）</p><p>React的组件被看为”状态机“，通过更新组件的state来更新对象对应的页面显示（重新渲染组件，不需要操作DOM）</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><sup><a href="#fn_自定义function中默认开启了严格模式，所以function中的this为undefined" id="reffn_自定义function中默认开启了严格模式，所以function中的this为undefined">自定义function中默认开启了严格模式，所以function中的this为undefined</a></sup>:</p><ol><li>组件中的render方法中的this为实例对象</li><li><p>组件自定义的方法中的this为undefined解决方式：</p><ol><li>强制绑定this：通过函数对象的bind(this)</li><li>箭头函数</li></ol></li><li><p>状态数据，不能直接修改或者更新</p></li></ol><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>state 和 props 主要的区别在于 <strong>props</strong> 是不可变的，而 state 可以根据与用户交互来改变。 state 来更新和修改数据，子组件只能通过 props 来传递数据。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C算法记录</title>
    <link href="/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="C算法记录"><a href="#C算法记录" class="headerlink" title="C算法记录"></a>C算法记录</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-comment">//定义一个静态的全局变量，用于存放数组下标，大小为2</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//int *res=(int*)malloc(sizeof(int)*2);</span><br>    <span class="hljs-comment">//返回值大小</span><br>    *returnSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//暴力遍历所有方法，默认为有解，i只需遍历到数组倒数第二个值，j跟随i的变化而变化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)&#123;<br>            <span class="hljs-comment">//将每一种可能与target比较</span><br>            <span class="hljs-keyword">if</span>(*(nums+i)+*(nums+j)==target)&#123;<br>                <span class="hljs-comment">//存入res数组中并且返回</span><br>                res[<span class="hljs-number">0</span>]=i;<br>                res[<span class="hljs-number">1</span>]=j;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误记录：</strong></p><p>​    使用int res[2]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line <span class="hljs-number">207</span>: Char <span class="hljs-number">3</span>: runtime error: load of null pointer of type <span class="hljs-string">&#x27;int&#x27;</span> [__Serializer__.c]<br></code></pre></td></tr></table></figure><p>​    空指针异常</p><p>​    力扣提示Note: The returned array must be malloced, assume caller calls free().</p><p>​    因为函数返回的是指针地址指向函数内的局部变量数组，在函数退出时，数组的存储空间会被销毁，此时去访问该地址就会出现这个错误。</p><p><strong>解决办法：</strong></p><p>​    使用malloc函数，当malloc函数被调用时，它会沿空闲链表寻找一个可以满足需求的内存块，然后把所需大小的内存块分配给用户，剩下的返回到链表上。free函数被调用时，它将释放的内存块连接到空闲链表上。</p><p>​    malloc函数声明：void *malloc (int size)；向系统申请分配size字节的内存空间。</p><p>​    因为malloc返回是void类型指针，因此使用时候要强制转换为int：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *res=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*sizeNums);<br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExcelReader</title>
    <link href="/zhouyuchen/2022/12/08/ExcelReader/"/>
    <url>/zhouyuchen/2022/12/08/ExcelReader/</url>
    
    <content type="html"><![CDATA[<h1 id="ExcelReader"><a href="#ExcelReader" class="headerlink" title="ExcelReader"></a>ExcelReader</h1><h2 id="用户导入"><a href="#用户导入" class="headerlink" title="用户导入"></a>用户导入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/import&quot;)</span><br>        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">imp</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br>                <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> ExcelUtil.getReader(inputStream);<br>                <span class="hljs-comment">// 方式1：(推荐) 通过 javabean的方式读取Excel内的对象，但是要求表头必须是英文，跟javabean的属性要对应起来</span><br><span class="hljs-comment">//        List&lt;User&gt; list = reader.readAll(User.class);</span><br><br>                <span class="hljs-comment">// 方式2：忽略表头的中文，直接读取表的内容</span><br>                List&lt;List&lt;Object&gt;&gt; list = reader.read(<span class="hljs-number">1</span>);<br>                List&lt;User&gt; users = CollUtil.newArrayList();<br>                <span class="hljs-keyword">for</span> (List&lt;Object&gt; row : list) &#123;<br>                        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                        user.setUsername(row.get(<span class="hljs-number">0</span>).toString());<br>                        user.setPassword(row.get(<span class="hljs-number">1</span>).toString());<br>                        users.add(user);<br>                &#125;<br>                userService.saveBatch(users);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="用户导出"><a href="#用户导出" class="headerlink" title="用户导出"></a>用户导出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/export&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从数据库查询出所有的数据</span><br>        List&lt;User&gt; list = userService.list();<br>        <span class="hljs-comment">// 通过工具类创建writer 写出到磁盘路径</span><br><span class="hljs-comment">//        ExcelWriter writer = ExcelUtil.getWriter(filesUploadPath + &quot;/用户信息.xlsx&quot;);</span><br>        <span class="hljs-comment">// 在内存操作，写出到浏览器</span><br>        <span class="hljs-type">ExcelWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> ExcelUtil.getWriter(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//自定义标题别名</span><br>        writer.addHeaderAlias(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;用户名&quot;</span>);<br>        writer.addHeaderAlias(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;密码&quot;</span>);<br><br>        <span class="hljs-comment">// 一次性写出list内的对象到excel，使用默认样式，强制输出标题</span><br>        writer.write(list, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 设置浏览器响应的格式</span><br>        response.setContentType(<span class="hljs-string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> URLEncoder.encode(<span class="hljs-string">&quot;用户信息&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + fileName + <span class="hljs-string">&quot;.xlsx&quot;</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        writer.flush(out, <span class="hljs-literal">true</span>);<br>        out.close();<br>        writer.close(); <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExcelReader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-plus</title>
    <link href="/zhouyuchen/2022/12/04/Mybatis-plus/"/>
    <url>/zhouyuchen/2022/12/04/Mybatis-plus/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot-集成Mybatis-plus"><a href="#Spring-Boot-集成Mybatis-plus" class="headerlink" title="Spring Boot 集成Mybatis-plus"></a>Spring Boot 集成Mybatis-plus</h2><p>在pom.xml引入Mybatis-plus </p><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建MybatisPlusConfig （我用的是MySQL数据库）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guanli.xitong.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;你的mapper的reference&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<span class="hljs-comment">//使用MySQL</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写 Mapper 包下的 <code>UserMapper</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>即可开始使用</p><p>下面是例子（分页查询）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询 mybatis plus</span><br><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> IPage&lt;User&gt; <span class="hljs-title function_">findPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer pageNum,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> Integer pageSize,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(defaultValue = &quot;&quot;)</span> String username,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> (defaultValue = <span class="hljs-string">&quot;&quot;</span>)</span>String nikename,<br>                            <span class="hljs-meta">@RequestParam(defaultValue = &quot;&quot;)</span> String address) &#123;<br>    IPage&lt;User&gt;page=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum,pageSize);<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">&quot;username&quot;</span>,username);<br>    queryWrapper.like(<span class="hljs-string">&quot;nikename&quot;</span>,nikename);<br>    queryWrapper.like(<span class="hljs-string">&quot;address&quot;</span>,address);<span class="hljs-comment">//通过Mybatis-plus的methods可知自动拼接条件查询</span><br>    <span class="hljs-keyword">return</span> userService.page(page, queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mybatis-plus代码生成器"><a href="#Mybatis-plus代码生成器" class="headerlink" title="Mybatis-plus代码生成器"></a>Mybatis-plus代码生成器</h2><h3 id="java-sql-SQLException-No-suitable-driver-found"><a href="#java-sql-SQLException-No-suitable-driver-found" class="headerlink" title="java.sql.SQLException: No suitable driver found"></a>java.sql.SQLException: No suitable driver found</h3><p><img src="/zhouyuchen/.io//1675689644096.jpg" alt></p><p>原因是因为mysql-connector-java依赖版本太低，或者没有导入，换成高版本即可(我这使用的是8.0.17)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还需要导入的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意和你的Mybatis-plus版本号一致--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整配置代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    String url= <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/你的数据库名称?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你的数据库用户名&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你的数据库密码&quot;</span>;<br>    FastAutoGenerator.create(url, username, password)<br>            .globalConfig(builder -&gt; &#123;<br>                builder.author(<span class="hljs-string">&quot;你的名字&quot;</span>) <span class="hljs-comment">// 设置作者</span><br>                        .fileOverride() <span class="hljs-comment">// 覆盖已生成文件</span><br>                        .outputDir(<span class="hljs-string">&quot;...\\java\\&quot;</span>); <span class="hljs-comment">// 指定输出目录</span><br>            &#125;)<br>            .packageConfig(builder -&gt; &#123;<br>                builder.parent(<span class="hljs-string">&quot;com.xx.xx&quot;</span>) <span class="hljs-comment">// 设置父包名</span><br>                        .moduleName(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 设置父包模块名 </span><br>                        .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="hljs-string">&quot;...mapper\\&quot;</span>)); <span class="hljs-comment">// 设置mapperXml生成路径 copy mapper reference</span><br>            &#125;)<br>            .strategyConfig(builder -&gt; &#123;<br>                builder.entityBuilder().enableLombok();<span class="hljs-comment">//开启Lombok</span><br>                builder.controllerBuilder().enableHyphenStyle()  <span class="hljs-comment">// 开启驼峰转连字符</span><br>                    .enableRestStyle();  <span class="hljs-comment">// 开启生成@RestController 控制器</span><br>                builder.addInclude(<span class="hljs-string">&quot;你的数据库表名&quot;</span>) <span class="hljs-comment">// 设置需要生成的表名</span><br>                        .addTablePrefix(<span class="hljs-string">&quot;t_&quot;</span>, <span class="hljs-string">&quot;b_&quot;</span>); <span class="hljs-comment">// 设置过滤表前缀</span><br>            &#125;)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完后运行main方法即可看到生成的代码框架</p><p><img src="/zhouyuchen/.io//1675689725109.jpg" alt></p><h3 id="CRUD模板"><a href="#CRUD模板" class="headerlink" title="CRUD模板"></a>CRUD模板</h3><p>在mybatis-plus-generator-版本号.jar（我这里是3.5.1）</p><p><img src="/zhouyuchen/.io//1675689933873.jpg" alt></p><p>选择controller.java.vm复制到resource包下的templates中</p><p>导包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><br><span class="hljs-keyword">import</span> $!&#123;<span class="hljs-keyword">package</span>.Service&#125;.$!&#123;table.serviceName&#125;;<br><span class="hljs-keyword">import</span> $&#123;<span class="hljs-keyword">package</span>.Entity&#125;.$&#123;entity&#125;;<br></code></pre></td></tr></table></figure><p>在文件最后的end下加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> $&#123;table.serviceName&#125; $&#123;table.entityPath&#125;Service;<br><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> $&#123;entity&#125; $&#123;table.entityPath&#125;)</span> &#123;<span class="hljs-comment">//保存或者更新</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.saveOrUpdate($&#123;table.entityPath&#125;);<br>        &#125;<br><br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<span class="hljs-comment">//删除</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.removeById(id);<br>        &#125;<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> List&lt;$&#123;entity&#125;&gt; findAll() &#123;<span class="hljs-comment">//查询所有</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.list();<br>        &#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> $&#123;entity&#125; findOne(<span class="hljs-meta">@PathVariable</span> Integer id) &#123;<span class="hljs-comment">//按照ID查询</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.getById(id);<br>        &#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> Page&lt;$&#123;entity&#125;&gt; findPage(<span class="hljs-meta">@RequestParam</span> Integer pageNum,<span class="hljs-comment">//分页</span><br><span class="hljs-meta">@RequestParam</span> Integer pageSize) &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum, pageSize),queryWrapper);<br>        &#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/del/batch&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Integer&gt; ids)</span> &#123;<span class="hljs-comment">//批量删除</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.removeBatchByIds(ids);<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行之前的main方法即可生成</p><p>其他模板同理！</p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot跨域</title>
    <link href="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/"/>
    <url>/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot跨域"><a href="#SpringBoot跨域" class="headerlink" title="SpringBoot跨域"></a>SpringBoot跨域</h1><p>在前端访问后端出现跨域问题时候</p><p><img src="/zhouyuchen/.io//image-20230202115339681-16753100243391.png" alt="image-20230202115339681"></p><p>通过创建一个CorsConfig .java配置文件来解决，重启即可跨域访问，前端无需配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<br><span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br><br><span class="hljs-comment">// 当前跨域请求最大有效时长。这里默认1天</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>    corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 1 设置访问源地址，即为前端的地址</span><br>    corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 2 设置访问源请求头</span><br>    corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 3 设置访问源请求方法</span><br>    corsConfiguration.setMaxAge(MAX_AGE);<br>    source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsConfiguration); <span class="hljs-comment">// 4 对接口配置跨域设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git上传仓库</title>
    <link href="/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <url>/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Git上传到码云仓库"><a href="#使用Git上传到码云仓库" class="headerlink" title="使用Git上传到码云仓库"></a>使用Git上传到码云仓库</h1><p>在码云新建仓库后</p><p>在需要上传的文件夹右键点击Git Bush Here</p><p>git init进行初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init <br></code></pre></td></tr></table></figure><p>点击克隆，复制你仓库的HTTPS路径，输入git remote add origin + 复制路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin<br></code></pre></td></tr></table></figure><p>git pull origin master 命令，将码云上的仓库pull到本地文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></table></figure><p>git add . （. 表示所有的）或者 git add + 文件名 ，将文件保存到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></table></figure><p>git commit -m “文件描述”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m<br></code></pre></td></tr></table></figure><p>git push origin master ，推送到码云仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure><p>刷新即可</p>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Git</title>
    <link href="/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/"/>
    <url>/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/</url>
    
    <content type="html"><![CDATA[<h1 id="了解Git"><a href="#了解Git" class="headerlink" title="了解Git"></a>了解Git</h1><p>Git（读音为/gɪt/）是一个开源的<strong>分布式</strong>版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h2 id="Git和SVN区别"><a href="#Git和SVN区别" class="headerlink" title="Git和SVN区别"></a>Git和SVN区别</h2><ol><li>核心区别：Git是分布式的，SVN不是</li><li>Git按照元数据方式存储，SVN按照文件方式存储</li><li>Git分支有多种使用方法，例如：创建、切换、合并、删除、跟踪等等，SVN仅仅是另一个文件目录</li><li>Git没有全局的版本号，SVN有</li><li>xxxxxxxxxx class Solution {    public int lengthOfLongestSubstring(String s) {        if (s.length()==0) return 0;        HashMap<Character, integer> map = new HashMap<Character, integer>();        int max = 0;//最长子串长度        int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标        for(int i = 0; i &lt; s.length(); i ++){            if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。                left = Math.max(left,map.get(s.charAt(i)) + 1);       //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移            }        //map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位            map.put(s.charAt(i),i);      //再更新map中a映射的下标            max = Math.max(max,i-left+1);     //比较两个参数的大小        }        return max;            }}java </Character,></Character,></li></ol><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。 </li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h2><p>工作区：你电脑看到的目录</p><p>暂存区：一般存放在.git/index，所以又称为索引（index或者stage）</p><p>版本库：隐藏的.git目录</p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支意味着从开发主线分离出来，而且在不影响主线的情况下同时继续工作</p><p>Git分支分支实际上是指向更改快照的指针</p><p>创建分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch (branchname)<br></code></pre></td></tr></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (branchname)<br></code></pre></td></tr></table></figure><p>合并分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge <br></code></pre></td></tr></table></figure><p>列出分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><p>创建分支并且切换到该分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b (branchname)<br></code></pre></td></tr></table></figure><p>删除分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (branchname)<br></code></pre></td></tr></table></figure><p>如果合并发现冲突需要手动修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add<br>git commit<br></code></pre></td></tr></table></figure><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log //查看历史提交记录<br>git log --oneline //查看历史记录的简洁的版本<br>git log --graph //查看历史中什么时候出现了分支、合并<br>git log --reverse --oneline //逆向显示所有日志<br>git log --author //查找指定用户的提交日志<br>git blame &lt;file&gt; //以列表的形式查看指定文件的历史修改记录<br></code></pre></td></tr></table></figure><h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><p>为什么要使用标签，直接commit不好吗？</p><p>标签即为版本库的一个快照，通过添加标签，可以更加方便查找到版本号：</p><p>commit号可能是51234c…</p><p>标签可以是v1.0</p><p>当达到一个重要阶段，并且希望更加方便记住这个提交，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v1.0 //-a意为创建一个带有注解的标签，可以不加<br></code></pre></td></tr></table></figure><p>查看已有标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag<br></code></pre></td></tr></table></figure><p>删除标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d 版本号<br></code></pre></td></tr></table></figure><p>查看该标签修改的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git show 版本号<br></code></pre></td></tr></table></figure><h2 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h2><p>这是一个Git的图形界面工具（GUI），SourceTree 简化了开发者与代码仓库之间的 Git 操作方式，我们可以通过界面菜单很方便的处理 Git 操作，而不需要通过命令。</p><p>可以在 Sourcetree 官网 <a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a> 直接点击下载按钮来下载，根据提示安装。</p>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>了解Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣</title>
    <link href="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/"/>
    <url>/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><p><img src="/zhouyuchen/.io//image-20201105160612408.png" alt></p><p><img src="/zhouyuchen/.io//image-20201105160645305.png" alt></p><p><img src="/zhouyuchen/.io//image-20201105160658443.png" alt></p><p><img src="/zhouyuchen/.io//image-20201105160719623.png" alt></p><p>主要是先建立2个指针，一个指针移动，一个指针返回值，通过carry表示进位，如果为1就进位，如果为0就直接返回。</p><h2 id="指针滑动窗口"><a href="#指针滑动窗口" class="headerlink" title="指针滑动窗口"></a>指针滑动窗口</h2><p>java的方法：</p><ul><li><p>```java<br>string.charAt(i)<br>//用于返回string字符串i位置的字符</p><p>HashMap<Character, integer> map = new HashMap<Character, integer>()<br>map.put(“key”,1)<br>string key=”apple”<br>boolean contains=map.containsKey(key)<br>//用于比较key值是否包含指定的值</Character,></Character,></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```java <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<span class="hljs-comment">//最长子串长度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左下标，i相当于滑动窗口右下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">containsKey</span>(s.<span class="hljs-built_in">charAt</span>(i)))&#123;<span class="hljs-comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span><br>                left = Math.<span class="hljs-built_in">max</span>(left,map.<span class="hljs-built_in">get</span>(s.<span class="hljs-built_in">charAt</span>(i)) + <span class="hljs-number">1</span>);       <span class="hljs-comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span><br>            &#125;        <span class="hljs-comment">//map.get(&#x27;a&#x27;)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span><br>            map.<span class="hljs-built_in">put</span>(s.<span class="hljs-built_in">charAt</span>(i),i);      <span class="hljs-comment">//再更新map中a映射的下标</span><br>            max = Math.<span class="hljs-built_in">max</span>(max,i-left+<span class="hljs-number">1</span>);     <span class="hljs-comment">//比较两个参数的大小</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装</title>
    <link href="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/"/>
    <url>/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h1><p>由于node版本太低，记录一下更新node</p><p>node中文下载地址：：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p><img src="/zhouyuchen/.io//12.jpg" alt></p><p>对应电脑系统选择（windows）</p><p><img src="/zhouyuchen/.io//1673433881757.jpg" alt></p><p>通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">where node<br></code></pre></td></tr></table></figure><p>查看自己node安装位置</p><p><img src="/zhouyuchen/.io//1673434014083.jpg" alt></p><p>将文件内容全部替换为压缩包内容即可</p><p>查看是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
