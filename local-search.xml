<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UE</title>
    <link href="/zhouyuchen/2025/06/01/UE%E8%93%9D%E5%9B%BE/"/>
    <url>/zhouyuchen/2025/06/01/UE%E8%93%9D%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="UE蓝图"><a href="#UE蓝图" class="headerlink" title="UE蓝图"></a>UE蓝图</h1><h2 id="界面基本介绍"><a href="#界面基本介绍" class="headerlink" title="界面基本介绍"></a>界面基本介绍</h2><p>按住鼠标右键进行WSAD移动，E上升，Q下降，鼠标滚轮控制相机速度</p><p>shift+坐标轴是偏移世界位置</p><p>V键吸附</p><p>在虚幻引擎世界里，空间坐标的单位是厘米（cm），且规定红轴X正方向为前方，绿轴Y正方向为右方，蓝轴Z正方向为上方。显然X轴代表前后方向，Y轴代表左右方向，Z轴代表上下方向。</p><p>ctrl 空格 内容浏览器 布局在视图中 做了工作之后记得保存所有</p><p>游戏模式中选择BP_ThirdPerson进行第三人称模式</p><p>按下F键快速聚焦到物体</p><p>复制：按下alt拖动物体或者ctrl+D</p><p>多选/减选：ctrl 点击</p><p>轴向移动小技巧：<br>关于轴向移动，当我们同时选中两个模型时，我们可以按住鼠标中键，将原本物体的坐标轴拖动到两个物体轴中心的位置，这样我们在旋转这两个物体时会发现，物体是沿着我们改变后的轴向进行的整体移动。</p><p>在静态网格体中更换模型可以直接进行替换</p><p>EV100是一种曝光值的标准，不同的值会影响自动曝光的明暗强度。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/zhouyuchen/2024/08/30/%E6%8A%80%E6%9C%AF%E6%B6%89%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <url>/zhouyuchen/2024/08/30/%E6%8A%80%E6%9C%AF%E6%B6%89%E5%8F%8A%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="惯性张量"><a href="#惯性张量" class="headerlink" title="惯性张量"></a>惯性张量</h1><hr><h3 id="1-数学定义"><a href="#1-数学定义" class="headerlink" title="1. 数学定义"></a><strong>1. 数学定义</strong></h3><h4 id="通用公式："><a href="#通用公式：" class="headerlink" title="通用公式："></a>通用公式：</h4><p>惯性张量是一个对称矩阵，其元素 $ I_{ij} $ 定义为：</p><script type="math/tex; mode=display">I_{ij} = \sum_k m_k \left( \delta_{ij} \| \mathbf{r}_k \|^2 - r_{k,i} r_{k,j} \right)</script><ul><li><strong>$ m_k $</strong>: 第 $ k $ 个点的质量。</li><li><strong>$ \mathbf{r}_k = (x_k, y_k, z_k) $</strong>: 第 $ k $ 个点的位置向量。</li><li><strong>$ \delta_{ij} $</strong>: Kronecker delta（克朗尼克德尔塔），当 $ i = j $ 时 $ \delta_{ij} = 1 $，否则为 $ 0 $。</li><li><strong>$ | \mathbf{r}_k |^2 $</strong>: 位置向量的模长平方，即 $ x_k^2 + y_k^2 + z_k^2 $。</li></ul><p>这个公式分为两部分：</p><ol><li><p><strong>对角线项 $ i = j $</strong>:</p><script type="math/tex; mode=display">I_{ii} = \sum_k m_k \left( \| \mathbf{r}_k \|^2 - r_{k,i}^2 \right)</script><ul><li>$ | \mathbf{r}_k |^2 $：总模长平方。</li><li>$ r_{k,i}^2 $：在当前轴上的分量平方。</li></ul></li><li><p><strong>非对角线项 $ i \neq j $</strong>:</p><script type="math/tex; mode=display">I_{ij} = -\sum_k m_k \cdot r_{k,i} \cdot r_{k,j}</script><ul><li>表示旋转惯性的耦合，体现不同轴间的质量分布相互作用。</li></ul></li></ol><hr><h3 id="2-算法逻辑"><a href="#2-算法逻辑" class="headerlink" title="2. 算法逻辑"></a><strong>2. 算法逻辑</strong></h3><h4 id="计算过程与公式一一对应："><a href="#计算过程与公式一一对应：" class="headerlink" title="计算过程与公式一一对应："></a>计算过程与公式一一对应：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span> diag = m * vertices[i].sqrMagnitude; <span class="hljs-comment">// m * |r_k|^2</span><br></code></pre></td></tr></table></figure><ul><li>这里 <code>vertices[i].sqrMagnitude</code> 是点的模长平方 $ | \mathbf{r}_k |^2 = x_k^2 + y_k^2 + z_k^2 $。</li><li>$ diag $ 对应公式中的 $ m_k | \mathbf{r}_k |^2 $。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">I_ref[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] += diag; <span class="hljs-comment">// 对应 I_xx 中的总模长平方部分</span><br>I_ref[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] += diag; <span class="hljs-comment">// 对应 I_yy</span><br>I_ref[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] += diag; <span class="hljs-comment">// 对应 I_zz</span><br></code></pre></td></tr></table></figure><ul><li>这是为每个主对角线项初始化模长平方的累加。</li></ul><hr><h4 id="减去当前轴分量平方："><a href="#减去当前轴分量平方：" class="headerlink" title="减去当前轴分量平方："></a>减去当前轴分量平方：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">I_ref[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] -= m * vertices[i][<span class="hljs-number">0</span>] * vertices[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// x^2 部分</span><br>I_ref[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] -= m * vertices[i][<span class="hljs-number">1</span>] * vertices[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// y^2 部分</span><br>I_ref[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] -= m * vertices[i][<span class="hljs-number">2</span>] * vertices[i][<span class="hljs-number">2</span>]; <span class="hljs-comment">// z^2 部分</span><br></code></pre></td></tr></table></figure><ul><li>这一步从模长平方中减去当前轴方向的分量平方，确保公式的完整性：<script type="math/tex; mode=display">I_{ii} = m_k (\| \mathbf{r}_k \|^2 - r_{k,i}^2).</script></li></ul><hr><h4 id="更新非对角线项："><a href="#更新非对角线项：" class="headerlink" title="更新非对角线项："></a>更新非对角线项：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">I_ref[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] -= m * vertices[i][<span class="hljs-number">0</span>] * vertices[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// -xy</span><br>I_ref[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] -= m * vertices[i][<span class="hljs-number">0</span>] * vertices[i][<span class="hljs-number">2</span>]; <span class="hljs-comment">// -xz</span><br>I_ref[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] -= m * vertices[i][<span class="hljs-number">1</span>] * vertices[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// -yx</span><br>I_ref[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] -= m * vertices[i][<span class="hljs-number">1</span>] * vertices[i][<span class="hljs-number">2</span>]; <span class="hljs-comment">// -yz</span><br>I_ref[<span class="hljs-number">2</span>, <span class="hljs-number">0</span>] -= m * vertices[i][<span class="hljs-number">2</span>] * vertices[i][<span class="hljs-number">0</span>]; <span class="hljs-comment">// -zx</span><br>I_ref[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] -= m * vertices[i][<span class="hljs-number">2</span>] * vertices[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// -zy</span><br></code></pre></td></tr></table></figure><ul><li>这些计算对应非对角线项公式：<script type="math/tex; mode=display">I_{ij} = -\sum_k m_k r_{k,i} r_{k,j}.</script></li><li>每个顶点对惯性耦合产生贡献，例如：<ul><li>$ I_{xy} $：与顶点 $ (x, y) $ 分量相乘，体现 $ xy $ 耦合。</li></ul></li></ul><hr><h3 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值 "></a><strong>3.赋值 </strong></h3><p>在刚体动力学中，惯性张量通常是 3x3 矩阵，但这里的 <code>I_ref</code> 被扩展为 4x4 矩阵。最后一行（或列）的赋值 $ [3,3] = 1 $ 是为了方便使用<strong>齐次坐标变换</strong>。</p><p><code>I_ref[3, 3] = 1</code></p><ul><li>齐次坐标扩展使惯性张量可以直接与 4x4 矩阵乘法配合，用于变换（如平移、旋转）。</li><li>上三行三列仍然存储惯性张量的主要信息。</li></ul><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>这个算法直接基于惯性张量的定义进行实现：</p><ol><li>先计算对角线项的模长平方。</li><li>减去特定轴上的分量平方。</li><li>更新非对角线项以考虑轴间的耦合惯性。</li><li>最终扩展为齐次形式（赋值 $ I_{33} = 1 $）。</li></ol><p>优化问题本质：一阶导数等于0</p><h1 id="多重网格"><a href="#多重网格" class="headerlink" title="多重网格"></a>多重网格</h1><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20250218144135861.png" alt="image-20250218144135861"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20250225104908890.png" alt="image-20250225104908890"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Matlab</title>
    <link href="/zhouyuchen/2024/08/24/Matlab/"/>
    <url>/zhouyuchen/2024/08/24/Matlab/</url>
    
    <content type="html"><![CDATA[<h1 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h1><p>clear;清空工作区</p><p>clc;清空命令窗口</p><h1 id="矩阵向量"><a href="#矩阵向量" class="headerlink" title="矩阵向量"></a>矩阵向量</h1><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><p>矩阵缩放</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240424173456304.png" alt="image-20240424173456304"></p><p>修改对角线的值</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240424173512613.png" alt="image-20240424173512613"></p><p>旋转</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240424173521492.png" alt="image-20240424173521492"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240424173623412.png" alt="image-20240424173623412"></p><p>移动</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240424173747943.png" alt="image-20240424173747943"></p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等值面计算</title>
    <link href="/zhouyuchen/2024/07/01/%E7%AD%89%E5%80%BC%E9%9D%A2%E8%AE%A1%E7%AE%97/"/>
    <url>/zhouyuchen/2024/07/01/%E7%AD%89%E5%80%BC%E9%9D%A2%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="等值面计算"><a href="#等值面计算" class="headerlink" title="等值面计算"></a>等值面计算</h1><h2 id="有向距离场SDF"><a href="#有向距离场SDF" class="headerlink" title="有向距离场SDF"></a>有向距离场SDF</h2><p>有向距离场（Signed Distance Field, SDF）是一种用于表示形状或几何体的数学模型，在计算机图形学、计算机视觉和物理仿真等领域有广泛应用。它不仅可以描述形状的边界，还能提供形状内部和外部的距离信息。</p><h3 id="有向距离场的定义"><a href="#有向距离场的定义" class="headerlink" title="有向距离场的定义"></a>有向距离场的定义</h3><p>有向距离场是在每个点上存储到最近表面的距离，以及该点是位于表面内部还是外部。这个距离可以是正值、负值或零：</p><ul><li>正值：点位于表面外部。</li><li>负值：点位于表面内部。</li><li>零值：点位于表面上。</li></ul><h3 id="计算有向距离场"><a href="#计算有向距离场" class="headerlink" title="计算有向距离场"></a>计算有向距离场</h3><p>有向距离场的计算可以通过多种方法实现，常见的方法包括：</p><ol><li><strong>离散网格法</strong>：在一个三维网格中计算每个格点到表面的距离。</li><li><strong>几何法</strong>：使用几何算法直接计算点到表面的距离。</li><li><strong>快速距离场变换</strong>：使用快速算法（如Fast Marching Method）计算距离场。</li></ol><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241122093756034.png" alt="image-20241122093756034"></p><p>其中点乘即为向量在该方向上的投影</p><script type="math/tex; mode=display">\vec{a} \cdot \vec{b} = |\vec{a}| |\vec{b}| \cos(\theta)</script><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241122111337685.png" alt="image-20241122111337685"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241122155531394.png" alt="image-20241122155531394"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241122165951389.png" alt="image-20241122165951389"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241122165753159.png" alt="image-20241122165753159"></p><p>判断速度是否向下，越陷越深，N法向上速度，T切线上速度</p><p>impulse可以精确控制不穿透（刚体）  物理世界本质也是penalty（衣服，布料）</p><p>库伦定律</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241202154451817.png" alt="image-20241202154451817"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241202160101540.png" alt="image-20241202160101540"></p><p>向量转为矩阵相乘</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241202160255505.png" alt="image-20241202160255505"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241202160843293.png" alt="image-20241202160843293"> </p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241202161525873.png" alt="image-20241202161525873">                </p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204110934602.png" alt="image-20241204110934602"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204111108984.png" alt=" "></p><h4 id="示例：二维有向距离场"><a href="#示例：二维有向距离场" class="headerlink" title="示例：二维有向距离场"></a>示例：二维有向距离场</h4><p>以下是一个简单的二维有向距离场的示例，计算一个圆形区域的距离场：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SignedDistanceField</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> resolution = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> radius = <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">public</span> Vector2 center = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span>[,] sdf;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        GenerateSDF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateSDF</span>()</span><br>    &#123;<br>        sdf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[resolution, resolution];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; resolution; x++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span>; y &lt; resolution; y++)<br>            &#123;<br>                Vector2 point = <span class="hljs-keyword">new</span> Vector2((<span class="hljs-built_in">float</span>)x / resolution, (<span class="hljs-built_in">float</span>)y / resolution);<br>                <span class="hljs-built_in">float</span> distance = Vector2.Distance(point, center) - radius;<br>                sdf[x, y] = distance;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 输出SDF到控制台</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> y = resolution - <span class="hljs-number">1</span>; y &gt;= <span class="hljs-number">0</span>; y--)<br>        &#123;<br>            <span class="hljs-built_in">string</span> line = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; resolution; x++)<br>            &#123;<br>                line += sdf[x, y].ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            Debug.Log(line);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们计算了一个圆形区域的有向距离场。中心在$(0.5, 0.5)$，半径为$0.5$。距离场被存储在二维数组<code>sdf</code>中，并在控制台输出。</p><h3 id="有向距离场的应用"><a href="#有向距离场的应用" class="headerlink" title="有向距离场的应用"></a>有向距离场的应用</h3><ol><li><p><strong>形状表示与碰撞检测</strong>：SDF用于描述复杂形状的边界，在物理仿真和碰撞检测中尤为重要。与传统的边界表示方法相比，SDF可以更高效地进行距离计算和碰撞检测。</p></li><li><p><strong>纹理与字体渲染</strong>：SDF常用于字体渲染和纹理生成中，特别是在放大或缩小时保持边缘的平滑和清晰。Valve公司在其游戏引擎中使用SDF技术来渲染高质量的字体和符号。</p></li><li><p><strong>流体和烟雾模拟</strong>：在流体和烟雾模拟中，SDF可以用来表示障碍物和界面，用于模拟复杂流体运动和交互。</p></li><li><p><strong>三维建模与重建</strong>：SDF用于从扫描数据重建三维模型。通过将点云数据转换为SDF，可以生成具有平滑表面的高质量三维模型。</p></li></ol><h3 id="优势与挑战"><a href="#优势与挑战" class="headerlink" title="优势与挑战"></a>优势与挑战</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>准确性</strong>：SDF可以精确描述复杂形状的边界和内部结构。</li><li><strong>高效性</strong>：在距离计算和碰撞检测方面，SDF比传统方法更高效。</li><li><strong>多用途</strong>：SDF可以用于渲染、模拟、重建等多个领域。</li></ul><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li><strong>计算复杂性</strong>：生成和更新SDF可能计算复杂且耗时，尤其是对于高分辨率的场景。</li><li><strong>存储需求</strong>：高分辨率的SDF需要大量的存储空间。</li></ul><p>有向距离场作为一种强大的形状表示工具，在许多领域发挥着重要作用。通过合理的算法和优化技术，可以有效地利用SDF来解决复杂的计算机图形学和仿真问题。</p><h2 id="DC双重轮廓化"><a href="#DC双重轮廓化" class="headerlink" title="DC双重轮廓化"></a>DC双重轮廓化</h2><p>Dual Contouring (DC) 是一种用于从有向距离场（SDF）或其他隐式表面表示中提取多边形网格的高级算法。它是一种改进的表面重建方法，相较于传统的 Marching Cubes 算法，DC 更加擅长捕捉锐边和细节特征。以下是对 Dual Contouring 的详细介绍。</p><h3 id="Dual-Contouring-的基本概念"><a href="#Dual-Contouring-的基本概念" class="headerlink" title="Dual Contouring 的基本概念"></a>Dual Contouring 的基本概念</h3><p>Dual Contouring 使用的基本思想是通过将每个网格单元（或体素）转化为一个顶点，并通过这些顶点生成网格的几何形状。它可以在保留原始几何特征（如锐边和细节）的同时，生成高质量的多边形网格。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>顶点生成</strong>：在每个网格单元中，根据其八个角点的距离值和梯度（或法向量），计算一个优化顶点。这个顶点通常位于该单元的内部，靠近表面的位置。</p></li><li><p><strong>顶点连接</strong>：通过连接相邻单元的顶点，形成多边形面。顶点的连接方式根据单元的标量值和邻接关系确定。</p></li></ol><h3 id="优化顶点的计算"><a href="#优化顶点的计算" class="headerlink" title="优化顶点的计算"></a>优化顶点的计算</h3><p>在每个网格单元中，优化顶点的位置可以通过最小化一个误差函数来确定，这个误差函数通常表示顶点与原始表面的距离。常用的优化方法包括线性最小二乘法。</p><h4 id="示例算法"><a href="#示例算法" class="headerlink" title="示例算法"></a>示例算法</h4><p>以下是一个简化的 Dual Contouring 算法示例，用于从三维有向距离场中生成多边形网格：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DualContouring</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> resolution = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> isoLevel = <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span>[,,] scalarField;<br>    <span class="hljs-keyword">private</span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword">new</span> List&lt;Vector3&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">int</span>&gt; triangles = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        GenerateScalarField();<br>        GenerateMesh();<br>        CreateMesh();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateScalarField</span>()</span><br>    &#123;<br>        scalarField = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[resolution, resolution, resolution];<br>        <span class="hljs-comment">// 示例：生成简单的噪声标量场</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; resolution; x++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span>; y &lt; resolution; y++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> z = <span class="hljs-number">0</span>; z &lt; resolution; z++)<br>                &#123;<br>                    <span class="hljs-built_in">float</span> noiseValue = Mathf.PerlinNoise(x * <span class="hljs-number">0.1f</span>, y * <span class="hljs-number">0.1f</span>) - (z * <span class="hljs-number">0.1f</span>);<br>                    scalarField[x, y, z] = noiseValue;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateMesh</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>; x &lt; resolution - <span class="hljs-number">1</span>; x++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span>; y &lt; resolution - <span class="hljs-number">1</span>; y++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> z = <span class="hljs-number">0</span>; z &lt; resolution - <span class="hljs-number">1</span>; z++)<br>                &#123;<br>                    ProcessCell(x, y, z);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessCell</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, <span class="hljs-built_in">int</span> z</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 提取单元的8个角点</span><br>        Vector3[] cellCorners = <span class="hljs-keyword">new</span> Vector3[<span class="hljs-number">8</span>];<br>        <span class="hljs-built_in">float</span>[] cellScalars = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">int</span> dx = (i &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> dy = (i &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> dz = (i &amp; <span class="hljs-number">4</span>) != <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            cellCorners[i] = <span class="hljs-keyword">new</span> Vector3(x + dx, y + dy, z + dz);<br>            cellScalars[i] = scalarField[x + dx, y + dy, z + dz];<br>        &#125;<br><br>        <span class="hljs-comment">// 计算优化顶点</span><br>        Vector3 vertex = CalculateOptimalVertex(cellCorners, cellScalars);<br><br>        <span class="hljs-comment">// 在此示例中，我们简单地将顶点添加到列表中，并生成三角形（实际应用中会更复杂）</span><br>        vertices.Add(vertex);<br>        <span class="hljs-keyword">if</span> (vertices.Count &gt;= <span class="hljs-number">3</span>)<br>        &#123;<br>            triangles.Add(vertices.Count - <span class="hljs-number">1</span>);<br>            triangles.Add(vertices.Count - <span class="hljs-number">2</span>);<br>            triangles.Add(vertices.Count - <span class="hljs-number">3</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">Vector3 <span class="hljs-title">CalculateOptimalVertex</span>(<span class="hljs-params">Vector3[] corners, <span class="hljs-built_in">float</span>[] scalars</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 简单实现：计算角点的平均值作为优化顶点</span><br>        Vector3 optimalVertex = Vector3.zero;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            optimalVertex += corners[i];<br>        &#125;<br>        optimalVertex /= <span class="hljs-number">8.0f</span>;<br>        <span class="hljs-keyword">return</span> optimalVertex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateMesh</span>()</span><br>    &#123;<br>        Mesh mesh = <span class="hljs-keyword">new</span> Mesh();<br>        mesh.vertices = vertices.ToArray();<br>        mesh.triangles = triangles.ToArray();<br>        mesh.RecalculateNormals();<br><br>        MeshFilter meshFilter = GetComponent&lt;MeshFilter&gt;();<br>        <span class="hljs-keyword">if</span> (meshFilter == <span class="hljs-literal">null</span>)<br>            meshFilter = gameObject.AddComponent&lt;MeshFilter&gt;();<br><br>        MeshRenderer meshRenderer = GetComponent&lt;MeshRenderer&gt;();<br>        <span class="hljs-keyword">if</span> (meshRenderer == <span class="hljs-literal">null</span>)<br>            meshRenderer = gameObject.AddComponent&lt;MeshRenderer&gt;();<br><br>        meshFilter.mesh = mesh;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Dual Contouring 在多个领域有广泛应用：</p><ol><li><strong>三维建模与重建</strong>：从点云数据或体数据中重建三维模型，特别适用于需要保留细节和锐边的场景。</li><li><strong>物理仿真与碰撞检测</strong>：通过生成高质量的多边形网格，用于物理仿真和精确的碰撞检测。</li><li><strong>计算机图形学</strong>：在游戏开发和动画制作中，用于生成复杂的几何体和场景。</li></ol><h3 id="优势与挑战-1"><a href="#优势与挑战-1" class="headerlink" title="优势与挑战"></a>优势与挑战</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li><strong>高质量网格</strong>：DC 能够生成捕捉细节和锐边的高质量网格。</li><li><strong>灵活性</strong>：适用于多种隐式表面表示和复杂形状。</li><li><strong>效率</strong>：在保留细节的同时，计算效率较高。</li></ul><h4 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h4><ul><li><strong>复杂性</strong>：实现和优化 DC 算法可能较为复杂，特别是处理大规模数据时。</li><li><strong>顶点优化</strong>：需要有效的优化方法来计算顶点，以保证网格质量和准确性。</li></ul><p>Dual Contouring 是一种强大且灵活的表面重建技术，在需要高质量几何表示和保留细节特征的应用中，具有重要价值。通过合理的实现和优化，DC 可以在多种领域中发挥重要作用。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>等值面计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹簧</title>
    <link href="/zhouyuchen/2024/07/01/%E7%BA%A6%E6%9D%9F/"/>
    <url>/zhouyuchen/2024/07/01/%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="弹簧"><a href="#弹簧" class="headerlink" title="弹簧"></a>弹簧</h1><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204125644018.png" alt="image-20241204125644018"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204130057541.png" alt="image-20241204130057541"></p><p>显示积分可能会导致overshooting</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204131809950.png" alt="image-20241204131809950"></p><p>显式积分</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241204135054370.png" alt="image-20241204135054370"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241212165411237.png" alt="image-20241212165411237"></p><p>牛顿法</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20241212171345051.png" alt="image-20241212171345051"></p><p><strong>克服overshooting，使用优化求解，而不是简单的线性求解</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>弹簧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文研读笔记</title>
    <link href="/zhouyuchen/2024/06/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/zhouyuchen/2024/06/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Local-Deformation-for-Interactive-Shape-Editing"><a href="#Local-Deformation-for-Interactive-Shape-Editing" class="headerlink" title="Local Deformation for Interactive Shape Editing"></a>Local Deformation for Interactive Shape Editing</h1><p><strong>交互式形状编辑的局部变形</strong></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化参数等价于对参数引入先验分布，使得模型复杂度变小（缩小解空间），对于噪声以及异常值的鲁棒性增强（泛化能力）。</p><p>  正则化项本质上是一种先验信息，整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式，如果你将这个贝叶斯最大后验估计的形式取对数，即进行极大似然估计，你就会发现问题立马变成了损失函数+正则化项的最优化问题形式。</p><h3 id="L0范数"><a href="#L0范数" class="headerlink" title="L0范数"></a>L0范数</h3><p>L0范数定义为向量中非零元素的个数</p><p>L0范数常常用来表示模型的复杂性或者模型的稀疏性。例如，如果你想要构建一个稀疏的模型（即模型中的大部分参数都是0），你可能会试图最小化模型参数的L0范数。然而，<strong>L0范数的问题在于它是非凸的</strong>，这使得相关的优化问题变得非常困难。因此，在实际应用中，人们<strong>常常使用L1范数来代替L0范数</strong>，因为L1范数在保持稀疏性的同时，其优化问题是凸的，更容易求解。</p><h3 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h3><p>L1范数，也被称为曼哈顿距离或者绝对值和，是向量中所有元素的绝对值之和。</p><p>L1范数在机器学习和数据科学中有很多应用。例如，在线性回归模型中，L1范数可以用来进行特征选择和生成稀疏模型。当我们将L1范数作为正则化项加入到模型的损失函数中，这种方法被称为<strong>Lasso回归</strong>[ˈlæsoʊ]。L1范数因为其产生稀疏解的特性，是一种常用的特征选择方法，可以用来剔除不重要的特征。</p><h3 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h3><p>L2范数是一种衡量向量大小的方法，也被称为欧几里得范数或者欧几里得长度。L2范数就是向量元素平方和的平方根。</p><p>在线性回归模型中，L2范数可以用来进行正则化，防止模型过拟合。当我们将L2范数作为正则化项加入到模型的损失函数中，这种方法被称为<strong>岭回归或者L2正则化</strong>。L2正则化的效果是使得模型的权重向量尽可能小，从而限制了模型复杂度，提高了模型的泛化能力。</p><h1 id="Robust-Low-Poly-Meshing-for-General-3D-Models"><a href="#Robust-Low-Poly-Meshing-for-General-3D-Models" class="headerlink" title="Robust Low-Poly Meshing for General 3D Models"></a>Robust Low-Poly Meshing for General 3D Models</h1><p><strong>一般三维模型的鲁棒Low - Poly Meshing</strong></p><h2 id="几何误差导向技术"><a href="#几何误差导向技术" class="headerlink" title="几何误差导向技术"></a>几何误差导向技术</h2><p>几何误差导向技术是计算机图形学和几何建模中使用的一种方法，用于管理和优化几何形状或物体的表示。这些技术利用几何误差的概念，即近似（例如简化的网格）与原始几何体（例如高分辨率模型）之间的差异。其目标是在视觉保真度和计算效率之间找到平衡。以下是一些几何误差导向技术的详细解释：</p><ol><li><p><strong>误差度量</strong>：</p><ul><li><strong>几何误差</strong>：这是这些技术中使用的主要度量标准，用于量化原始几何与近似之间的差异。常见的度量包括Hausdorff距离、均方根误差和平均误差。</li><li><strong>视觉误差</strong>：这个度量评估人眼能感知到的差异，关注视觉上的效果。</li></ul></li><li><p><strong>简化技术</strong>：</p><ul><li><strong>网格简化</strong>：使用边折叠或顶点聚类等算法减少网格中的三角形数量，同时保持其整体形状。</li><li><strong>细节层次（LoD）模型</strong>：创建多个模型版本，每个版本具有不同的细节级别。根据观察者与物体的距离选择合适的LoD模型。</li></ul></li><li><p><strong>表面逼近</strong>：</p><ul><li><strong>参数化和逼近</strong>：使用参数化方法来识别感兴趣的区域，从而通过逼近技术减少数据集的大小。</li></ul></li></ol><h3 id="Hausdorff距离等"><a href="#Hausdorff距离等" class="headerlink" title="Hausdorff距离等"></a>Hausdorff距离等</h3><p>这些指标通常用于衡量几何误差导向技术中原始几何体与近似几何体之间的差异和误差。让我们逐个来看它们的定义和用途：</p><ol><li><strong>Hausdorff距离</strong>：<ul><li><strong>定义</strong>：Hausdorff距离是两个集合（或几何体）之间的一种度量，表示两个集合中每个点到另一个集合的最短距离中的最大值。在几何误差导向技术中，它通常用来衡量两个几何体之间的最大距离，即最大误差。</li><li><strong>应用</strong>：用于评估简化后的几何体与原始几何体之间的最大形状差异，可以帮助确定简化后几何体的保真度和精确度。</li></ul></li><li><strong>均方根误差（RMS误差）</strong>：<ul><li><strong>定义</strong>：均方根误差是测量两个几何体（或集合）之间每个点之间距离差异的平均值。在几何误差导向技术中，它表示近似几何体和原始几何体之间的平均形状差异。</li><li><strong>应用</strong>：通常用于评估简化算法的整体效果，因为它提供了全局误差的一种统计测量。</li></ul></li><li><strong>平均误差</strong>：<ul><li><strong>定义</strong>：平均误差是指两个几何体之间每个点之间距离差异的平均值。与均方根误差类似，但平均误差没有进行平方根操作，因此直接表示平均距离差异。</li><li><strong>应用</strong>：与均方根误差类似，用于评估几何体简化或逼近后的平均形状差异，提供了对几何体整体精度的衡量。</li></ul></li></ol><h2 id="拉普拉斯正则化项"><a href="#拉普拉斯正则化项" class="headerlink" title="拉普拉斯正则化项"></a>拉普拉斯正则化项</h2><p>拉普拉斯正则化（Laplacian Regularization）是一种常用于3D网格优化的技术，它通过对网格顶点位置进行平滑处理，以减少不必要的锐角和噪声，从而生成更平滑、更自然的网格。以下是关于拉普拉斯正则化项的详细介绍：</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>拉普拉斯正则化项主要基于拉普拉斯算子（Laplacian Operator），它在离散情况下可以应用于网格顶点来计算每个顶点相对于其邻居的偏差。其核心思想是，如果一个顶点的位置与其邻居的平均位置偏差过大，那么对该顶点的位置进行适当的调整，以减少这种偏差，从而实现网格的平滑化。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>在3D网格中，每个顶点的位置可以表示为</p><script type="math/tex; mode=display">\mathbf{v}_i = (x_i, y_i, z_i)</script><p>其拉普拉斯算子可以表示为：</p><script type="math/tex; mode=display">\Delta \mathbf{v}_i = \mathbf{v}_i - \frac{1}{|\mathcal{N}(i)|} \sum_{j \in \mathcal{N}(i)} \mathbf{v}_j</script><p>其中，</p><script type="math/tex; mode=display">\mathcal{N}(i)</script><p>表示顶点 i 的邻居顶点集合，|N(i)| 是邻居顶点的数量。拉普拉斯算子反映了顶点i 相对于其邻居的偏差。</p><h3 id="拉普拉斯正则化项-1"><a href="#拉普拉斯正则化项-1" class="headerlink" title="拉普拉斯正则化项"></a>拉普拉斯正则化项</h3><p>在优化过程中，拉普拉斯正则化项可以添加到损失函数中，用于惩罚过大的偏差。常见的拉普拉斯正则化项形式为：</p><script type="math/tex; mode=display">L_{\text{Lap}} = \sum_{i} \left\| \Delta \mathbf{v}_i \right\|^2 = \sum_{i} \left\| \mathbf{v}_i - \frac{1}{|\mathcal{N}(i)|} \sum_{j \in \mathcal{N}(i)} \mathbf{v}_j \right\|^2</script><p>通过最小化该正则化项，可以有效地平滑网格，避免生成不自然的锐角和噪声。</p><h3 id="优势与应用"><a href="#优势与应用" class="headerlink" title="优势与应用"></a>优势与应用</h3><p><strong>优势</strong>：</p><ol><li><strong>平滑效果显著</strong>：拉普拉斯正则化能够显著平滑3D网格，减少噪声和不自然的锐角。</li><li><strong>计算效率高</strong>：计算拉普拉斯正则化项相对简单高效，适合大规模网格优化。</li></ol><p><strong>应用</strong>：</p><ol><li><strong>3D重建</strong>：在BSP-Net等3D重建方法中，通过添加拉普拉斯正则化项，可以生成更平滑、更自然的3D网格。</li><li><strong>模型简化</strong>：在多边形简化过程中，使用拉普拉斯正则化可以保持简化后的模型平滑性。</li><li><strong>动画和仿真</strong>：在3D动画和物理仿真中，通过拉普拉斯正则化，可以避免网格的过度变形，保持模型的整体平滑性。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设我们有一个简单的三角形网格，如下图所示，其中每个顶点与其邻居相连。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-selector-tag">A</span><br>/ | \<br><span class="hljs-selector-tag">B</span><span class="hljs-selector-tag">---C</span><br></code></pre></td></tr></table></figure><p>顶点$A$的拉普拉斯算子为：</p><script type="math/tex; mode=display">\Delta \mathbf{v}_A = \mathbf{v}_A - \frac{1}{2} (\mathbf{v}_B + \mathbf{v}_C)<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br>通过最小化以下损失函数：<br><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>L_&#123;\text&#123;Lap&#125;&#125; = \left\| \Delta \mathbf&#123;v&#125;_A \right\|^<span class="hljs-number">2</span> + \left\| \Delta \mathbf&#123;v&#125;_B \right\|^<span class="hljs-number">2</span> + \left\| \Delta \mathbf&#123;v&#125;_C \right\|^<span class="hljs-number">2</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><br>我们可以平滑整个网格，使得每个顶点的位置更加接近其邻居的平均位置。<br><br><br><br><span class="hljs-comment">## BSP-net</span><br><br>BSP<span class="hljs-literal">-Net</span> 是一种用于<span class="hljs-number">3</span>D网格重建的学习方法，通过构建二叉空间分割（Binary Space Partitioning, BSP）树来生成多边形网格。以下是对BSP<span class="hljs-literal">-Net</span>的详细介绍：<br><br><span class="hljs-comment">### 基本原理</span><br>BSP<span class="hljs-literal">-Net</span>利用二叉空间分割树来表示<span class="hljs-number">3</span>D几何形状。这种表示方法的核心思想是将空间递归地划分为两个子空间，通过一系列平面分割直到整个空间被充分细分。每个节点对应一个划分平面，叶子节点则对应最终的空间分割结果。<br><br><span class="hljs-comment">### 方法步骤</span><br><br><span class="hljs-number">1</span>. **数据准备**：<br>   - **数据集**：BSP<span class="hljs-literal">-Net</span>需要大量的训练数据，这些数据通常包括<span class="hljs-number">3</span>D模型及其对应的<span class="hljs-number">2</span>D图像。每个<span class="hljs-number">3</span>D模型都需要有明确的内/外分割。<br>   - **体素化**：数据集中的<span class="hljs-number">3</span>D模型需要进行体素化处理，即将连续的<span class="hljs-number">3</span>D几何形状转换为离散的体素（体积像素）表示，以便于网络训练。<br><br><span class="hljs-number">2</span>. **网络架构**：<br>   - **编码器-解码器结构**：BSP<span class="hljs-literal">-Net</span>通常采用编码器-解码器结构。编码器将输入的<span class="hljs-number">2</span>D图像转换为潜在空间表示，解码器则根据这些潜在表示生成BSP树。<br>   - **BSP树生成**：解码器输出一系列平面参数，这些平面参数定义了BSP树的结构，表示对<span class="hljs-number">3</span>D空间的划分。<br><br><span class="hljs-number">3</span>. **训练过程**：<br>   - **损失函数**：BSP<span class="hljs-literal">-Net</span>的训练过程依赖于特定的损失函数，这些损失函数评估生成网格与目标网格之间的差异。常见的损失包括重建损失和正则化损失，前者评估生成网格的准确性，后者则确保网格的平滑性和简洁性。<br>   - **优化方法**：使用标准的反向传播算法和优化器（如Adam）来最小化损失函数，调整网络权重。<br><br><span class="hljs-number">4</span>. **网格生成**：<br>   - **平面交集和选择**：通过BSP树中的划分平面计算<span class="hljs-number">3</span>D网格的顶点和面。<br>   - **网格优化**：生成的初始网格可能包含不理想的锐角和不规则形状，进一步的优化步骤包括平滑处理和参数调整。<br><br><span class="hljs-comment">### 优势与局限</span><br><br>**优势**：<br>- **低多边形生成**：BSP<span class="hljs-literal">-Net</span>能够从<span class="hljs-number">2</span>D图像生成低多边形网格，这在计算和存储资源有限的应用中非常有用。<br>- **自动化程度高**：通过深度学习实现了<span class="hljs-number">3</span>D网格重建的自动化，减少了对人工干预的依赖。<br><br>**局限**：<br>- **数据需求大**：需要大量的带有明确内外分割的<span class="hljs-number">3</span>D数据进行训练。<br>- **模型泛化性差**：训练好的模型通常只能适用于与训练数据类型相似的网格，无法很好地处理不同类型的网格。<br>- **参数调整复杂**：生成的网格可能需要进一步的手动优化，这对参数调整的技术要求较高。<br><br><span class="hljs-comment">### 典型应用</span><br>BSP<span class="hljs-literal">-Net</span>在各种计算机视觉和图形学应用中有潜力，包括但不限于：<br>- **虚拟现实（VR）和增强现实（AR）**：生成低多边形网格用于实时渲染。<br>- **游戏开发**：创建游戏中的低多边形模型，以减少计算负载。<br>- **工业设计**：从<span class="hljs-number">2</span>D图纸或图片生成<span class="hljs-number">3</span>D模型，用于设计和制造过程。<br><br><span class="hljs-comment">### 相关研究</span><br>Chen等人在<span class="hljs-number">2020</span>年的研究中展示了BSP<span class="hljs-literal">-Net</span>的应用，证明了该方法在从<span class="hljs-number">2</span>D图像生成低多边形网格方面的有效性。同时，也指出了该方法的一些常见问题，例如需要大量训练数据和生成网格的优化问题。Munkberg等人在<span class="hljs-number">2022</span>年的研究进一步探讨了将BSP<span class="hljs-literal">-Net</span>与可微分渲染框架结合的可能性，展示了同时优化网格和材料的潜力。<br><br>总的来说，BSP<span class="hljs-literal">-Net</span>是一种创新的<span class="hljs-number">3</span>D网格重建方法，通过利用深度学习和BSP树的结合，实现了从<span class="hljs-number">2</span>D图像到<span class="hljs-number">3</span>D网格的高效转换，但也面临着数据需求和优化复杂度等挑战。<br><br><br><br><span class="hljs-comment">## 对偶网格</span><br><br><span class="hljs-string">&quot;Dual grid alignment&quot;</span> 是一个在计算机图形学和<span class="hljs-number">3</span>D网格处理中的概念，通常涉及到对<span class="hljs-number">3</span>D网格进行优化和重构，以便于实现更高效和准确的几何表示。以下是对这个概念的详细介绍：<br><br><span class="hljs-comment">### 基本概念</span><br><br>在网格处理和优化过程中，“dual grid”  是指从原始网格（primal grid）中派生出来的一个网格系统。原始网格的顶点、边和面在对偶网格（dual  grid）中对应不同的几何元素。例如，原始网格中的顶点在对偶网格中通常对应的是对偶网格的面，而原始网格的面则对应对偶网格的顶点。<br><br><span class="hljs-comment">### 对偶网格的构建</span><br><br>构建对偶网格的常见方法之一是 Voronoi 图。给定一个原始网格，Voronoi 图的每个单元代表一个原始网格顶点的影响区域。这些区域形成了对偶网格的面，而这些面在几何上与原始网格的面正交。<br><br><span class="hljs-comment">### 对齐与优化</span><br><br>对偶网格的对齐（dual grid alignment）通常涉及到以下几个方面：<br><br><span class="hljs-number">1</span>. **顶点对齐**：确保对偶网格的顶点与原始网格的顶点相匹配。这意味着优化对偶网格的几何结构，使其尽可能与原始网格的结构保持一致。<br><span class="hljs-number">2</span>. **边界对齐**：确保对偶网格的边界与原始网格的边界相匹配。这对于处理开口网格（如<span class="hljs-number">3</span>D扫描中常见的网格）特别重要，以确保对偶网格的生成和优化过程中不产生伪影。<br><span class="hljs-number">3</span>. **优化目标**：通过对齐过程，优化目标通常包括最小化网格的几何误差、提高网格的光滑度以及确保网格的拓扑结构不变。<br><br><span class="hljs-comment">### 应用场景</span><br><br>对偶网格对齐和优化在以下场景中有重要应用：<br><br><span class="hljs-number">1</span>. **<span class="hljs-number">3</span>D重建**：在从点云或图像生成<span class="hljs-number">3</span>D网格时，使用对偶网格对齐可以帮助生成更高质量的网格，减少噪声和伪影。<br><span class="hljs-number">2</span>. **物理仿真**：在物理仿真中，对偶网格对齐可以确保网格的几何结构稳定，从而提高仿真的准确性和稳定性。<br><span class="hljs-number">3</span>. **网格简化**：在网格简化过程中，使用对偶网格对齐可以帮助保留重要的几何特征，同时减少网格的多边形数量。<br><br><br><br><span class="hljs-comment">## 双重立方体算法 </span><br><br>双重立方体算法（Dual Marching Cubes，DMC）是对经典立方体算法（Marching Cubes, MC）的一种扩展。经典立方体算法用于从体数据生成多边形网格，它在医学成像和科学可视化中有广泛应用。然而，MC算法有时会产生不规则的网格，尤其是在处理高复杂度和细节的结构时。<br><br><span class="hljs-comment">### 梯度</span><br><br>向量微分算子可以和向量和数值做运算<br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20240704140624971</span>](论文研读笔记/image<span class="hljs-literal">-20240704140624971</span>.png)<br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20240704141148278</span>](论文研读笔记/image<span class="hljs-literal">-20240704141148278</span>.png)<br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20240704141702343</span>](论文研读笔记/image<span class="hljs-literal">-20240704141702343</span>.png)<br><br><span class="hljs-comment">### 等值线、面</span><br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20240704135011922</span>](论文研读笔记/image<span class="hljs-literal">-20240704135011922</span>.png)<br><br><span class="hljs-comment">#### 双重立方体算法的优势</span><br><br><span class="hljs-number">1</span>. **双网格表示**：DMC算法引入了双网格的概念，不仅考虑原始网格（原始网格是定义标量场值的网格），还使用一个双网格（通常在原始网格顶点处生成）。这种双网格表示有助于生成更加规则和精确的三角网格。<br><br><span class="hljs-number">2</span>. **提高网格质量**：通过使用双网格，DMC算法可以减少经典MC算法中的网格伪影和不规则性，生成更平滑、更高质量的表面。<br><br><span class="hljs-comment">#### 双重立方体算法的工作原理</span><br><br><span class="hljs-number">1</span>. **原始网格评估**：与MC算法类似，首先在原始网格的每个顶点上评估标量场。<br><br><span class="hljs-number">2</span>. **构建双网格**：在原始网格顶点处生成双网格的网格单元（这些单元通常是以原始网格顶点为中心的）。<br><br><span class="hljs-number">3</span>. **表面提取**：在每个双网格单元中，根据对应的原始网格顶点上的标量值确定与等值面的交点。这些交点定义了最终网格的顶点和三角形。<br><br><span class="hljs-number">4</span>. **生成网格**：根据交点生成三角形补丁，形成表示标量场等值面的网格。<br><br><span class="hljs-comment">#### 应用领域</span><br><br>- **医学成像**：生成解剖结构的平滑、准确的表面表示。<br>- **科学可视化**：可视化复杂的<span class="hljs-number">3</span>D科学数据集，需要精确的表面表示。<br>- **工程模拟**：生成用于数值模拟的网格，这些模拟对表面质量和规则性有严格要求。<br><br>总之，双重立方体算法通过双网格表示，改进了经典立方体算法，生成更规则、更精确的表面网格，适用于医学成像、科学可视化和工程模拟等领域。<br><br><span class="hljs-comment">### 红外跳转算法</span><br><br>图形学中的红外跳转算法（Infrared Jump Algorithm）主要用于快速路径规划和导航。该算法通常用于机器人、游戏AI以及其他需要高效路径计算的应用中。以下是对红外跳转算法的介绍：<br><br><span class="hljs-comment">#### 红外跳转算法简介</span><br><br>红外跳转算法是一种基于网格的路径搜索算法。它通过预处理网格中的可行路径，减少实时路径搜索的计算量。红外跳转算法的主要思想是通过跳点（Jump Points）的概念优化A*算法，从而提高路径搜索的效率。<br><br><span class="hljs-comment">#### 红外跳转算法的核心概念</span><br><br><span class="hljs-number">1</span>. **跳点（Jump Points）**：<br>   跳点是网格中的特殊节点，它们是路径中转弯或改变方向的关键点。算法通过跳点跳跃，可以跳过多余的节点，从而加快路径搜索速度。<br><br><span class="hljs-number">2</span>. **强迫邻居（Forced Neighbors）**：<br>   强迫邻居是相对于当前节点在某个方向上的必须检查的节点。它们通常是因为障碍物的存在而强制需要检查的节点，以确保路径的连通性。<br><br><span class="hljs-number">3</span>. **方向性跳跃（Directional Jumping）**：<br>   在搜索路径时，算法根据当前的移动方向进行方向性跳跃，直到遇到障碍物、网格边界或者找到一个跳点。<br><br><span class="hljs-comment">#### 红外跳转算法的步骤</span><br><br><span class="hljs-number">1</span>. **预处理阶段**：<br>   预处理阶段算法对网格进行分析，标记所有的跳点和强迫邻居。这个过程可以显著减少实际路径搜索时的计算量。<br><br><span class="hljs-number">2</span>. **路径搜索阶段**：<br>   在路径搜索阶段，算法从起点开始，按照A*算法的方式进行搜索，但每次移动时，它会跳过多个节点，直接跳到下一个跳点。这种跳跃通过检查强迫邻居来确保路径的有效性和连通性。<br><br><span class="hljs-number">3</span>. **回溯路径**：<br>   当搜索到目标节点时，算法通过记录的路径信息回溯出完整的路径。<br><br><span class="hljs-comment">#### 红外跳转算法的优点</span><br><br><span class="hljs-number">1</span>. **效率高**：<br>   由于跳过了大量不必要的节点，红外跳转算法比传统的A*算法更加高效，特别是在大规模网格中效果显著。<br><span class="hljs-number">2</span>. **路径优化**：<br>   跳点的使用使得生成的路径更加直接和优化，减少了不必要的弯折。<br><br><span class="hljs-comment">### Voronoi图</span><br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20240704200941129</span>](论文研读笔记/image<span class="hljs-literal">-20240704200941129</span>.png)<br><br>https://blog.csdn.net/gongdiwudu/article/details/<span class="hljs-number">132221308</span><br><br><span class="hljs-comment">### 内点法</span><br><br><br><br><span class="hljs-comment"># 多样性基准构型驱动的网格变形方法</span><br><br><span class="hljs-comment">## 径向基函数RBF Radial basis function</span><br><br>**径向基函数**：是一种实值函数，其值仅依赖于到中心点的距离。形式上，RBF可以表示为<br><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>f(∥x−c∥)<br><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>其中 x 是输入，c 是中心点，∥x−c∥ 表示 x 和 c 之间的欧几里得距离。<br><br><br><br><span class="hljs-comment"># 基于径向基函数的网格变形</span><br><br><span class="hljs-comment">## 欧式空间中的二维流形曲面S </span><br><br>欧式空间即为向量空间<br><br>在欧氏空间中的二维流形曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 被映射到另一个曲面 <span class="hljs-variable">$S</span><span class="hljs-string">&#x27;$ 的过程中，最小化这种映射带来的形变</span><br><span class="hljs-string"></span><br><span class="hljs-string">曲面S是一个二维的几何对象，它嵌入在更高维的欧氏空间中（通常是三维空间）。在 S 上的每个点都有一个邻域，这个邻域在某种意义上看起来像是平面。</span><br><span class="hljs-string"></span><br><span class="hljs-string">。这个过程涉及到一些几何和变分问题的概念。以下是对这一过程的详细解释：</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 1. **曲面映射与区域变换**</span><br><span class="hljs-string"></span><br><span class="hljs-string">- **曲面 $S$ 和 $S&#x27;</span><span class="hljs-variable">$</span>**：<br>  - 假设我们有一个二维流形曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span>，它嵌入在三维欧氏空间 <span class="hljs-variable">$</span>\mathbb&#123;<span class="hljs-built_in">R</span>&#125;^<span class="hljs-number">3</span><span class="hljs-variable">$</span> 中。<br>  - 通过映射 <span class="hljs-variable">$</span>\varphi: S \to S<span class="hljs-string">&#x27;$，曲面 $S$ 被变换到另一个曲面 $S&#x27;</span><span class="hljs-variable">$</span>，其中 <span class="hljs-variable">$S</span><span class="hljs-string">&#x27;$ 也是嵌入在 $\mathbb&#123;R&#125;^3$ 中的二维流形。</span><br><span class="hljs-string"></span><br><span class="hljs-string">- **区域 $\Delta S$ 和 $\varphi(\Delta S)$**：</span><br><span class="hljs-string">  - 在曲面 $S$ 上选择一个小区域 $\Delta S$，当我们通过映射 $\varphi$ 变换这个区域时，$\Delta S$ 被映射到 $S&#x27;</span><span class="hljs-variable">$</span> 上的区域 <span class="hljs-variable">$</span>\varphi(\Delta S)<span class="hljs-variable">$</span>。<br>  - 映射后的区域 <span class="hljs-variable">$</span>\varphi(\Delta S)<span class="hljs-variable">$</span> 在曲面 <span class="hljs-variable">$S</span><span class="hljs-string">&#x27;$ 上的位置和形状都可能发生改变，这种改变通常伴随着拉伸、压缩、旋转等几何变形。</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 2. **度量改变和扭曲程度**</span><br><span class="hljs-string"></span><br><span class="hljs-string">- **度量 $D(\Delta S, \varphi(\Delta S))$**：</span><br><span class="hljs-string">  - 度量 $D$ 用来衡量原始曲面 $S$ 上的区域 $\Delta S$ 在经过映射 $\varphi$ 变换后与输出曲面 $S&#x27;</span><span class="hljs-variable">$</span> 上的区域 <span class="hljs-variable">$</span>\varphi(\Delta S)<span class="hljs-variable">$</span> 之间的几何差异。这个度量可以反映映射过程中区域的拉伸、压缩、扭曲等形变。<br>  - 具体来说，度量 <span class="hljs-variable">$D</span><span class="hljs-variable">$</span> 可以基于雅可比矩阵 <span class="hljs-variable">$</span>\frac&#123;\partial \varphi&#125;&#123;\partial x&#125;<span class="hljs-variable">$</span> 的特征值来定义，这些特征值描述了映射在各个方向上的伸缩情况。<br><br><span class="hljs-comment">### 3. **面积测度与积分**</span><br><br>- **面积测度 <span class="hljs-variable">$</span>\mu<span class="hljs-variable">$</span>**：<br>  - 面积测度 <span class="hljs-variable">$</span>\mu<span class="hljs-variable">$</span> 是一种在曲面上定义的度量，用于计算曲面上的面积。在这个上下文中，<span class="hljs-variable">$</span>\mu(\Delta S)<span class="hljs-variable">$</span> 表示曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 上区域 <span class="hljs-variable">$</span>\Delta S<span class="hljs-variable">$</span> 的面积。<br>  - 例如，在二维欧氏空间中，平面的面积测度就是普通的面积，而在曲面上，面积测度通常依赖于曲面的第一基本形式（度量张量）。<br><br>- **积分表示整体扭曲程度**：<br>  - 在整个曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 上，度量 <span class="hljs-variable">$D</span><span class="hljs-variable">$</span> 的积分 <span class="hljs-variable">$</span>\int_S D(\Delta S, \varphi(\Delta S)) \, d\mu<span class="hljs-variable">$</span> 用来表示映射 <span class="hljs-variable">$</span>\varphi<span class="hljs-variable">$</span> 作用于整个曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 所带来的总的形变或扭曲程度。<br>  - 这里的积分是对曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 上所有区域的度量改变进行累积计算。<br><br><span class="hljs-comment">### 4. **变分问题与最小形变映射**</span><br><br>- **寻找形变最小的映射 <span class="hljs-variable">$</span>\varphi<span class="hljs-variable">$</span>**：<br>  - 我们的目标是找到一个映射 <span class="hljs-variable">$</span>\varphi<span class="hljs-variable">$</span>，使得该映射在整个曲面 <span class="hljs-variable">$S</span><span class="hljs-variable">$</span> 上引起的形变最小化。<br>  - 数学上，这个问题可以表述为一个变分问题，即寻找使得函数 <span class="hljs-variable">$</span>\int_S D(\Delta S, \varphi(\Delta S)) \, d\mu<span class="hljs-variable">$</span> 达到最小值的映射 <span class="hljs-variable">$</span>\varphi<span class="hljs-variable">$</span>：<br>    <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>    \text&#123;arg&#125; \, \min_&#123;\varphi&#125; \int_S D(\Delta S, \varphi(\Delta S)) \, d\mu<br>    <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  - 解决这个变分问题可以通过求解相应的欧拉-拉格朗日方程，得到满足最小形变条件的最优映射。<br><br><span class="hljs-comment">### 5. **应用与实际意义**</span><br><br>- **应用**：<br>  - 这一类问题在几何处理中非常常见，比如图像配准、形状匹配、物体表面变形、最优传输等领域。<br>  - 在物理学中，这种分析也被用于研究材料的变形和应力分布。<br><br>- **实际意义**：<br>  - 寻找最小形变映射的实际意义在于找到一种“最佳”的方式，将一个曲面映射到另一个曲面上，同时尽可能保留原始几何特性。这在保形映射（如里曼映射定理）和等距映射（如在保持距离的情况下进行映射）中具有重要意义。<br><br><br><br><span class="hljs-comment">## 雅可比矩阵</span><br><br>类似于雅可比矩阵的数学工具或概念主要包括以下几种：<br><span class="hljs-number">1</span>. **海森矩阵（Hessian Matrix）**：<br>   - 海森矩阵是多元函数的二阶偏导数组成的方阵，它描述了函数的局部曲率。雅可比矩阵是一阶导数，而海森矩阵则是二阶导数。<br><span class="hljs-number">2</span>. **梯度（Gradient）**：<br>   - 梯度是一个向量，由多元函数的偏导数组成，指向函数增长最快的方向。雅可比矩阵可以看作是多个梯度向量组成的矩阵。<br><span class="hljs-number">3</span>. **散度（Divergence）**：<br>   - 散度是向量微积分中的一个运算，通常用于描述向量场的发散程度。它与雅可比矩阵有关，因为散度可以表示为雅可比矩阵的迹（即对角线元素之和）。<br><span class="hljs-number">4</span>. **旋度（<span class="hljs-built_in">Curl</span>）**：<br>   - 旋度是描述向量场旋转性质的量。在三维空间中，旋度可以通过雅可比矩阵来计算。<br><span class="hljs-number">5</span>. **弗雷歇导数（Fréchet Derivative）**：<br>   - 弗雷歇导数是泛函分析中的一般化导数概念，适用于更广泛的函数空间。雅可比矩阵是弗雷歇导数在欧几里得空间中的特例。<br><span class="hljs-number">6</span>. **推广雅可比矩阵**：<br>   - 在某些情况下，需要考虑非欧几里得空间或非标准映射，这时会使用推广的雅可比矩阵，如辛雅可比矩阵（用于辛几何）。<br><span class="hljs-number">7</span>. **变换矩阵（Transformation Matrices）**：<br>   - 在线性代数和几何中，变换矩阵用于描述线性变换，它们在形式上与雅可比矩阵类似，但应用场景和意义可能不同。<br>   这些概念和工具在数学、物理学、工程学等领域都有着广泛的应用，它们在处理多元函数的微分、积分以及变换等问题时发挥着重要作用。<br><br>这段文字描述了三角形网格上的一个映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 的雅可比矩阵的定义和计算。具体而言，它涉及一个从三角形 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 的顶点到目标空间的映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span>，并讨论了该映射在每个三角形上的雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span> 的构造。<br><br><span class="hljs-comment">### 解释与背景</span><br><br><span class="hljs-comment">#### 1. **三角形面片与映射 $\phi$**</span><br><br>- 设有一个三角形网格，表示为 <span class="hljs-variable">$M</span><span class="hljs-variable">$</span>，它由多个三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 组成。<br>- 每个三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 有三个顶点，记作 <span class="hljs-variable">$</span>\&#123;v_&#123;t,<span class="hljs-number">1</span>&#125;, v_&#123;t,<span class="hljs-number">2</span>&#125;, v_&#123;t,<span class="hljs-number">3</span>&#125;\&#125;<span class="hljs-variable">$</span>。<br>- 我们定义一个从三角形网格 <span class="hljs-variable">$M</span><span class="hljs-variable">$</span> 到目标空间 <span class="hljs-variable">$</span>\mathbb&#123;<span class="hljs-built_in">R</span>&#125;^d<span class="hljs-variable">$</span> 的映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span>。<br><br><span class="hljs-comment">#### 2. **映射 $\phi$ 在三角形面片 $t$ 上的限制**</span><br><br>- 映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上的限制（即 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上的作用）记作 <span class="hljs-variable">$</span>\phi_t<span class="hljs-variable">$</span>，它是一个从三角形 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 到 <span class="hljs-variable">$</span>\mathbb&#123;<span class="hljs-built_in">R</span>&#125;^d<span class="hljs-variable">$</span> 的映射。<br>- <span class="hljs-variable">$</span>\phi_t<span class="hljs-variable">$</span> 是局部的映射，意味着它只在单个三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上定义。<br><br><span class="hljs-comment">#### 3. **雅可比矩阵 $J_t$ 的定义**</span><br><br>- 映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在三角形 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上的雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span> 用来描述 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在该三角形上的局部线性近似。<br>- 给定三角形 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 的顶点坐标 <span class="hljs-variable">$</span>\&#123;(x_&#123;t,<span class="hljs-number">1</span>&#125;, y_&#123;t,<span class="hljs-number">1</span>&#125;), (x_&#123;t,<span class="hljs-number">2</span>&#125;, y_&#123;t,<span class="hljs-number">2</span>&#125;), (x_&#123;t,<span class="hljs-number">3</span>&#125;, y_&#123;t,<span class="hljs-number">3</span>&#125;)\&#125;<span class="hljs-variable">$</span>，以及它们在映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 作用下对应的目标坐标 <span class="hljs-variable">$</span>\&#123;(x<span class="hljs-string">&#x27;_&#123;t,1&#125;, y&#x27;</span>_&#123;t,<span class="hljs-number">1</span>&#125;), (x<span class="hljs-string">&#x27;_&#123;t,2&#125;, y&#x27;</span>_&#123;t,<span class="hljs-number">2</span>&#125;), (x<span class="hljs-string">&#x27;_&#123;t,3&#125;, y&#x27;</span>_&#123;t,<span class="hljs-number">3</span>&#125;)\&#125;<span class="hljs-variable">$</span>，雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span> 表示为：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  J_t =<br>  \begin&#123;bmatrix&#125;<br>  x<span class="hljs-string">&#x27;_&#123;t,2&#125; - x&#x27;</span>_&#123;t,<span class="hljs-number">1</span>&#125; &amp; y<span class="hljs-string">&#x27;_&#123;t,2&#125; - y&#x27;</span>_&#123;t,<span class="hljs-number">1</span>&#125; \\<br>  x<span class="hljs-string">&#x27;_&#123;t,3&#125; - x&#x27;</span>_&#123;t,<span class="hljs-number">1</span>&#125; &amp; y<span class="hljs-string">&#x27;_&#123;t,3&#125; - y&#x27;</span>_&#123;t,<span class="hljs-number">1</span>&#125;<br>  \end&#123;bmatrix&#125;<br>  \cdot<br>  \begin&#123;bmatrix&#125;<br>  x_&#123;t,<span class="hljs-number">2</span>&#125; - x_&#123;t,<span class="hljs-number">1</span>&#125; &amp; y_&#123;t,<span class="hljs-number">2</span>&#125; - y_&#123;t,<span class="hljs-number">1</span>&#125; \\<br>  x_&#123;t,<span class="hljs-number">3</span>&#125; - x_&#123;t,<span class="hljs-number">1</span>&#125; &amp; y_&#123;t,<span class="hljs-number">3</span>&#125; - y_&#123;t,<span class="hljs-number">1</span>&#125;<br>  \end&#123;bmatrix&#125;^&#123;<span class="hljs-literal">-1</span>&#125;<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  <br>  - **左边的矩阵**：表示目标空间中对应顶点坐标差异。<br>  - **右边的矩阵**：表示原始空间中三角形顶点坐标差异，并取其逆矩阵。<br><br><span class="hljs-comment">#### 4. **线性部分的解释**</span><br><br>- 上述雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span> 表示从原始空间的三角形 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 到目标空间中的三角形的线性变换部分。<br>- 它描述了在三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 内映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 的局部几何特性，如缩放、旋转、剪切等。<br><br><span class="hljs-comment">#### 5. **局部标架**</span><br><br>-  <span class="hljs-variable">$</span>\&#123;(x_&#123;t,i&#125;, y_&#123;t,i&#125;)\&#125;_&#123;i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-variable">$</span> 是三角形顶点在原始空间中的局部坐标。<br>-  <span class="hljs-variable">$</span>\&#123;(x<span class="hljs-string">&#x27;_&#123;t,i&#125;, y&#x27;</span>_&#123;t,i&#125;)\&#125;_&#123;i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-variable">$</span> 是映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 作用后这些顶点在目标空间中的局部坐标。<br><br><span class="hljs-comment">### 总结</span><br><br>这段话主要描述了如何通过顶点的局部坐标计算映射 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上的雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span>。该雅可比矩阵捕捉了 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 上的局部线性特性，用于理解和描述 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 的几何变换。<br><br><br><br><span class="hljs-comment">## 相关能量</span><br><br>这段文字讨论了通过雅可比矩阵的奇异值分解来研究和衡量几何映射（如从三角形面片到目标空间的映射）中形变的扭曲能量。以下是对其中关键概念和公式的详细解释。<br><br><span class="hljs-comment">### 1. **雅可比矩阵的奇异值分解 (SVD)**</span><br>- 给定三角形面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 的雅可比矩阵 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span>，可以通过奇异值分解 (Singular Value Decomposition, SVD) 将其分解为三个矩阵的乘积：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  J_t = U_t S_t V_t^T<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  其中：<br>  - <span class="hljs-variable">$U_t</span><span class="hljs-variable">$</span> 和 <span class="hljs-variable">$V_t</span><span class="hljs-variable">$</span> 是正交矩阵（即列向量正交且范数为<span class="hljs-number">1</span>）。<br>  - <span class="hljs-variable">$S_t</span><span class="hljs-variable">$</span> 是一个对角矩阵，其中对角线上的元素为奇异值。<br><br>- 在<span class="hljs-number">2</span>D情况下，<span class="hljs-variable">$S_t</span><span class="hljs-variable">$</span> 可以写作：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  S_t = \begin&#123;bmatrix&#125; \Sigma_t &amp; <span class="hljs-number">0</span> \\ <span class="hljs-number">0</span> &amp; \sigma_t \end&#123;bmatrix&#125;<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  其中 <span class="hljs-variable">$</span>\Sigma_t<span class="hljs-variable">$</span> 和 <span class="hljs-variable">$</span>\sigma_t<span class="hljs-variable">$</span> 是奇异值，对应 <span class="hljs-variable">$J_t</span><span class="hljs-variable">$</span> 的拉伸和压缩变换。<br><br>- 在分解中，要求 <span class="hljs-variable">$</span>\det(U_t V_t^T) &gt; <span class="hljs-number">0</span><span class="hljs-variable">$</span>，这确保了变换是保定向的，即不会发生镜像反转。<br><br><span class="hljs-comment">### 2. **保角能量**</span><br>- **保角能量** 是用来衡量映射在三角形面片上的保角性（conformality）。保角性意味着在局部变换中角度保持不变。<br>- Lévy 等提出的保角能量度量公式是：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  D_&#123;\text&#123;conf&#125;&#125;(\phi_t) = (\Sigma_t - \sigma_t)^<span class="hljs-number">2</span><br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  该能量度量了两个奇异值 <span class="hljs-variable">$</span>\Sigma_t<span class="hljs-variable">$</span> 和 <span class="hljs-variable">$</span>\sigma_t<span class="hljs-variable">$</span> 之间的差异。理想情况下，保角映射要求 <span class="hljs-variable">$</span>\Sigma_t = \sigma_t<span class="hljs-variable">$</span>，使得保角能量 <span class="hljs-variable">$D_</span>&#123;\text&#123;conf&#125;&#125;<span class="hljs-variable">$</span> 最小。<br><br><span class="hljs-comment">### 3. **ARAP 能量（尽可能刚性）**</span><br>- Liu 等和 Zhang 等提出了 **ARAP（As<span class="hljs-literal">-Rigid-As-Possible</span>）能量**，旨在最小化变形的非刚性部分：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  D_&#123;\text&#123;ARAP&#125;&#125;(\phi_t) = (\Sigma_t - <span class="hljs-number">1</span>)^<span class="hljs-number">2</span> + (\sigma_t - <span class="hljs-number">1</span>)^<span class="hljs-number">2</span><br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  该公式表示奇异值 <span class="hljs-variable">$</span>\Sigma_t<span class="hljs-variable">$</span> 和 <span class="hljs-variable">$</span>\sigma_t<span class="hljs-variable">$</span> 偏离<span class="hljs-number">1</span>（即理想刚性变换的奇异值为<span class="hljs-number">1</span>）的程度。ARAP能量在 <span class="hljs-variable">$</span>\Sigma_t = \sigma_t = <span class="hljs-number">1</span><span class="hljs-variable">$</span> 时达到最小值，即映射尽可能地接近刚性变换。<br><br><span class="hljs-comment">### 4. **对称狄利克雷（Symmetric Dirichlet, SD）能量**</span><br>- Schreiner 等和 Smith 等进一步提出了一类等距能量，特别是 **对称狄利克雷能量**：<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  D_&#123;\text&#123;SD&#125;&#125;(\phi_t) = \Sigma_t^<span class="hljs-number">2</span> + \Sigma_t^&#123;<span class="hljs-literal">-2</span>&#125; + \sigma_t^<span class="hljs-number">2</span> + \sigma_t^&#123;<span class="hljs-literal">-2</span>&#125;<br>  <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br>  该能量度量的是在形变中各方向上的等距性。对于刚性变换（<span class="hljs-variable">$</span>\Sigma_t = \sigma_t = <span class="hljs-number">1</span><span class="hljs-variable">$</span>），对称狄利克雷能量达到最小值。<br><br><span class="hljs-comment">### 5. **等距能量的意义**</span><br>- **等距能量** 在刚性变换下取得最小值，这意味着当映射保持距离（即形状和大小）不变时，能量最小。这类能量非常适合用于网格变形中，目标是保持几何形状的刚性不变形。<br><br><br><br>在网格变形中，除了等距能量之外，还有多种其他能量函数用于衡量和控制变形过程中的不同特性。以下是一些常用的能量类型：<br><br><span class="hljs-comment">### 1. **保角能量（Conformal Energy）**</span><br>   - **定义**：保角能量衡量变形过程中的角度保留情况，即变形后局部结构的角度是否与原始网格保持一致。<br>   - **典型公式**：如前面提到的 <span class="hljs-variable">$D_</span>&#123;\text&#123;conf&#125;&#125;(\phi_t) = (\Sigma_t - \sigma_t)^<span class="hljs-number">2</span><span class="hljs-variable">$</span>，其中 <span class="hljs-variable">$</span>\Sigma_t<span class="hljs-variable">$</span> 和 <span class="hljs-variable">$</span>\sigma_t<span class="hljs-variable">$</span> 是奇异值分解中的奇异值。<br>   - **应用**：保角能量在需要保持局部形状特性（如角度）的应用中非常重要，如纹理映射或几何建模。<br><br><span class="hljs-comment">### 2. **面积保留能量（Area Preservation Energy）**</span><br>   - **定义**：面积保留能量衡量变形后网格面片的面积与原始面积之间的差异，目标是保持变形前后的面积一致。<br>   - **典型公式**：<span class="hljs-variable">$D_</span>&#123;\text&#123;area&#125;&#125;(\phi_t) = \left(\frac&#123;\text&#123;Area&#125;(\phi(t))&#125;&#123;\text&#123;Area&#125;(t)&#125; - <span class="hljs-number">1</span>\right)^<span class="hljs-number">2</span><span class="hljs-variable">$</span>，该公式表示变形后面积与原始面积的比值偏离<span class="hljs-number">1</span>的程度。<br>   - **应用**：在地形建模、物理仿真等需要保持局部区域面积不变的情况下使用。<br><br><span class="hljs-comment">### 3. **体积保留能量（Volume Preservation Energy）**</span><br>   - **定义**：对于三维网格，体积保留能量衡量的是变形后每个网格体单元的体积相对于原始体积的变化。<br>   - **典型公式**：<span class="hljs-variable">$D_</span>&#123;\text&#123;volume&#125;&#125;(\phi_t) = \left(\frac&#123;\text&#123;Volume&#125;(\phi(t))&#125;&#123;\text&#123;Volume&#125;(t)&#125; - <span class="hljs-number">1</span>\right)^<span class="hljs-number">2</span><span class="hljs-variable">$</span>，类似于面积保留能量，但应用于三维的体积。<br>   - **应用**：用于需要保持体积不变的三维变形，如模拟不可压缩流体或变形物体的体积保持。<br><br><span class="hljs-comment">### 4. **光滑能量（Smoothness Energy）**</span><br>   - **定义**：光滑能量用于控制网格变形的平滑度，防止产生过于剧烈的形变或不规则的折叠。<br>   - **典型公式**：<span class="hljs-variable">$D_</span>&#123;\text&#123;smooth&#125;&#125;(\phi) = \sum_&#123;i,j&#125; \|\phi(v_i) - \phi(v_j)\|^<span class="hljs-number">2</span><span class="hljs-variable">$</span>，其中 <span class="hljs-variable">$v_i</span><span class="hljs-variable">$</span> 和 <span class="hljs-variable">$v_j</span><span class="hljs-variable">$</span> 是相邻顶点，<span class="hljs-variable">$</span>\phi(v_i)<span class="hljs-variable">$</span> 和 <span class="hljs-variable">$</span>\phi(v_j)<span class="hljs-variable">$</span> 是它们变形后的坐标。<br>   - **应用**：在曲面建模、变形补间（morphing）中使用，确保变形过程中的网格光滑且无不规则折叠。<br><br><span class="hljs-comment">### 5. **弹性能量（Elastic Energy）**</span><br>   - **定义**：弹性能量源自材料力学，用于衡量在变形过程中网格的弹性响应，通常与应力和应变的关系有关。<br>   - **典型公式**：<span class="hljs-variable">$D_</span>&#123;\text&#123;elastic&#125;&#125;(\phi) = \sum_&#123;t&#125; \text&#123;Strain&#125;(\phi_t)<span class="hljs-variable">$</span>，其中 <span class="hljs-variable">$</span>\text&#123;Strain&#125;<span class="hljs-variable">$</span> 是描述应变的度量。<br>   - **应用**：用于模拟物体的弹性变形，如在计算机动画中模拟橡皮筋或其他弹性材料。<br><br><span class="hljs-comment">### 6. **刚性能量（Rigidity Energy）**</span><br>   - **定义**：刚性能量衡量网格变形中与刚性变换（平移、旋转、缩放）之间的偏差。<br>   - **典型公式**：ARAP能量（As<span class="hljs-literal">-Rigid-As-Possible</span> Energy）就是刚性能量的一个例子。<br>   - **应用**：在需要保持物体整体形状刚性的应用中，如仿真刚性物体的运动。<br><br><span class="hljs-comment">### 7. **折叠避免能量（Fold Avoidance Energy）**</span><br>   - **定义**：这种能量用于防止网格在变形过程中发生自相交或折叠。<br>   - **典型公式**：通常设计为一种惩罚函数，当网格发生自相交或折叠时增加能量。<br>   - **应用**：在表面重建、物理仿真中使用，确保变形结果物理上可行且无折叠。<br><br><span class="hljs-comment">### 8. **拉普拉斯能量（Laplacian Energy）**</span><br>   - **定义**：拉普拉斯能量基于离散拉普拉斯算子，用于控制网格形变的平滑度，保持顶点之间的相对关系。<br>   - **典型公式**：<span class="hljs-variable">$D_</span>&#123;\text&#123;laplacian&#125;&#125;(\phi) = \sum_&#123;i&#125; \|\Delta \phi(v_i)\|^<span class="hljs-number">2</span><span class="hljs-variable">$</span>，其中 <span class="hljs-variable">$</span>\Delta<span class="hljs-variable">$</span> 是离散拉普拉斯算子。<br>   - **应用**：常用于几何处理中的网格平滑与形变控制。<br><br>这些能量类型在网格变形中有广泛的应用，针对不同的变形需求，设计适当的能量函数能够有效控制和优化变形结果，使其符合预期的物理或几何特性。<br><br><br><br><span class="hljs-comment"># 能量平衡</span><br><br><span class="hljs-comment">### 1. 离散化积分表示</span><br>原式（<span class="hljs-number">1</span>）的积分形式是：<br><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span> E_d(\phi) = \int_M D(\phi) \, dA <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><br>在实际计算中，离散网格 <span class="hljs-variable">$M</span><span class="hljs-variable">$</span> 上的积分通常会被转换为求和的形式，因为离散网格 <span class="hljs-variable">$M</span><span class="hljs-variable">$</span> 由一系列小的面片（例如三角形面片）组成。每个面片的面积对整体积分都有贡献。因此，我们可以将这个积分离散化，得到一个求和形式：<br><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span> E_d(\phi) = \sum_&#123;t \in T&#125; w_t D(\phi(t)) <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><br>其中：<br>- <span class="hljs-variable">$T</span><span class="hljs-variable">$</span> 是网格中的面片集合。<br>- <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 表示一个单独的面片。<br>- <span class="hljs-variable">$w_t</span><span class="hljs-variable">$</span> 是面片 <span class="hljs-variable">$t</span><span class="hljs-variable">$</span> 对应的权重，通常是该面片的面积 <span class="hljs-variable">$A_t</span><span class="hljs-variable">$</span>。<br>- <span class="hljs-variable">$D</span>(\phi(t))<span class="hljs-variable">$</span> 是在该面片上形变 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 引起的能量密度。<br><br>从几何意义上来说，权重 <span class="hljs-variable">$w_t</span><span class="hljs-variable">$</span> 表示的是面片的几何重要性，在三角形网格中通常取为面片的面积 <span class="hljs-variable">$A_t</span><span class="hljs-variable">$</span>，因为面积越大的面片对总能量的贡献越大。<br><br>因此，离散形式为：<br><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span> E_d(\phi) = \sum_&#123;t \in T&#125; A_t D(\phi(t)) <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><br><span class="hljs-comment">### 2. 点对点（P2P）约束能量</span><br>在网格变形中，通常需要施加一些约束，特别是控制点的约束。控制点的约束可以通过点对点（P2P）能量的形式引入。<br><br>定义一个控制点集 <span class="hljs-variable">$V_c</span><span class="hljs-variable">$</span>，该集包含网格中被强制固定或约束的顶点。这些顶点的目标是移动到给定的约束位置 <span class="hljs-variable">$c_v</span><span class="hljs-variable">$</span>，即约束控制点的位置。<br><br>点对点（P2P）能量定义为：<br><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span> E_&#123;P2P&#125;(\phi) = \sum_&#123;v \in V_c&#125; \|\phi(x_v) - c_v\|^<span class="hljs-number">2</span> <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><br>其中：<br>- <span class="hljs-variable">$v</span><span class="hljs-variable">$</span> 是网格中的一个顶点。<br>- <span class="hljs-variable">$x_v</span><span class="hljs-variable">$</span> 是顶点 <span class="hljs-variable">$v</span><span class="hljs-variable">$</span> 的坐标。<br>- <span class="hljs-variable">$</span>\phi(x_v)<span class="hljs-variable">$</span> 是变形函数 <span class="hljs-variable">$</span>\phi<span class="hljs-variable">$</span> 在该顶点 <span class="hljs-variable">$v</span><span class="hljs-variable">$</span> 处的变形结果。<br>- <span class="hljs-variable">$c_v</span><span class="hljs-variable">$</span> 是顶点 <span class="hljs-variable">$v</span><span class="hljs-variable">$</span> 的目标位置或约束位置。<br><br>该能量表示的是顶点 <span class="hljs-variable">$v</span><span class="hljs-variable">$</span> 处的变形与其目标位置之间的误差平方和。通过最小化这个误差，可以保证网格变形时，控制点尽可能接近其指定的位置。<br><br><span class="hljs-comment">### 3. 结合面片能量与点约束的优化</span><br>将面片的能量 <span class="hljs-variable">$E_d</span>(\phi)<span class="hljs-variable">$</span> 和点对点的约束能量 <span class="hljs-variable">$E_</span>&#123;P2P&#125;(\phi)<span class="hljs-variable">$</span> 结合起来，可以构建一个带约束的优化问题。这通常是一个非线性优化问题，但是可以通过引入拉格朗日乘子或其他技巧，将其转化为相对容易求解的无约束优化问题。<br><br>这样做的好处是可以在保证整体变形能量（例如光滑度、等距性等）的同时，严格控制关键点的位置，使其满足实际需求。这种结合方式在几何建模和动画中非常常见。<br><br><span class="hljs-comment">### 总结</span><br>- **离散形式**：将连续的积分形式转化为离散的求和，面片的面积作为权重 <span class="hljs-variable">$w_t</span><span class="hljs-variable">$</span>，使得总能量 <span class="hljs-variable">$E_d</span>(\phi)<span class="hljs-variable">$</span> 是面片能量密度的加权和。<br>- **点对点约束能量**：通过最小化顶点与其控制点位置之间的误差平方和，确保变形过程中控制点能被很好地约束。<br>- **带约束优化问题**：通过结合面片能量和点对点约束能量，将带约束的问题转化为易于求解的无约束优化问题。<br><br>**Laplacian Surface Editing**<br><br>编辑操作可以在粗略的层次上进行，这样修改的形状是通过在它们的局部坐标系中<span class="hljs-string">&quot;添加&quot;</span>位移来计算的。编辑操作可以在粗略的层次上进行，这样修改的形状是通过在它们的局部坐标系中<span class="hljs-string">&quot;添加&quot;</span>位移来计算的。<br><br>使用的编辑交互框架类似于[ <span class="hljs-type">LSCO</span>-<span class="hljs-number">04</span> ]中描述的编辑交互框架，它由以下几个阶段组成：首先，用户定义用于编辑的感兴趣区域( ROI )。ROI由其边界边缘的闭合简单环定义。接下来，对ROI内部的句柄进行定义。 此外，用户可以通过固定锚点来任意定义ROI的<span class="hljs-string">&quot;填充&quot;</span>量。这些固定的锚点形成一个带，支持ROI和网格未接触部分之间的过渡。然后，用户操作手柄，相对于手柄的重定位进行曲面重构。<br><br><br><br><span class="hljs-comment"># 贝塞尔</span><br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20241107141324513</span>](论文研读笔记/image<span class="hljs-literal">-20241107141324513</span>.png)<br><br><br><br>```c<span class="hljs-comment">#</span><br><br>public Vector3 Tangent(float t, Knot k)<br>&#123;<br>Vector3 vel;<br><br>float a = t;<br>float b = <span class="hljs-number">1.0</span>f - t;<br><br>float b2 = b * b;<br>float a2 = a * a;<br><br>vel.x = (<span class="hljs-literal">-3</span>.<span class="hljs-number">0</span>f * p.x * b2) + (<span class="hljs-number">3.0</span>f * outvec.x * b * (b - <span class="hljs-number">2.0</span>f * a)) + (<span class="hljs-number">3.0</span>f * k.invec.x * a * (<span class="hljs-number">2.0</span>f * b - a)) + (k.p.x * <span class="hljs-number">3.0</span>f * a2);<br>vel.y = (<span class="hljs-literal">-3</span>.<span class="hljs-number">0</span>f * p.y * b2) + (<span class="hljs-number">3.0</span>f * outvec.y * b * (b - <span class="hljs-number">2.0</span>f * a)) + (<span class="hljs-number">3.0</span>f * k.invec.y * a * (<span class="hljs-number">2.0</span>f * b - a)) + (k.p.y * <span class="hljs-number">3.0</span>f * a2);<br>vel.z = (<span class="hljs-literal">-3</span>.<span class="hljs-number">0</span>f * p.z * b2) + (<span class="hljs-number">3.0</span>f * outvec.z * b * (b - <span class="hljs-number">2.0</span>f * a)) + (<span class="hljs-number">3.0</span>f * k.invec.z * a * (<span class="hljs-number">2.0</span>f * b - a)) + (k.p.z * <span class="hljs-number">3.0</span>f * a2);<br><br>//float d = vel.sqrMagnitude;<br><br><span class="hljs-keyword">return</span> vel;<br>&#125;<br></code></pre></td></tr></table></figure>这段代码实现了三次贝塞尔曲线的切线计算，但是它并不是标准的贝塞尔曲线公式，而是基于贝塞尔曲线的控制点（包括两个控制点和两个切线）进行的改进。### 三次贝塞尔曲线的标准公式对于标准的三次贝塞尔曲线，给定四个控制点：$P_0, P_1, P_2, P_3$，贝塞尔曲线的参数化方程为：</script><p>B(t) = (1 - t)^3 P_0 + 3(1 - t)^2 t P_1 + 3(1 - t) t^2 P_2 + t^3 P_3</p><script type="math/tex; mode=display">该曲线在 $t = 0$ 时位于 $P_0$，在 $t = 1$ 时位于 $P_3$，而 $P_1$ 和 $P_2$ 是控制点，用来调整曲线的形状。### 切线（Tangent）计算贝塞尔曲线的切线可以通过对贝塞尔曲线方程对 $t$ 求导来获得。对上述方程进行求导，得到三次贝塞尔曲线的切线公式：</script><p>T’(t) = -3(1 - t)^2 P_0 + 3(1 - t)^2 P_1 - 6t(1 - t) P_1 + 6t(1 - t) P_2 - 3t^2 P_2 + 3t^2 P_3</p><p>$$</p><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><p>在这段代码中，<code>Tangent</code> 函数计算的是贝塞尔曲线的切线，考虑了四个控制点 $p$、$outvec$、$k.invec$ 和 $k.p$，它们分别是起始点、起始点的切线、结束点的切线和结束点。可以看出，它实际上并不是单纯的三次贝塞尔曲线，而是修改过的版本。</p><h4 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h4><ul><li><code>t</code>: 曲线上的参数值，范围通常是 [0, 1]。</li><li><code>MegaKnot k</code>: 代表某个节点的对象，其中 <code>k.invec</code> 是该节点的输入切线，<code>k.p</code> 是该节点的控制点。</li><li><code>p</code>, <code>outvec</code>: 对应曲线上的起始点和起始点的切线。</li></ul><p>计算每个维度（x, y, z）的切线：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">vel.x = (<span class="hljs-number">-3.0f</span> * p.x * b2) + (<span class="hljs-number">3.0f</span> * outvec.x * b * (b - <span class="hljs-number">2.0f</span> * a)) + (<span class="hljs-number">3.0f</span> * k.invec.x * a * (<span class="hljs-number">2.0f</span> * b - a)) + (k.p.x * <span class="hljs-number">3.0f</span> * a2);<br>vel.y = (<span class="hljs-number">-3.0f</span> * p.y * b2) + (<span class="hljs-number">3.0f</span> * outvec.y * b * (b - <span class="hljs-number">2.0f</span> * a)) + (<span class="hljs-number">3.0f</span> * k.invec.y * a * (<span class="hljs-number">2.0f</span> * b - a)) + (k.p.y * <span class="hljs-number">3.0f</span> * a2);<br>vel.z = (<span class="hljs-number">-3.0f</span> * p.z * b2) + (<span class="hljs-number">3.0f</span> * outvec.z * b * (b - <span class="hljs-number">2.0f</span> * a)) + (<span class="hljs-number">3.0f</span> * k.invec.z * a * (<span class="hljs-number">2.0f</span> * b - a)) + (k.p.z * <span class="hljs-number">3.0f</span> * a2);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>p</code>: 当前节点的起始点位置。</li><li><code>outvec</code>: 当前节点的出发切线（控制点的切线）。</li><li><code>k.invec</code>: 下一节点的入射切线。</li><li><code>k.p</code>: 下一节点的控制点。</li></ul><h3 id="这段代码与标准三次贝塞尔曲线的区别"><a href="#这段代码与标准三次贝塞尔曲线的区别" class="headerlink" title="这段代码与标准三次贝塞尔曲线的区别"></a>这段代码与标准三次贝塞尔曲线的区别</h3><ol><li><p><strong>切线使用控制点和切线</strong>：标准三次贝塞尔曲线的切线是通过控制点的组合来求得的，而这段代码在计算切线时，除了控制点，还考虑了切线（<code>outvec</code> 和 <code>invec</code>）。这种做法是改进版，称为<strong>带切线的贝塞尔曲线</strong>（通常用于类似于 Catmull-Rom 或其他插值曲线算法）。</p></li><li><p><strong>参数化形式</strong>：标准的三次贝塞尔曲线使用四个控制点，而这段代码使用了类似四个控制点，但也包括切线作为控制，这让曲线在经过两个节点时更加平滑和自然。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码计算的是一个改进版的三次贝塞尔曲线的切线，考虑了控制点和切线的信息。标准三次贝塞尔曲线只依赖于四个控制点，而改进的算法将控制点的切线（<code>outvec</code> 和 <code>invec</code>）也纳入了计算，提供了更大的灵活性，通常用于需要精细控制曲线形状的应用场景。这种类型的曲线被广泛应用于动画、路径插值和曲线编辑中。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p>半监督学习：监督学习和无监督学习</p><p>监督学习：数据有标签、一般为回归或分类</p><p>无监督学习：数据无标签、一般为聚类或若干降维任务</p><p>强化学习：序列数据决策学习、一般为从环境交互中学习</p><p>在无监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些<br>内在结构;</p><p>在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果</p><p>常见的应用场景包括关联规则的学习以及聚类等。常见算法包括Apriori算法和k-Means算法</p><p>半监督学习是介于监督学习与无监督学习之间一种机器学习方式，主要考虑如可利用<strong>少量的标注样本</strong>和<strong>大量的未标注样本</strong>进行训练和分类的问题;</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p><strong>中值是奇数个中间的值或者偶数个中间两个数的平均值。</strong></p><p>已知一组价格数据：15,21,24,21,25,4,8,34,28<br>现用等深（深度为3）分箱方法对其进行平滑，以对数据中的噪声进行处理。</p><p>首先进行排序：</p><p>排序后价格:4，8，15，21，21，24 ，25，28，34</p><p>划分为等高度：</p><p>Bin1：4，8，15</p><p>Bin2：21，21，24</p><p>Bin3：25，28，34</p><p>根据Bin均值进行平滑</p><p>Bin1：9，9，9</p><p>Bin2：22，22，22</p><p>Bin3：29，29，29</p><p>根据Bin边界进行平滑</p><p>Bin1：4，4，15</p><p>Bin2：21，21，24</p><p>Bin3：25，25，34</p><p>根据Bin中值进行平滑</p><p>Bin1：8，8，8</p><p>Bin2：21，21，21</p><p>Bin3：28，28，28</p><p>已知一组价格数据:15,21,24,21,25,4,8,34,28现用等宽(宽度为10)分箱方法对其进行平滑，以对数据中的噪声进行处理。</p><p><strong>由于数据范围是从最小值4到最大值34，数据范围的总宽度是34 - 4 = 30。要分为3个等宽的区间，每个区间的宽度将是30 / 3 = 10。即要求箱中数据之差不能超过10</strong></p><ul><li>第一个区间：4 - 13（包括头尾）</li><li>第二个区间：15 - 24（包括头尾）</li><li>第三个区间：28 - 37（包括头尾）</li></ul><p>结果:<br>先排序:4，8，15，21，21，24，25，28，34</p><p>划分为等宽度箱子</p><p>Bin1：4，8</p><p>Bin2：15，21，21，24，25</p><p>Bin3：28，34</p><p>根据Bin均值进行平滑</p><p>Bin1：6，6</p><p>Bin2：21，21，21，21，21</p><p>Bin3：31，31</p><p>根据Bin边界进行平滑</p><p>Bin1：4，8</p><p>Bin2：15，25，25，25，25</p><p>Bin3：28，34</p><p>根据Bin中值进行平滑</p><p>Bin1：6，6</p><p>Bin2：21，21，21，21，21</p><p>Bin3：31，31</p><p><strong>ppt第二章p28</strong></p><p><strong>纯度</strong></p><p>可以通过以下公式计算：</p><script type="math/tex; mode=display">P = \frac{\text{多数类别的实例数}}{\text{总实例数}}</script><p>数据规范化：将数据按比例进行缩放，使之落入一个特定的区域，以消除数值型属性因大小不一而造成的挖掘结果的偏差</p><p>最小-最大规范化</p><p>零-均值规范化（z-score规范化）</p><p>小数定标规范化</p><p><strong>最小—最大规范化</strong>：假定minA和maxA分别为属性A的最小和最大值，则通过下面公式将A的值映射到区间[new_min, new_max]中的v’：</p><script type="math/tex; mode=display">v' = \frac{(v - \min_A) \times (\text{new\_max} - \text{new\_min})}{(\max_A - \min_A)} + \text{new\_min}</script><p>例：假定属性income的最小与最大值分别为$12000和$98000，可根据最小—最大规范化方法将其范围映射到[0,1]：<br>如：属性值$73600将变换为：</p><script type="math/tex; mode=display">v' = \frac{(73600 - 12000) \times (1 - 0)}{98000 - 12000} + \text{0}=0.716</script><p><strong>零-均值规范化（z-score规范化）</strong></p><script type="math/tex; mode=display">𝑣′=\frac{𝑣−𝑚𝑒𝑎𝑛𝐴}{standard_− 𝑑𝑒𝑣𝐴}</script><p>其中，meanA、standard-devA分别为属性A取值的均值和标准差</p><p>例：假定属性income的平均值与标准差分别为$54000和$16000，使用z-score规范化，则属性值$73600将变换为：</p><script type="math/tex; mode=display">𝑣′=\frac{73600−54000}{16000}=1.225</script><p><strong>小数定标规范化</strong></p><script type="math/tex; mode=display">𝑣′=\frac𝑣{10^𝑗 }</script><p>其中，j是使 Max(|  v’ |)&lt;1的最小整数</p><p><strong>例：</strong>假定A的取值范围[-986, 917]，则A的最大绝对值为986，为使用小数定标规范化，用1000（即j=3）除每个值，这样-986被规范化为-0.986。</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416112557044.png" alt="image-20240416112557044"></p><h2 id="信息增益ID3"><a href="#信息增益ID3" class="headerlink" title="信息增益ID3"></a>信息增益ID3</h2><p>选择具有最高信息增益的属性作为分裂属性</p><p>假设有两个类,P和N </p><p>让样本集S包含类P的p个元素以及类N的n个元素</p><p>识别S中一个样本是否属于P或N所需要的平均信息量为</p><script type="math/tex; mode=display">I(p, n) = -\frac{p}{p + n} \log_2\left(\frac{p}{p + n}\right) - \frac{n}{p + n} \log_2\left(\frac{n}{p + n}\right)</script><p>对于离散随机变量 ，其熵定义同下</p><p>当熵公式推广到多个类别时，其形式保持不变，只是需要对所有可能的类别进行求和。对于离散随机变量 X，如果它有 k 个不同的取值 x1,x2,…,xk，每个取值的概率分别为 p(x1),p(x2),…,p(xk)，那么熵 H(X) 的公式为</p><script type="math/tex; mode=display">E(X) = -\sum_{i=1}^{k} p(x_i) \log_2 p(x_i)</script><script type="math/tex; mode=display">信息增益：Gain(A)=I(p,n)-E(A)</script><p>例如总共有14个样本，最终结果9是，5否，带入上面公式</p><script type="math/tex; mode=display">I(9, 5) = -\frac{9}{14} \log_2\left(\frac{9}{14}\right) - \frac{5}{14} \log_2\left(\frac{5}{14}\right)=0.940</script><hr><p><strong>例题</strong></p><p>请按照ID3决策树分类算法，采用信息增益作为节点的选择指标，筛选出基于以下训练数据所生成的决策树的根节点，请详细写出计算步骤。</p><div class="table-container"><table><thead><tr><th style="text-align:center">不浮出水面是否可以生存</th><th style="text-align:center">是否有脚璞</th><th style="text-align:center">属于鱼类</th></tr></thead><tbody><tr><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr></tbody></table></div><ol><li>计算未分类前的熵,总共有5个样本，是2个,否3个</li></ol><script type="math/tex; mode=display">熵(总)=I(2,3) = -\frac{2}{5} \log_2\left(\frac{2}{5}\right) - \frac{3}{5} \log_2\left(\frac{3}{5}\right)=0.971</script><ol><li>分别计算按不浮出水面是否可以生存和是否有脚蹊进行分类后的信息嫡。</li></ol><p>先按不浮出水面是否可以生存进行分类：是中有2是1否；否中有0是2否</p><script type="math/tex; mode=display">熵(是否可以生存_是)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28</script><script type="math/tex; mode=display">熵(是否可以生存_否)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28</script><script type="math/tex; mode=display">E=熵(是否可以生存)=\frac{3}{5}*0.28+\frac{2}{5}*0=0.17</script><script type="math/tex; mode=display">信息增益=熵(总)-熵(是否可以生存)=0.971-0.17=0.801</script><ol><li>是否有脚蹊进行分类：是中2是2否；否中有0是1否</li></ol><script type="math/tex; mode=display">熵(是否可以生存_是)=I(2,2) = -\frac{2}{4} \log_2\left(\frac{2}{4}\right) - \frac{2}{4} \log_2\left(\frac{2}{4}\right)=1</script><script type="math/tex; mode=display">熵(是否可以生存_否)=I(0,1) = -\frac{0}{1} \log_2\left(\frac{0}{1}\right) - \frac{1}{1} \log_2\left(\frac{1}{1}\right)=0</script><script type="math/tex; mode=display">熵(是否可以生存)=\frac{4}{5}*1+\frac{1}{5}*0=0.8</script><script type="math/tex; mode=display">信息增益=熵(总)-熵(是否可以生存)=0.971-0.8=0.171</script><p><strong>信息增益更大，区分样本的能力更强</strong>，更具有代表性,故根节点为”不浮出水面是否可以生存”</p><p><strong>基尼指标Gini指标</strong></p><p>( G ) 是基尼指数，( p_i ) 是第 ( i ) 个类别的样本占比，( n ) 是类别的总数</p><p>类似于信息增益，Gini指标越小，则为最优特征，指数越大，样本不确定性就越大</p><script type="math/tex; mode=display">G = 1 - \sum_{i=1}^{n} p_i^2</script><p>在特征A条件下，集合D的基尼指数</p><script type="math/tex; mode=display">G(D|A) = \sum_{j=1}^{k} \frac{|D_j|}{|D|} G(D_j)</script><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416140851945.png" alt="image-20240416140851945"></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>避免过分拟合的两种方法</p><ul><li>先剪枝: 通过提前停止树的构造而对树剪枝<br>很难选取一个合适的阈值</li><li>后剪枝: 由完全生成的树剪去子树.通过删除节点的分枝并用树叶替换它而剪掉给定节点的子树.树叶用被替换的子树中最频繁的类标记</li></ul><p><strong>CART使用的代价复杂度剪枝算法</strong></p><p>使用Gini系数，求得权重</p><p>在特征A条件下，集合D的基尼指数</p><p><a href="https://blog.csdn.net/weixin_45116749/article/details/129261511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%86%B3%E7%AD%96%E6%A0%91cart%E8%AE%A1%E7%AE%97%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-129261511.142^v100^pc_search_result_base4&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45116749/article/details/129261511?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%86%B3%E7%AD%96%E6%A0%91cart%E8%AE%A1%E7%AE%97%E9%A2%98&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-129261511.142^v100^pc_search_result_base4&amp;spm=1018.2226.3001.4187</a></p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>贝叶斯定理公式</p><p>朴素的概念：假设样本特征彼此独立，没有相关关系。而这在现实中不存在，但用这个方法来分类效果很好</p><p>P(B) </p><ul><li>表示在没有训练数据前假设A拥有的初始概率。P(A)被称为A的先验概率.</li></ul><p>P(B|A) </p><ul><li>P(A|B)表示假设B成立时A的概率</li><li>机器学习中我们关心的是P(B|A)，即给定A时B的成立的概率，称为B的后验概率</li></ul><script type="math/tex; mode=display">P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}</script><p>因此P(B|A)如下</p><script type="math/tex; mode=display">P(B|A) = \frac{P(A|B) \cdot P(B)}{P(A)}</script><p>​    P(B|A)随着P(B)和P(A|B)的增长而增长，随着P(A)的增长而减少，即如果A独立于B时被观察到的可能性越大，那么B对A的支持度越小.</p><p>贝叶斯全概率公式</p><script type="math/tex; mode=display">P(A) = \sum_{i=1}^{n} P(A|B_i) \cdot P(B_i)</script><p>例题</p><p> <img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416194507458.png" alt="image-20240416194507458"></p><p>求出所有概率最后相乘，选择更大的</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416194539654.png" alt=" "></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416194554820.png" alt="image-20240416194554820"></p><p>例题</p><p>用公式展开，并使用全概率公式将分母展开</p><p>给出P(R)=0.4    P(W|R)=0.9    P(W|~R)=0.2    P(~R)=0.6</p><script type="math/tex; mode=display">\begin{aligned}P(R|W)&=\frac{P(W|R)P(R)}{P(W)} \\&=\frac{P(W|R)P(R)}{P(W|R)P(R)+P(W|\neg R)P(\neg R)}\\&=\frac{0.9\times0.4}{0.9\times0.4+0.2\times0.6}=0.75\end{aligned}</script><p>例题公式推导</p><script type="math/tex; mode=display">P(W|S) = \frac{P(W \cap S)}{P(S)}</script><script type="math/tex; mode=display">P(W \cap S) = P((W \cap S) \cap R) + P((W \cap S) \cap \sim R)</script><p>由于下面</p><script type="math/tex; mode=display">P(A \mid B) = \frac{P(A \cap B)}{P(B)}</script><p>因此得到</p><script type="math/tex; mode=display">P(W \cap S) = P(W \mid R,S) \cdot P(R \mid S) + P(W \mid \sim R,S) \cdot P(\sim R \mid S)</script><p>所以</p><script type="math/tex; mode=display">P(W \cap S) = P(W \mid R,S) \cdot P(R ) + P(W \mid \sim R,S) \cdot P(\sim R)</script><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240416205205173.png" alt="image-20240416205205173"></p><h2 id="分类器验证方法"><a href="#分类器验证方法" class="headerlink" title="分类器验证方法"></a>分类器验证方法</h2><p>交叉验证</p><ul><li>CV是用来验证分类器的性能一种统计分析方法，将原始数据(dataset)进行分组,一部分做为训练集(train set)，另一部分做为验证集(validation set),首先用训练集对分类器进行训练,再利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标</li></ul><p>K-折交叉验证</p><ul><li>将原始数据分成K组(一般是均分)，将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标</li><li>K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性</li></ul><p>留一验证LOO-CV</p><ul><li><p>如果设原始数据有N个样本,那么LOO-CV就是N-CV,即 每个样本单独作为验证集,其余的N-1个样本作为训练集,所以LOO-CV会得到N个模型,用这N个模型最终的验证集的分类准确率的平均数作为此下LOO-CV分类器的性能指标</p></li><li><p>相比于前面的K-CV,LOO-CV有两个明显的优点: ①a.每一回合中几乎所有的样本皆用于训练模型,因此最接近原始样本的分布,这样评估所得的结果比较可靠。 ②b.实验过程中没有随机因素会影响实验数据,确保实验过程是可以被复制的</p></li><li><p>LOO-CV的缺点则是计算成本高,因为需要建立的模型数量与原始数据样本数量相同,当原始数据样本数量相当多时,LOO-CV在实作上几乎就是不现实的,除非每次训练分类器得到模型的速度很快,或是可以用并行化计算减少计算所需的时间. </p></li></ul><h2 id="分类器性能评价"><a href="#分类器性能评价" class="headerlink" title="分类器性能评价"></a>分类器性能评价</h2><p>主对角线：被正确分类的正例个数(TP个)和    被正确分类的负例个数(TN个)</p><p>副对角线：被错误分类的正例个数(FP个)和    被错误分类的负例个数(FN个)</p><div class="table-container"><table><thead><tr><th></th><th>预测正例</th><th>预测负例</th></tr></thead><tbody><tr><td>实际正例</td><td>TP (真正例)PP</td><td>FN (假反例)PN</td></tr><tr><td>实际负例</td><td>FP (假正例)NP</td><td>TN (真反例)NN</td></tr></tbody></table></div><ul><li><p>准确率：总样本预测对了个数</p><script type="math/tex; mode=display">\text{Accuracy} = \frac{\text{TP} + \text{TN}}{\text{TP} + \text{TN} + \text{FP} + \text{FN}}</script></li><li><p>查准率(Precision)：也叫<strong>精确率</strong>，预测为正的中实际为正的有多少。（正确分类的正例个数占分类为正例的实例个数的比例）</p></li></ul><script type="math/tex; mode=display">\text{Precision} = \frac{\text{TP}}{\text{TP} + \text{FP}}</script><ul><li>查全率(Recall)：也叫<strong>召回率</strong>，在所有实际为正例的样本中，正确分类的正例个数占实际正例个数的比例。</li></ul><script type="math/tex; mode=display">\text{Recall} = \frac{\text{TP}}{\text{TP} + \text{FN}}</script><ul><li>F1值：查全率与查询率的调和平均数</li></ul><script type="math/tex; mode=display">F1 = 2 \times \frac{P \times R}{P + R}</script><ul><li>误分率<script type="math/tex; mode=display">\text{误分率} = \frac{\text{FP} + \text{FN}}{\text{TP} + \text{TN} + \text{FP} + \text{FN}}</script></li></ul><p><strong>ROC</strong></p><p>ROC图形，根据混合矩阵，定义两个概念：</p><p>错误的正例率(False Positive Rate,FPR)=FP/N=错误预测为正/原本为负</p><p>正确的正例率(True Positive Rate.TPR)=TP/P=正确预测为正/原本为正</p><p>ROC图形是一个二维图形，横轴为<strong>FPR</strong>，纵轴为TPR，直观的展示FPR与TPR之间的对应关系</p><p>FPR</p><script type="math/tex; mode=display">\text{FPR} = \frac{\text{FP}}{\text{FP} + \text{TN}}</script><p>TPR</p><script type="math/tex; mode=display">\text{TPR} = \frac{\text{TP}}{\text{TP} + \text{FN}}</script><p><strong>AUC</strong></p><p>ROC曲线下的面积，是一个具体数值，数值越大，模型越好</p><ul><li>AUC =1，是完美的分类器，该模型至少存在一个值，可以将正负样本完美的划分开</li><li>0.5&lt;AUC&lt;1，优于随机猜测，数值越大，分类器越好</li><li>AUC=0.5，相当于随机猜测，模型没有预测价值</li><li>AUC&lt;0.5，比随机猜测要差，然而若反向预测，该模型也可优于随机猜测</li></ul><p><strong>预测概率和阈值</strong></p><p>模型预测概率大于阈值判定为正，反之为负</p><p>例题</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240417151554970.png" alt="image-20240417151554970"></p><p>混淆矩阵画法</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240417140040656.png" alt="image-20240417140040656"></p><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul><li>无监督的分类</li><li>不要训练集合</li><li>聚类算法会将数据集中的样本划分成为若干个通常不相交的子集，每一个子集我们称之为“簇”。</li><li>在聚类过程自动形成簇结构后,我们会发现每个簇里会存在一些潜在的概念，比如“黄种人”、“白种人”，“女性”、“男性”，这些是我们事先未知的，这些概念也是由使用者来把握和命名的。</li></ul><h2 id="k均值聚类算法"><a href="#k均值聚类算法" class="headerlink" title="k均值聚类算法"></a>k均值聚类算法</h2><p>k-means：k均值聚类算法,其中每个簇都用该簇中对象的均值来表示  </p><p>k-medoids：k中心点聚类算法，其中每个簇用接近簇中心的一个对象来表示</p><p>CLARANS：大型数据库中的划分聚类算法</p><p>步骤</p><ul><li><p>先定义总共有多少个类/簇(cluster)</p></li><li><p>将每个簇心(cluster centers)随机定在一个点上将每个数据点关联到最近簇中心所属的簇上</p></li><li>对于每一个簇找到其所有关联点的中心点(取每一个点坐标的平均值)</li><li>将上述点变为新的簇心</li><li>不停重复，直到每个簇所拥有的点不变</li></ul><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240417162108117.png" alt="image-20240417162108117"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240417162122926.png" alt="image-20240417162122926"></p><p>例题</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240417164313560.png" alt="image-20240417164313560"></p><p>k均值优点</p><ul><li>聚类时间快</li></ul><p>缺点</p><ul><li>用户必须事先指定聚类簇的个数</li><li>常常终止于局部最优</li><li>只适用于数值属性聚类(计算均值有意义)</li><li>对噪声和异常数据也很敏感</li><li>不同的初始值，结果可能不同</li><li>不适合发现非凸面形状的簇</li></ul><p>k-means利用簇内点的均值或加权平均值ci（质心）作为类Ci的代表点。对数值属性数据有较好的几何和统计意义。对孤立点是敏感的，如果具有极大值，就可能大幅度地扭曲数据的分布</p><p>k-medoids(k-中心点)算法是为消除这种敏感性提出的，它选择类中位置最接近类中心的对象(称为中心点)作为类的代表点，目标函数仍然可以采用平方误差准则</p><p>PAM（Partitioning Around Medoids，围绕中心点的划分）是最早提出的k中心点算法之一</p><p>当使用 k-medoids 算法进行聚类时，以下是完整的步骤：</p><div class="table-container"><table><thead><tr><th></th><th>k均值</th><th>k中心点</th></tr></thead><tbody><tr><td>初始化</td><td>从数据集中随机选择 k 个点作为初始的聚类中心</td><td>same</td></tr><tr><td>分配数据点到最近的聚类中心</td><td>计算它与每个聚类中心之间的距离（通常使用欧氏距离），将该点分配给距离最近的聚类中心所在的簇。</td><td>same</td></tr><tr><td>更新中心点</td><td>对于每个簇，计算该簇中所有数据点的均值，并将该均值作为新的聚类中心。</td><td>对于每个簇，选择一个新的中心点以最小化该簇中所有点到该中心点的总距离。具体步骤如下：对于当前簇中的每个点，将该点作为新的中心点，计算所有其他点到该新中心点的总距离。 选择使总距离最小的点作为该簇的新中心点</td></tr><tr><td>重复迭代直到收敛</td><td>重复步骤二和步骤三</td><td>same</td></tr><tr><td>收敛条件</td><td>k-均值算法会在聚类中心不再改变或达到最大迭代次数时收敛</td><td>same</td></tr></tbody></table></div><p><strong>PAM</strong></p><p>假如空间中的五个点｛A、Ｂ、Ｃ、Ｄ、Ｅ｝如图1所示，各点之间的距离关系如表1所示，根据所给的数据对其运行PAM算法实现划分聚类（设<em>k</em>=2）。 样本点间距离如下表所示</p><div class="table-container"><table><thead><tr><th>样本点</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>2</td><td>2</td><td>3</td></tr><tr><td>B</td><td>1</td><td>0</td><td>2</td><td>4</td><td>3</td></tr><tr><td>C</td><td>2</td><td>2</td><td>0</td><td>1</td><td>5</td></tr><tr><td>D</td><td>2</td><td>4</td><td>1</td><td>0</td><td>3</td></tr><tr><td>E</td><td>3</td><td>3</td><td>5</td><td>3</td><td>0</td></tr></tbody></table></div><p>第一步 建立阶段：假如从5个对象中随机抽取的2个中心点为{A，B},则样本被划分为{A、C、D}和{B、E}</p><p>第二步 交换阶段：假定中心点A、B分别被非中心点C、D、E替换，根据PAM算法需要计算下列代价TCAC、 TCAD、 TCAE、TCBC、TCBD、 TCBE。</p><p>以TCAC为例说明计算过程</p><p>a)当A被C替换以后，A不再是一个中心点，因为A离B比A离C近，A被分配到B中心点代表的簇，CAAC=<em>d</em>(<em>A</em>,<em>B</em>)-<em>d</em>(<em>A</em>,<em>A</em>)=1</p><p>b)B是一个中心点，当A被C替换以后，B不受影响，CBAC=0</p><p>a)C原先属于A中心点所在的簇，当A被C替换以后，C是新中心点，符合PAM算法代价函数的第二种情况<em>C**CAC</em>=<em>d</em>(<em>C</em>,<em>C</em>)-<em>d</em>(<em>C</em>,<em>A</em>)=0-2=-2</p><p>b)D原先属于A中心点所在的簇，当A被C替换以后，离D最近的中心点是C，根据PAM算法代价函数的第二种情况<em>C**DAC</em>=<em>d</em>(<em>D</em>,<em>C</em>)-<em>d</em>(<em>D</em>,<em>A</em>)=1-2=-1</p><p>c)E原先属于B中心点所在的簇，当A被C替换以后，离E最近的中心仍然是 B，根据PAM算法代价函数的第三种情况<em>C**EAC</em>=0</p><p>因此，<em>TC**AC</em>=<em>C**AAC</em>+ <em>C**BAC</em>+ <em>C**cAC</em>+ <em>C<strong>DAC</strong>+ C**EAC</em> <em>=1+0-2-1+0=-2。</em></p><p>重复迭代，找到T最小值</p><p>PAM算法的时间复杂度通常是O(k(n-k)^2)，其中n是数据集中的对象数，k是聚类的数量。由于迭代的次数可能很多，PAM算法的复杂性很高，所以不适合大型数据库</p><p><strong>CLARANS</strong></p><p>CLARANS方法在搜索的每一步都以某种随机方式进行采样，其聚类过程可描述成一个图的搜索，图中的每个节点是一个潜在的解，即k个中心点的集合<br>在替换一个中心对象后所获得的新第一就称为当前聚类的邻居，随机产生的聚类邻居数由用户限制<br>若发现一个更好的邻居(具有较低的方差)，CLARANS算法就移动到这一邻居节点然后再开始重新搜索,否则当前节点就形成了一个局部最优<br>若发现一个局部最优，CLARANS方法就随机选择节点重新开始搜索新的局部最优</p><p>优点<br>不用限制在局部区域搜索<br>只检查节点的邻居的样本，效率高</p><h2 id="层次方法"><a href="#层次方法" class="headerlink" title="层次方法"></a><strong>层次方法</strong></h2><p>层次方法hierachical methods创建给定数据对象集的层次分解。根据层次的分解的形成方式，层次的方法可以分类为<strong>凝聚的</strong>或<strong>分裂的</strong>方法</p><p><strong>凝聚法</strong>，也称<strong>自底向上</strong>的方法，开始将每个对象形成单独的组，然后逐次合并相近的对象或组，直到所有的组合并为一个（层次的最顶层），或者满足某个终止条件</p><p><strong>分裂法</strong>，也称<strong>自顶向下</strong>的方法，开始将所有的对象置于一个簇中，每次迭代，簇分裂为更小的簇，直到最终每个对象在一个簇中，或者满足某个终止条件</p><p>比较常用的算法<br>DIANA（Divisive ANAlysis） ：<br>   分裂层次聚类算法<br>AGENES（AGglomerative NESting）：<br>   凝聚层次聚类算法<br>BIRCH：<br>   利用层次方法的平衡迭代规约和</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240418200310246.png" alt="image-20240418200310246"></p><p><strong>单链接</strong>（single-link）方法，其每个簇可以用簇中所有对象代表，簇间的相似度用属于不同簇中最近的数据点对之间的相似度来度量<br>也称为最短距离法，定义簇的邻近度为取自不同簇的所有点对的俩个最近的点之间的邻近度</p><p><strong>全链接</strong>取自不同簇中的俩个最远的点之间邻近度作为簇的邻近度，或者使用图的术语，不同的结点子集中俩个结点之间的最长边</p><p><strong>组平均</strong>（average linkage method）类间所有样本点的平均距离<br>该法利用了所有样本的信息，被认为是较好的系统聚类法</p><ul><li>当算法使用最小距离dmin（Ci，Cj）衡量簇间距离时，有时称它为最近邻聚类算法<br>如果当最近的簇之间的距离超过某个任意的阈值是聚类过程就会终止，则成其为单连接算法</li><li>使用最小距离度量的凝聚层次聚类算法也成为最小生成树算法</li><li>当算法使用最大距离dmax（Ci，Cj）衡量簇间距离时，有时称它为最远邻聚类算法（farthest-neighbor clustering algorithm）</li><li>如果当最近的簇之间的最大距离超过某个任意的阈值是聚类过程就会终止，则成其为全连接算法（complete-linkage algorithm）</li></ul><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240418203651419.png" alt="image-20240418203651419"></p><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>按相关的程度可分为完全相关、不完全相关和不相关。一般的相关现象是不完全相关。<br>按相关的方向可分为：正相关和负相关。<br>按相关的形式可分为：线性相关和非线性相关。<br>按变量多少可分为：单相关、复相关和偏相关。一个变量对另一变量的相关关系，称为单相关；一个变量对两个以上变量的相关关系时，称为复相关；在某一现象与多种现象相关的场合，当假定其他变量不变时，其中两个变量的相关关系称为偏相关。　</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>深度学习的基本思想：通过堆叠多层的网络结构和非线性变换，组合低层特征以实现对输入数据的分级表达。<br>强化学习并没有提供直接的监督信号来指导智能体（agent）的行为。</p><p>强化学习的关键要素:</p><ul><li>强化学习的关键要素有：<strong>环境、奖赏、动作和状态</strong>。有了这些要素，就可以建立一个强化学习模型；</li><li>强化学习解决的问题是：针对一个具体问题，得到一个最优策略，使得在该策略下获得的长期回报最大；</li><li>策略：在系列状态下，采取的动作或动作概率。</li></ul><p>状态（state）：</p><ul><li>就是指当前agent所处的状态。</li></ul><p>策略（policy）：就是指agent在特定状态下的动作依据，是从state到action的映射。</p><ul><li>确定策略：某一状态下的确定动作               ；</li><li>随机策略：以概率来描述，即某一状态下执行这一动作的概率                                         </li></ul><p>动作（action）：</p><ul><li>来自于动作空间，每个状态通过采取动作进行状态转移；</li><li>执行动作的目的是达到最大化期望奖赏，直到最终算法收敛，所得到的策略就是一系列action的序列数据。</li></ul><p>奖赏（reward）：</p><ul><li>奖赏通常被记作Rt，表示第t个时间步的返回奖励值。所有强化学习都是基于奖赏假设的。</li><li>奖赏通常为一个标量。</li><li>注意：回报（return）是奖赏（reward）的累积。</li></ul><p>行为策略（ b(s)  ）：</p><ul><li>用来指导个体产生与环境进行实际交互行为的策略；</li><li>实际采样的策略。</li></ul><p>目标策略（ Π(s)  ）：</p><ul><li>用来评价状态或行为价值的策略（或待优化的策略）。</li></ul><p>环境模型：理解环境或感知环境<br>更新方式：回合更新或单步更新<br>求解方式：基于价值或基于策略<br>策略使用：同策略或异策略</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划本质上是多阶段决策过程</p><p>特点</p><ul><li>根据过程的特征可以将过程按空间、时间等标志分为若干互相联系又互相区别的阶段</li><li>在每一个阶段都需要做出决策，从而使得整个过程达到最好的效果</li><li>在处理各阶段决策的选取上，不仅只依赖于当前面临的状态，而且还要注意对以后的发展，即从全局考虑解决局部的问题</li><li>当各个阶段的决策确定后，就组成了一个决策序列，因而就决定了整个过程的一条活动路线</li></ul><p><strong>多阶段决策问题</strong>是把一个问题看作是一个<strong>前后关联</strong>具有<strong>链状结构</strong>的<strong>多阶段过程</strong>，也称为<strong>序贯决策过程</strong>。</p><p>动态规划把一个问题的过程，恰当地分为若干个相互联系的<strong>阶段</strong>，以便于按一定的次序去求解。</p><p>描述阶段的变量称为<strong>阶段变量</strong>,常用k表示。阶段的划分，一般是根据<strong>时间和空间的自然特征</strong>来进行的，但要便于问题转化为多阶段决策</p><p><strong>状态</strong>表示<strong>每个阶段开始</strong>时所处的自然状况或客观条件。</p><p>能用动态规划方法求解的多阶段决策过程是一类特殊的多阶段决策过程，即状态具有<strong>无后效性的多阶段决策过程</strong></p><p><strong>它可以把一个n 维决策问题变换为n个一维最优化问题</strong></p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>1.什么是机器学习？<br> 机器学习：本质上就是让计算机自己在数据中学习规律，并根据所得到的规律对未来数据进行预测。</p><p>2.机器学习基本分类：监督学习、无监督学习。</p><ul><li><p>监督学习：监督学习是根据已有数据集，知道输入和输出结果之间的关系，然后根据这种已知关系训练得到一个最优模型。也就是说，在监督学习中，我们的训练数据应该既有特征又有标签，然后通过训练，使得机器能自己找到特征和标签之间的联系，然后在面对没有标签的数据时可以判断出标签。</p></li><li><p>无监督学习：我们需要用某种算法去训练无标签的训练集从而能让我们我们找到这组数据的潜在结构。无监督学习大致可以分为<strong>聚类</strong>和<strong>降维</strong>两大类。</p></li></ul><p>3.机器模型<br>机器学习模型分为<strong>参数化模型</strong>和<strong>非参数化</strong>模型。</p><ul><li>非参数化模型一般没有优化目标函数，利用某种算法和结构建立模型，比如K近邻、决策树等。</li><li>参数化模型中定义了或多或少的参数，通过参数计算模型的输出，通过定义某种优化目标函数，利用数据去调整(训练)参数，比如线性回归、支持向量机、贝叶斯网络、神经网络等。本书侧重于参数化模型。</li></ul><p>4.监督学习模型和无监督学习模型有哪些？</p><p>监督学习模型：<br>（1） 线性回归（Linear Regression）： 用于解决回归问题，建立输入特征与连续目标变量之间的线性关系。</p><p>（2）逻辑回归（Logistic Regression）： 用于解决分类问题，将输入映射到概率输出，并进行二分类或多分类。</p><p>（3）决策树（Decision Trees）： 通过树状结构进行决策，可用于分类和回归任务。</p><p>（4）支持向量机（Support Vector Machines，SVM）： 用于分类和回归，通过找到将不同类别分开的最优超平面。</p><p>（5）k近邻算法（k-Nearest Neighbors，KNN）： 根据输入实例的邻近实例来进行分类或回归。<br>无监督学习模型：</p><p>（1）K均值聚类（K-Means Clustering）： 用于将数据集划分为K个不同的组（簇）。</p><p>（2）层次聚类（Hierarchical Clustering）： 将数据集划分为具有层次结构的簇。</p><p>（3）主成分分析（Principal Component Analysis，PCA）： 用于降低数据维度，发现数据的主要成分。</p><p>（4）独立成分分析（Independent Component Analysis，ICA）： 寻找数据中的独立源，用于盲源分离。</p><p>（5）自编码器： 用于学习数据的紧凑表示，常用于降维和特征学习。</p><p>5.监督机器学习模型通常将有标注的数据集分割为<strong>训练集</strong>和<strong>测试集</strong>。训练集用于训练模型，获得模型的最佳参数，测试集用于度量模型训练后的性能。</p><p>6.损失函数：<br>  损失函数是这样一类函数: 当模型对样本的分类正确时，不产生损失或产生较小的损失，反之，根据其离谱程度，将带来一定甚至很大损失。通过选择合理的参数，使得整个数据产生的总体损失最小化。这个过程被称为训练(training)，也称有监督学习。</p><p>损失函数衡量的是模型预测能力的好坏。</p><p>1.机器学习：<br>是人工智能的一种分支，让计算机从数据中学习和改进，以完成某种任务，目标是让计算机在经验中学习，自动发现模式和规律，并运用规律进行预测和决策</p><p>2.过拟合及缓解方法：<br>指模型在训练数据集上表现良好，但在新数据或测试集上表现不好的现象。通常是由于模型过于复杂，使得模型在训练的过程中过分注重与特定细节，而没有真正掌握数据的底层结构和一般规律<br>缓解方法：增加训练数据量，提供更多的数据样本供模型学习，减少过拟合的风险；降低模型的复杂度，减少模型的自由度；或者通过正则化限制模型的学习能力</p><p>3.有监督和无监督学习：<br>有监督的学习是指模型在训练数据中，每个样本都有对应的标签和目标输出，模型通过学习输入与输出的映射关系进行预测和决策<br>无监督的学习是指模型在训练数据中，每个样本没有对应的标签和目标输出，模型通过学习数据的内在结构和相似性进行聚类、降维或异常检测等任务</p><p>4.查准率和查全率：<br>查准率又称精确率，是指在预测为正类的样本中真正类所占的比例，衡量分类模型在某一分类预测上的准确性。<br>查全率又称召回率，是指在实际为正类的样本中真正类所占的比例，衡量分类模型在某一分类预测上的完整性。</p><p>5.P-R曲线怎么对学习器进行比较<br>P-R曲线是以P查准率为横轴，R查全率为纵轴绘制的曲线。通过改变分类的阈值来得到不同的P-R点，比较不同学习器的性能，可以通过曲线下的面积AUC，越接近1越好，或者F1-score来判断</p><p>6.真正例率和假正例率<br>真正例率（TPR）是表示实际为正例的样本中被正确预测为正例的比例，TPR=TP/TP+FN<br>假正例率（FPR）是表示实际为负例的样本中 被错误预测为正例的比例，FPR=FP/FP+TN</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender</title>
    <link href="/zhouyuchen/2023/12/03/blender/"/>
    <url>/zhouyuchen/2023/12/03/blender/</url>
    
    <content type="html"><![CDATA[<h1 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h1><p>A 全选物体</p><p>shift a 新建物体</p><p>shift 中键 平移视图</p><p>中键 旋转视图</p><p>视图控制 按住 ~   +   数字</p><p>独立显示  /</p><p>位移     G          后面可以加上xyz</p><p>旋转     R          后面可以加上xyz </p><p>缩放     S          后面可以加上xyz</p><p>编辑视图 ctrl + tab</p><p>6 编辑点线面</p><p> alt Z 透视</p><p>CTRL B 倒角 用于创作圆角</p><p>右键平滑着色可以使用插值顶点法线，网格面的边缘会变得模糊，看起来很光滑</p><p>x 删除</p><p>alt  shift 循环切割线选中</p><p>shift D 复制</p><p>扳手工具添加修改器 添加镜像，选择吸管吸取镜像中心</p><p>物体-&gt;设置原点-&gt;几何中心  设置物体旋转轴心的方式</p><h1 id="导出物体"><a href="#导出物体" class="headerlink" title="导出物体"></a>导出物体</h1><p>路径模式：复制</p><p>勾选内嵌纹理</p><p>选定的物体</p><p>物体类型：网格</p><p>选择Z向上</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240920141435829.png" alt="image-20240920141435829"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240920141427839.png" alt="image-20240920141427839"></p>]]></content>
    
    
    <categories>
      
      <category>建模工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agisoft Metashape</title>
    <link href="/zhouyuchen/2023/09/18/Metashape/"/>
    <url>/zhouyuchen/2023/09/18/Metashape/</url>
    
    <content type="html"><![CDATA[<h1 id="Agisoft-Metashape等使用"><a href="#Agisoft-Metashape等使用" class="headerlink" title="Agisoft Metashape等使用"></a>Agisoft Metashape等使用</h1><h2 id="Metashape使用"><a href="#Metashape使用" class="headerlink" title="Metashape使用"></a>Metashape使用</h2><ol><li>新建项目，将图片资源拖入堆块（Chunk）中</li><li>选择工作流程（Workflow）中的对齐照片（Align Photos）可选精度，目的是为了将导入的素材形成链接点描点拼接</li><li>选择移动区域（Move Region)调整区域，排除多余的点</li><li>再次选择工作流程中创建点云（build dense cloud）再次生成深度图</li><li>形成深度图后，双击左侧工作区中点云查看</li><li>选择工作流程中的生成网格（Build Mesh）选择点云更加精细</li><li>选择工作区中的3D Model优化多余的点</li><li>选择工作流程中的生成纹理（Build Texture），可选纹理大小数量</li><li>选择文件导出模型，同时选中纹理导出</li></ol><h3 id="离散点删除"><a href="#离散点删除" class="headerlink" title="离散点删除"></a>离散点删除</h3><p>在对齐照片后通过使用自由选择或者矩形工具先将不需要的离散点删除</p><p>调整移动区域大小重新规定计算点</p><p>重置视图可以移动到中心位置</p><h2 id="Upscayl"><a href="#Upscayl" class="headerlink" title="Upscayl"></a>Upscayl</h2><ul><li><strong>REAL-ESRGAN：</strong>提高图片的清晰度；</li><li><strong>RemaCRI：</strong>增强图片效果；</li><li><strong>UltraMix Balanced：</strong>提高图片色彩饱和度；</li><li><strong>UltraSharp：</strong>提高图片清晰度和锐化边缘；</li><li><strong>Digital Art：</strong>提高颜色和纹理细节；</li><li><strong>Sharpen Image：</strong>只锐化处理；</li></ul><p>注意在系统中开启：</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20230925112737882.png" alt></p><p>测试记录：</p><ol><li>图片记录（5张图）<ol><li>96DPI放大4倍（9600x12800，3M，10分钟）</li><li>96DPI放大8倍（12000x16000，5M，15分钟）</li><li>300DPI（2400x3200，3M，15分钟）   300DPI放大后变为（1）</li></ol></li><li><p>建模记录</p><ol><li>5张图建模总时长在20分钟左右，DPI大，时间长</li><li>（3）点云数量多于（1，2）</li><li>（1）和（2）建模清晰度并无太大差异  （3）清晰度低</li></ol></li><li><p>总结</p><ol><li>每张图优化时长在3分钟左右，</li><li>15cm大小一面至少需要4面整体，4面细节，位置需以球面等距拍摄</li></ol></li></ol><h2 id="DOTween"><a href="#DOTween" class="headerlink" title="DOTween"></a>DOTween</h2><p><strong>解压缩</strong>到 Unity Assets 文件夹中</p><p>使用的每个类/脚本中<strong>导入 DOTween 的命名空间：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br></code></pre></td></tr></table></figure><p>初始化以设置一些全局选项，DOTween 将使用默认设置自动初始化：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">DOTween.Init(autoKillMode, useSafeMode, logBehaviour);<br></code></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/splash_lambda.png" alt="img"></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/splash_shortcuts.png" alt="img"></p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//目标点（1，1，1），时长秒</span><br>DoMove(Vector3.one, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//X,Y,Z移动</span><br>DOMoveX<br><span class="hljs-comment">//旋转</span><br>DORotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">140</span>,<span class="hljs-number">140</span>, <span class="hljs-number">140</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment">//放大</span><br>DOScale<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Metashape</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Metashape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D</title>
    <link href="/zhouyuchen/2023/09/18/Unity3D/"/>
    <url>/zhouyuchen/2023/09/18/Unity3D/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="LateUpdate和Update"><a href="#LateUpdate和Update" class="headerlink" title="LateUpdate和Update"></a>LateUpdate和Update</h2><p>两者都是每帧调用，执行顺序不同</p><p>无论有多少个update函数，都要等update函数执行完才能再执行lateupdate</p><p>Lateupdate一般放相机处理</p><p>update放画面控制逻辑</p><p>update在渲染每一帧的时候调用。但是fixupdate一般是在固定的时间频率调用。这个时间不一定是每一帧的时间。</p><h2 id="光影"><a href="#光影" class="headerlink" title="光影"></a>光影</h2><p>区域光（Area）烘焙后相当于生成一张贴图，可以删除光源</p><p>烘焙光对一般动态物体没有影响</p><h3 id="体积雾学习笔记"><a href="#体积雾学习笔记" class="headerlink" title="体积雾学习笔记"></a>体积雾学习笔记</h3><p>Volumetric Fog放在camera下</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><p>package manager 安装Universal RP</p><p>资源管理器中出现，即为安装成功</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240909153352728.png" alt="image-20240909153352728"></p><p>将项目转化为URP</p><p>选择Assets =&gt; Rendering =&gt; URP Asstes (With Universal Render)</p><p>新建完成后会出现两个文件，其中第一个为渲染相关的设置，第二个为附加设置</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240909153842969.png" alt="image-20240909153842969"></p><p>Edit =&gt; Project Setting =&gt; Graphics =&gt; Scriptable Render Pipeline Settings =&gt; 勾选新建的URP AssetEdit =&gt; Project Setting =&gt; Graphics =&gt; Scriptable Render Pipeline Settings =&gt; 勾选新建的URP Asset</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240909155658986.png" alt="image-20240909155658986"></p><p>同样的在Project Setting中选择 Quality =&gt; Rendering =&gt; Render Pipeline Asset 选择新创建的URP</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240909155708915.png" alt="image-20240909155708915"></p><p>如果导入进来的素材出现材质丢失(紫色)，在确认该素材支持URP的情况下，点击 点击 点击 Edit——RenderPipline—-&gt;UniverRenderPipline——&gt;Upgrade Project Materials to UniversalRP Materials （全部资源替换成URP材质选项）</p><h3 id="第一个shader-unit无光照"><a href="#第一个shader-unit无光照" class="headerlink" title="第一个shader unit无光照"></a>第一个shader unit无光照</h3><p><strong>Lambert</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c#">Shader <span class="hljs-string">&quot;MyFirstShader&quot;</span><br>&#123;<br>    Properties<br>    &#123;<br>        _Color(<span class="hljs-string">&quot;Color&quot;</span>,color)=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        _BaseMap(<span class="hljs-string">&quot;Base Map&quot;</span>,<span class="hljs-number">2</span>D)=<span class="hljs-string">&quot;white&quot;</span>&#123;&#125;<br>    &#125;<br>    <span class="hljs-comment">//可以根据不同渲染管线进行切换</span><br>    SubShader<br>    &#123;<br>        <span class="hljs-comment">//多个pass对物体进行多个不同渲染</span><br>        Pass<br>        &#123;<br>            <span class="hljs-comment">//选择语言HLSL，GLSL</span><br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vertex</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Pixel</span><br>            half4 _Color;<br>            sampler2D _BaseMap;<br><br>            <span class="hljs-meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span><br>            <span class="hljs-meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span><br><br>            <span class="hljs-comment">//结构体作为输入</span><br>            <span class="hljs-keyword">struct</span> Attributes<br>            &#123;<br>                float4 vertex:POSITION;<br>                float2 uv:TEXCOORD;<br>                float3 normal:NORMAL;<br>            &#125;;<br><br>            <span class="hljs-comment">//结构体作为输出</span><br>            <span class="hljs-keyword">struct</span> Varyings<br>            &#123;<br>                float4 positionCS:SV_POSITION;<br>                float2 uv:TEXCOORD;<br>                float3 normalWS:NORMAL; <span class="hljs-comment">//法线</span><br>            &#125;;<br><br>            <span class="hljs-comment">//模型顶点处理</span><br>            <span class="hljs-function">Varyings <span class="hljs-title">Vertex</span>(<span class="hljs-params">Attributes IN</span>)</span><br>            &#123;<br>                Varyings OUT;<br>                OUT.positionCS = TransformObjectToHClip(IN.vertex.xyz);<br>                OUT.normalWS = TransformObjectToWorldNormal(IN.normal);<br>                OUT.uv = IN.uv;<br>                <span class="hljs-keyword">return</span> OUT;<br>                <span class="hljs-comment">//float4 positionWS=mul(UNITY_MATRIX_M,float4(vertex.xyz,1.0));</span><br>                <span class="hljs-comment">//float4 positionCS=mul(UNITY_MATRIX_VP,float4(positionWS.xyz,1.0));</span><br>                <span class="hljs-comment">//return positionCS;</span><br>                <span class="hljs-comment">// 使用TransformObjectToHClip函数将对象空间坐标转换为裁剪空间坐标</span><br>                <span class="hljs-comment">//return TransformObjectToHClip(vertex);</span><br>            &#125;<br><br>            <span class="hljs-comment">//颜色 像素着色器</span><br>            <span class="hljs-function">half4 <span class="hljs-title">Pixel</span>(<span class="hljs-params">Varyings IN</span>):SV_TARGET</span><br>            &#123;<br>                half4 color;<br>                Light light = GetMainLight();<br>                <span class="hljs-comment">//float3 normalWS=normalize(IN.normalWS);</span><br>                <span class="hljs-built_in">float</span> NoL = max(<span class="hljs-number">0</span>, dot(IN.normalWS, light.direction));<br>                half3 gi = SampleSH(IN.normalWS) * <span class="hljs-number">0.08</span>;<br>                color.rgb = tex2D(_BaseMap, IN.uv).rgb * _Color * NoL * _MainLightColor.rgb + gi;<br>                <span class="hljs-comment">//透明度</span><br>                color.a = <span class="hljs-number">1.0</span>;<br>                <span class="hljs-keyword">return</span> color;<br>            &#125;<br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>顶点输入 (<code>Attributes</code>)</strong>：图形管线将每个顶点的坐标、纹理坐标、法线等基础数据传递到顶点着色器。</li><li><strong>顶点着色器计算</strong>：顶点着色器根据传入的顶点数据，计算出裁剪空间中的顶点位置，并将局部法线变换到世界空间。最终，纹理坐标和法线等数据保留不变或经过适当的转换。</li><li><strong>顶点输出 (<code>Varyings</code>)</strong>：顶点着色器的输出被传递给像素着色器。输出的 <code>positionCS</code> 被用于光栅化，<code>uv</code> 用于纹理采样，<code>normalWS</code> 用于光照计算。</li></ol><p><strong>Phong模型</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c#">Shader <span class="hljs-string">&quot;MyFirstShader&quot;</span><br>&#123;<br>    Properties<br>    &#123;<br>        _Color(<span class="hljs-string">&quot;Color&quot;</span>,color)=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        _BaseMap(<span class="hljs-string">&quot;Base Map&quot;</span>,<span class="hljs-number">2</span>D)=<span class="hljs-string">&quot;white&quot;</span>&#123;&#125;<br>        _Shininess(<span class="hljs-string">&quot;Shininess&quot;</span>,<span class="hljs-built_in">float</span>)=<span class="hljs-number">32</span><br>    &#125;<br>    <span class="hljs-comment">//可以根据不同渲染管线进行切换</span><br>    SubShader<br>    &#123;<br>        <span class="hljs-comment">//多个pass对物体进行多个不同渲染</span><br>        Pass<br>        &#123;<br>            <span class="hljs-comment">//选择语言HLSL，GLSL</span><br>            HLSLPROGRAM<br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> vertex Vertex</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> fragment Pixel</span><br>            half4 _Color;<br>            sampler2D _BaseMap;<br>            half _Shininess;<br><br>            <span class="hljs-meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span><br>            <span class="hljs-meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span><br><br>            <span class="hljs-comment">//结构体作为输入</span><br>            <span class="hljs-keyword">struct</span> Attributes<br>            &#123;<br>                float4 vertex:POSITION;<br>                float2 uv:TEXCOORD;<br>                float3 normal:NORMAL;<br>            &#125;;<br><br>            <span class="hljs-comment">//结构体作为输出</span><br>            <span class="hljs-keyword">struct</span> Varyings<br>            &#123;<br>                float4 positionCS:SV_POSITION;<br>                float2 uv:TEXCOORD;<br>                float3 normalWS:NORMAL; <span class="hljs-comment">//法线</span><br>                float3 positionWS:TEXCOOR1;<br>            &#125;;<br><br>            <span class="hljs-comment">//模型顶点处理</span><br>            <span class="hljs-function">Varyings <span class="hljs-title">Vertex</span>(<span class="hljs-params">Attributes IN</span>)</span><br>            &#123;<br>                Varyings OUT;<br>                OUT.positionCS = TransformObjectToHClip(IN.vertex.xyz);<br>                OUT.normalWS = TransformObjectToWorldNormal(IN.normal);<br>                OUT.uv = IN.uv;<br><br>                OUT.positionWS = mul(UNITY_MATRIX_M, float4(IN.vertex.xyz, <span class="hljs-number">1.0</span>));<br>                <span class="hljs-keyword">return</span> OUT;<br>                <span class="hljs-comment">//float4 positionCS=mul(UNITY_MATRIX_VP,float4(positionWS.xyz,1.0));</span><br>                <span class="hljs-comment">//return positionCS;</span><br>                <span class="hljs-comment">// 使用TransformObjectToHClip函数将对象空间坐标转换为裁剪空间坐标</span><br>                <span class="hljs-comment">//return TransformObjectToHClip(vertex);</span><br>            &#125;<br><br>            <span class="hljs-comment">//颜色 像素着色器</span><br>            <span class="hljs-function">half4 <span class="hljs-title">Pixel</span>(<span class="hljs-params">Varyings IN</span>):SV_TARGET</span><br>            &#123;<br>                half4 color;<br>                Light light = GetMainLight();<br>                <span class="hljs-comment">//观察方向</span><br>                float3 viewDir=-normalize(_WorldSpaceCameraPos.xyz - IN.positionWS);<br>                <span class="hljs-comment">//灯光反射方向</span><br>                float3 reflDir = reflect(light.direction, normalize(IN.normalWS));<br>                <span class="hljs-comment">//高光</span><br>                <span class="hljs-built_in">float</span> spec=max(<span class="hljs-number">0</span>,dot(viewDir,reflDir));<br>                spec=pow(spec,_Shininess);<br>                <br>                <span class="hljs-comment">//float3 normalWS=normalize(IN.normalWS);</span><br>                <span class="hljs-built_in">float</span> NoL = max(<span class="hljs-number">0</span>, dot(IN.normalWS, light.direction));<br>                half3 gi = SampleSH(IN.normalWS) * <span class="hljs-number">0.08</span>;<br>                color.rgb = tex2D(_BaseMap, IN.uv).rgb * _Color * NoL * _MainLightColor.rgb + gi+spec;<br>                <span class="hljs-comment">//透明度</span><br>                color.a = <span class="hljs-number">1.0</span>;<br>                <span class="hljs-keyword">return</span> color;<br>            &#125;<br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>blinn-phong模型</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//观察方向</span><br>                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - IN.positionWS);<br>                <span class="hljs-comment">//灯光反射方向</span><br>                <span class="hljs-comment">//float3 reflDir = reflect(light.direction, normalize(IN.normalWS));</span><br>                float3 hVec = normalize(viewDir + light.direction);<br>                <span class="hljs-comment">//高光</span><br>                <span class="hljs-built_in">float</span> spec = max(<span class="hljs-number">0</span>, dot(normalize(IN.normalWS), hVec));<br>                spec = pow(spec, _Shininess);<span class="hljs-comment">//观察方向</span><br>                float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - IN.positionWS);<br>                <span class="hljs-comment">//灯光反射方向</span><br>                <span class="hljs-comment">//float3 reflDir = reflect(light.direction, normalize(IN.normalWS));</span><br>                float3 hVec = normalize(viewDir + light.direction);<br>                <span class="hljs-comment">//高光</span><br>                <span class="hljs-built_in">float</span> spec = max(<span class="hljs-number">0</span>, dot(normalize(IN.normalWS), hVec));<br>                spec = pow(spec, _Shininess);<br></code></pre></td></tr></table></figure><h1 id="JobSystem"><a href="#JobSystem" class="headerlink" title="JobSystem"></a>JobSystem</h1>]]></content>
    
    
    <categories>
      
      <category>Unity3D</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#</title>
    <link href="/zhouyuchen/2023/06/01/C#/"/>
    <url>/zhouyuchen/2023/06/01/C#/</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习入门"><a href="#C-学习入门" class="headerlink" title="C#学习入门"></a>C#学习入门</h1><h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h3><p>C# 是在 .Net 框架开发期间开发的。</p><p>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><p>主要功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li><strong>委托（Delegates）和事件管理（Events Management）</strong></li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><p>注意以下几点：</p><ul><li>C# 是大小写敏感的。</li><li>所有的语句和表达式必须以分号（;）结尾。</li><li>程序的执行从 Main 方法开始。</li><li>与 Java 不同的是，文件名可以不同于类的名称。</li></ul><h3 id="与C不同的基本语法"><a href="#与C不同的基本语法" class="headerlink" title="与C不同的基本语法"></a>与C不同的基本语法</h3><h4 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h4><p>在任何 C# 程序中的第一条语句都是：</p><p>由于使用 <code>using</code> 指令，因此程序可以使用 <code>Console.WriteLine</code> 作为 <code>System.Console.WriteLine</code> 的简写。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<span class="hljs-comment">//一个程序可以包含多个using语句</span><br></code></pre></td></tr></table></figure><h4 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h4><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System -  CTS）中所有数据类型的终极基类。Object 是 System.Object  类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><h4 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h4><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h4 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h4><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">String str = <span class="hljs-string">&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-string">@&quot;runoob.com&quot;</span>;<br></code></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;C:\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;C:\\Windows&quot;</span>;<br></code></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span><br><span class="hljs-string">    &lt;!--</span><br><span class="hljs-string">    --&gt;</span><br><span class="hljs-string">&lt;/script&gt;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C#类型转换"></a>C#类型转换</h3><p>C#类型转换与C很类似，隐式转换和显示转换（强转）</p><p><a href="https://www.runoob.com/csharp/csharp-type-conversion.html">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C#变量"></a>C#变量</h3><h4 id="接受来自用户的值"><a href="#接受来自用户的值" class="headerlink" title="接受来自用户的值"></a>接受来自用户的值</h4><p><strong>System</strong> 命名空间中的 <strong>Console</strong> 类提供了一个函数 <strong>ReadLine()</strong>，用于接收来自用户的输入，并把它存储到一个变量中。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> num;<br>num = Convert.ToInt32(Console.ReadLine());<br></code></pre></td></tr></table></figure><p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p><h3 id="C-常量运算符与C类似"><a href="#C-常量运算符与C类似" class="headerlink" title="C#常量运算符与C类似"></a>C#常量运算符与C类似</h3><p>需要注意的是</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>\</td><td></td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A \</td><td>B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car)  // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”);      StringReader r = obj as StringReader;</td></tr></tbody></table></div><h3 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h3><p>internal：同一个程序集的对象可以访问；</p><p>protected internal：访问限于当前程序集或派生自包含类的类型。也就是包括protected 和 internal</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20230712222252009.png" alt></p><h3 id="C-方法"><a href="#C-方法" class="headerlink" title="C#方法"></a>C#方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)<br>&#123;<br>   Method Body<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</p><p><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</p><p><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</p><p><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</p><p><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>&#123;<br>    <span class="hljs-comment">//方法主体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h4><p>通过方法名调用</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全</p><p>即使在函数内改变了值，值也没有发生任何的变化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>        &#123;...&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        ...<br>        <span class="hljs-built_in">int</span> ret;<br>        <span class="hljs-comment">//调用 FindMax 方法</span><br>        ret = n.FindMax(a, b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>   &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>      &#123;<br>         ...<br>      &#125;  <br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.swap(a, b);<br>         ...<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h4><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>         ...<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h4><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>         <span class="hljs-comment">/* 调用函数 */</span><br>         n.getValue(<span class="hljs-keyword">out</span> a)<br>         ...<br>      &#125;<br></code></pre></td></tr></table></figure><p>通过用户输入值再输出</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> y </span>)</span><br>      &#123;<br>          Console.WriteLine(<span class="hljs-string">&quot;请输入第一个值： &quot;</span>);<br>          x = Convert.ToInt32(Console.ReadLine());<br>          Console.WriteLine(<span class="hljs-string">&quot;请输入第二个值： &quot;</span>);<br>          y = Convert.ToInt32(Console.ReadLine());<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i; <span class="hljs-comment">//默认值0</span><br><span class="hljs-built_in">int</span>? ii; <span class="hljs-comment">//默认值nul</span><br></code></pre></td></tr></table></figure><h4 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h4><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br></code></pre></td></tr></table></figure><h4 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/* 初始化数组 n 中的元素 */</span>        <br><span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ )<br>&#123;<br>   n[i] = i + <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-comment">/* 输出每个数组元素的值 */</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> j <span class="hljs-keyword">in</span> n )<br>&#123;<br>   <span class="hljs-built_in">int</span> i = j<span class="hljs-number">-100</span>;<br>   Console.WriteLine(<span class="hljs-string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, i, j);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs result">Element[0] = 100<br>Element[1] = 101<br>Element[2] = 102<br>...<br></code></pre></td></tr></table></figure><h3 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h3><h4 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h4><p>String 类有以下两个属性：</p><div class="table-container"><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table></div><h4 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h4><div class="table-container"><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator,        string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table></div><p>完整方法参考MSDN库</p><p>C# 结构体、枚举、类与C相同不再赘述</p><p>类的继承以  子类 ：父类 方式继承</p><p>多重继承以  子类：父类，父类  方式继承</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240311201304749.png" alt></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> counter;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    StartCoroutine(<span class="hljs-string">&quot;myCoroutine&quot;</span>);<br>    print(<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (counter &lt; <span class="hljs-number">10</span>)<br>        print(<span class="hljs-string">&quot;帧数：&quot;</span> + counter++);<br><br>&#125;<br><span class="hljs-function">IEnumerator <span class="hljs-title">myCoroutine</span>()</span><br>&#123;<br>    print(<span class="hljs-string">&quot;步骤1&quot;</span>);<br>    <span class="hljs-comment">// 挂起，控制权返回原来的语句,直到下一帧,逐帧动态</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <br>    print(<span class="hljs-string">&quot;步骤2&quot;</span>);<br>    print(<span class="hljs-string">&quot;步骤3&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240311210341910.png" alt></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20240311211543512.png" alt></p><h2 id="c-快捷键"><a href="#c-快捷键" class="headerlink" title="c#快捷键"></a>c#快捷键</h2><ul><li>快速对齐：ctrl+Ｋ + D<br>快速弹出智能提示：ctrl + J<br><strong>ctrl k ctrl u取消注释 c 加上注释</strong><br>取消所选的注释：ctrl + K+ U<br>折叠冗余代码：#region 和 #endregion<br><strong>输入svm然后按Tab键会生成Main函数；</strong><br>ctrl+K+S 三个键一起按，会调出代码段；选中多行后，然后按以上三个快捷键，按下Tab，代码段会自动包括选中代码，就可以进行相关的操作。比如加上region等。<br> 单行选中： Shift+Home：选中当前坐标到行首的代码；Shift+End选中当前坐标到行尾的代码；<br>折叠代码：ctrl+M + O，用来查看代码结构是否规整。<br>展开折叠代码： ctrl + M + L<br>展开或折叠光标所在的的代码块：ctrl + M+ M<br>转到定义：F12<br>F7 从设计界面切转到后台代码。Shift+F7 从后台代码切换到设计界面。<br>自动给字段加属性，封装属性的快捷键：Ctrl+R+E。<br>删除整行：ctrl + L<br>F9 添加、消除断点；Shift+Ctrl+F9取消所有断点。</li><li><strong>复制当前行 ctrl D</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU</title>
    <link href="/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/"/>
    <url>/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>GPU（Graphics Processing Unit）图形处理器与CPU（Central Processing Unit）相比具有：</p><ol><li>高并行结构，因此在处理图形数据和复杂算法效率更高</li><li>更多的ALU（Arithmetic Logical Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，适合对密集型数据并行处理</li><li>CPU执行计算时是时间片轮转算法，GPU具有多个处理器核，在一个时刻可以并行处理多个数据 </li><li>流式并行计算模式，对每个数据进行独立计算，任意元素不依赖其他同类元素</li></ol>]]></content>
    
    
    <categories>
      
      <category>GPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希算法</title>
    <link href="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>哈希算法</strong>（Hash 算法，散列算法，消息摘要算法）将任意长度的二进制值映射为较短的固定长度的二进制值 ，这个小的二进制值称为哈希值。</p><p>简单来说就是通过哈希值快速定位到想要查找的记录，而不是通过表中存放的关键字来比较查找。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>哈希表是根据设定的哈希函数和处理冲突方法将<strong>一组关键字</strong>映射到<strong>一个有限的地址区间</strong>上，作为记录在表中的<strong>存储位置</strong>，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</li><li>通过将哈希算法应用到<strong>任意数量</strong>的数据会得到的<strong>固定大小</strong>的结果。如果输入数据中有变化，则哈希也会发生变化。哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”。</li><li>它是一种<strong>单向密码体制</strong>,即它是一个从明文到密文的不可逆的映射。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。</li><li>是一种基于Hash函数的文件构造方法，可对记录快速随机存取。把任意长关键字映射为一个固定长度的哈希值，一 般用于鉴权、认证、加密、索引等。其主要优点是<strong>运算简单</strong>，<strong>预处理时间较短</strong>，<strong>内存消耗低</strong>，匹配查找<strong>速度快</strong>，便于维护和刷新，支持匹配规则数多等。</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>如果对一个字符串数组进行查询。最快的检索办法是通过数组的下标进行检索，但是对于这种场景，只能从头查到尾，从而查询出目标元素。因此最坏情况下时间复杂度为O(n)，但是使用Hash可以将时间复杂度降为O(1)。</p><p>Hash表采用一个映射函数 function: key -&gt; address 将关键字映射到该记录在表中的存储位置，在想要查找该记录时，可以直接根据关键字和<strong>映射关系</strong>计算出该记录在表中的存储位置，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置（存储位置只是表中的存储位置，并不是实际的物理地址）称作为<strong>Hash地址</strong>。</p><p>比如上述例子中，假如字符串数组采用Hash表存储，则当想要找到字符串对应的信息时，直接根据字符串和Hash函数计算出 Hash 地址即可。所谓的 Hash 算法就是将字符串转换为数字的算法。例如我们可以将字符串数组的各个字符的ASCII码计算出，作为Hash表的地址，当需要哪个字符串时候就根据数字之间查找出，当然这是最笨的Hash算法。</p><h2 id="Hash函数设计"><a href="#Hash函数设计" class="headerlink" title="Hash函数设计"></a>Hash函数设计</h2><ol><li>直接定址法</li></ol><p>取关键字或者关键字的某个线性函数为 Hash 地址，即address(key) = a * key + b; 如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000(其中a = 1)作为Hash地址。</p><ol><li>平方取中法</li></ol><p>对关键字进行平方计算，取结果的中间几位作为 Hash 地址。如有以下关键字序列 {421，423，436} ，平方之后的结果为 {177241，178929，190096} ，那么可以取中间的两位数 {72，89，00} 作为 Hash 地址。</p><ol><li>折叠法</li></ol><p>将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。如图书的 ISBN 号为 8903-241-23，可以将address(key)=89+03+24+12+3 作为 Hash 地址。</p><ol><li>除留取余法</li></ol><p>如果知道 Hash 表的最大长度为 m，可以取不大于m的最大质数 p，然后对关键字进行取余运算，address(key)=key % p。这里 p 的选取非常关键，p 选择的好的话，能够最大程度地减少冲突，p 一般取不大于m的最大质数。</p><ol><li>基数转换法</li></ol><p>将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中若干为作为X的哈希值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。</p><ol><li>随机数法</li></ol><p>设定哈希函数为:H(key)=Random(key)其中，Random为伪随机函数</p><p>此法适于：对长度不等的关键字构造哈希函数。</p><ol><li>字符串数值哈希法</li></ol><p>把字符串的前10个字符的ASCⅡ值之和对N取摸作为Hash地址，只要N较小，Hash地址将较均匀分布[0，N]区间内。对于N很大的情形，可使用ELFHash(ExecutableandLinkingFormat,ELF,可执行链接格式)函数，它把一个字符串的绝对长度作为输入，并通过一种方式把字符的十进制值结合起来，对长字符串和短字符串都有效，这种方式产生的位置可能不均匀分布。</p><ol><li>旋转法</li></ol><p>旋转法是将数据的键值中进行旋转。旋转法通常并不直接使用在哈希函数上，而是搭配其他哈希函数使用。</p><h2 id="Hash-冲突及解决方案"><a href="#Hash-冲突及解决方案" class="headerlink" title="Hash 冲突及解决方案"></a>Hash 冲突及解决方案</h2><p>因为我们是用字符串数组对哈希值进行定值，有可能不同键值所得到的索引值相同，这里就是冲突。如不同的字符串可能ASCII总和是相同的，显然出现的这种情况是不合理的，解决该冲突的方法就是改变数据结构。我们将数组内的元素改变为一个链表，这样就能容下足够多的元素了，冲突问题也能得到解决。具体如何解决请看下面的链地址法。</p><ol><li>开放定址法</li></ol><p>发生冲突时，使用某种探测技术在 Hash 表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash 表长为14，Hash 函数为 address(key) = key % 11，当插入12，13，25时可以直接插入，而当插入 23 时，地址 1 被占用了（因为 12%11 和 23%11 的结果相同）。此时沿着地址 1 依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将 23 插入其中。</p><ol><li>链地址法</li></ol><p>采用数组和链表相结合的数据结构，将 Hash 地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如下图最左边是数组结构，数组内的元素为链表结构。</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20230330224717657.png" alt></p><h2 id="Hash-表的用处以及优劣"><a href="#Hash-表的用处以及优劣" class="headerlink" title="Hash 表的用处以及优劣"></a>Hash 表的用处以及优劣</h2><ol><li>找出两文件找出重复的元素</li></ol><p>假设有两个文件，文件中均包含一些短字符串，字符串个数分别为n。它们是有重复的字符串，现在需要找出所有重复的字符串。</p><p>最笨的解决办法可能是：遍历文件 1 中的每个元素，取出每一个元素分别去文件 2 中进行查找，这样的时间复杂度为O（n^2）。</p><p>但是借助 Hash 表可以有一种相对巧妙的方法，分别遍历文件 1 中的元素和文件 2 中的元素，然后放入 Hash Table 中，对于遍历的每一个元素我们只要简单的做一下计数处理即可。最后遍历整个 Hash 列表，找出所有个数大于 1 的元素即为重复的元素。</p><ol><li>找出两文件找出出现次数最多的元素</li></ol><p>同找出两文件找出重复的元素这样的问题解决方案类似，只是在最后遍历的时找计数最大的元素，即为出现次数最多的元素。</p><ol><li>路由算法</li></ol><p>多线程处理数据的场景下，通常需要将一个数据集分给不同的线程进行处理，同时要保证，相同的元素需要分到相同的处理线程上。这其实这个就是一个很典型的 Hash 值应用场景，对于很多的计算引擎默认都是用 Hash 算法去解决这个问题。因为相同元素的 Hash 值相同，那么我们可以取 Hash 之后进行模运算，运算结果分配到不同的线程。</p><p>优点</p><p>哈希表的效率非常高，查找、插入、删除操作只需要接近常量的时间即0(1）的时间级。如果需要在一秒种内查找上千条记录通常使用哈希表，哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。如果不需要遍历数据，不二的选择。</p><p>缺点</p><p>它是基于数组的，数组创建后难于扩展。有些情况下，哈希表被基本填满时，性能下降得非常严重，所以开发者必须要清楚表中将要存储的数据量。或者也可以定期地把数据转移到更大的哈希表中，不过这个过程耗时相对比较大。</p><p>注意点</p><p>在设计Hash算法的时候。一定要保证相同字符串产生的 Hash 值相同，同时要尽量的减小Hash冲突的发生，这样才算是好的 hash 算法。</p><h2 id="哈希加盐"><a href="#哈希加盐" class="headerlink" title="哈希加盐"></a>哈希加盐</h2><p>我们知道，系统保存用户的密码时，一般不会直接保存下密码，而是通过md5加密后保存；</p><p>md5加密原理：Orz</p><p>md5已经是一种十分安全的加密方法了，但是通过彩虹表依旧可以破解（彩虹表原理），那么我们伟大机智的程序员们就想出了在密码后加一段序列然后再md5加密的方法，这个后面加上的序列就是所谓的 “ 盐 ” 。</p><p>具体的流程是：</p><p>用户注册时：</p><ol><li><p>用户在网站注册时提供ID与口令</p></li><li><p>系统随机为用户分配盐值</p></li><li><p>盐值插入口令后进行hash</p></li><li><p>将ID，hash值与盐值存入数据库</p></li></ol><p>身份验证时：</p><ol><li><p>用户提供ID与口令</p></li><li><p>系统在数据库中通过用户提供的ID查找HASH值与盐值</p></li><li><p>将盐值插入用户提供的口令后进行HASH</p></li><li><p>将HASH值与数据库中的HASH值比较，相等则验证成功，反之验证失败</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache</title>
    <link href="/zhouyuchen/2023/02/08/Cache/"/>
    <url>/zhouyuchen/2023/02/08/Cache/</url>
    
    <content type="html"><![CDATA[<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>CPU的运行速度是远远高于读写内存速度的，以当前嵌入式普遍使用的mcu来说，主频也普遍在几百Mhz，但是要知道使用的主存储器使用的动态存储器（DRAM）其存储速度在10Mhz左右。这样，如果指令和数据都存储在主存储器中，内存的速度会严重制约整个系统的性能。因此，为了解决内存速度低下，Cache就被引入了。可以说 Cache 是连接 CPU 和内存的桥梁。 </p><p>Cache全部是由硬件实现的，其不仅对于应用程序员是透明的，对系统程序员也是透明的，其是由速度与cpu速度相近的SRAM构成（Cahce和内存都是用的SRAM，那么速度为什么不同这是因为离CPU距离不同越近总线读写速度越快）。现在的处理器一般是通过多级缓存的组织形式来达到性能和功能的最优。但是其实对于多级cache还是一级cache，其原理是一致的，了解其原理后，多级和一级没有什么功能上的差异。</p><h2 id="Cache功能"><a href="#Cache功能" class="headerlink" title="Cache功能"></a>Cache功能</h2><p>cache是一种<strong>高速缓冲存储器</strong>，是为了解决CPU和主存之间速度不匹配而采用的一项重要技术</p><h2 id="Cache原理"><a href="#Cache原理" class="headerlink" title="Cache原理"></a>Cache原理</h2><p>cache原理是基于程序运行中具有的<strong>空间</strong>局限性和<strong>时间</strong>局限性特征。</p><p>空间局限性：在最近的未来要用到的信息(指令和数据)，很有可能与现在正在使用的信息在存储空间上是邻近的，如：数组元素、顺序执行的指令代码</p><p>时间局限性：在最近的未来要用到的信息，很可能是现在正在使用的信息，  如：循环结构的指令代码</p><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放在Cache中</p>]]></content>
    
    
    <categories>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/zhouyuchen/2023/02/02/Redis/"/>
    <url>/zhouyuchen/2023/02/02/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是C语言开发的一个开源高性能键值对的<strong>内存数据库</strong>，可以用来做数据库、缓存、消息中间件等场景，是一种NoSQL(not-only sql,非关系型数据库)的数据库。</p><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>优秀的性能，数据是存储在内存中，读写速度非常快，可支持并发10W QPS(一般指每秒查询率)</li><li>单线程但进程，是线程安全的，采用IO 多路复用制</li><li>可作为分布式锁</li><li>支持五种数据类型</li><li>支持数据持久化到磁盘</li><li>可以作为消息中间件使用，支持消息发布及订阅</li></ul><h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。       </li></ul><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>每个 hash 可以存储 23^2 -1 键值对（40多亿）。</p><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表最多可存储  23^2 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis  zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td style="text-align:center">String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—-</td></tr><tr><td style="text-align:center">Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td style="text-align:center">List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td style="text-align:center">Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td style="text-align:center">Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table></div><p>Redis中文文档链接: <a href="http://www.redis.cn/documentation.html">http://www.redis.cn/documentation.html</a></p><p>Redis英文文档 <a href="https://redis.io/topics/data-types">https://redis.io/topics/data-types</a></p><p>Redis官网:<a href="http://redis.io/">http://redis.io/</a></p><p>Redis官方文档:<a href="http://redis.io/documentation">http://redis.io/documentation</a></p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是冒泡排序的改进，之所以快速是由于运用了<strong>分治法</strong></p><p>主要思路：</p><ol><li>选择一个数为基准点</li><li>从左往右，将数与基准点相比较，同时从右往左将数与基准点相比较</li><li>当左边的数比基准点大时，同时右边的数比基准点小时，把两数交换</li><li>此时左边的数都小于基准点，右边的数都大于基准点。此时以基准点拆分成2队，重复执行步骤2，3，4</li></ol><p>如下是<strong>一次快排</strong>图解，选用了中点（pivot）作为基准点</p><p>xxxxxxxxxx class Solution {    public int lengthOfLongestSubstring(String s) {        if (s.length()==0) return 0;        HashMap<Character, integer> map = new HashMap<Character, integer>();        int max = 0;//最长子串长度        int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标        for(int i = 0; i &lt; s.length(); i ++){            if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。                left = Math.max(left,map.get(s.charAt(i)) + 1);       //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移            }        //map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位            map.put(s.charAt(i),i);      //再更新map中a映射的下标            max = Math.max(max,i-left+1);     //比较两个参数的大小        }        return max;            }}java </Character,></Character,></p><p>下面用个简单的实例说明：</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20230317124246696.png" alt></p><p>这是以20作为了基准点，进行一次快排的过程</p><p>之后以20为基准点分为左右两队再进行快排便可以得到结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = left, j = right;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-comment">// 基准点</span><br>    <span class="hljs-type">int</span> pivot;<br><br>    pivot = arr[(i + j) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt;= j)<br>    &#123;<br>        <span class="hljs-comment">// 从左到右边找到大于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[i] &lt; pivot)<br>        &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 从右到左边找到小于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[j] &gt; pivot)<br>        &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 如果i&lt;=j则互换元素</span><br>        <span class="hljs-keyword">if</span> (i &lt;= j)<br>        &#123;<br>            temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &lt; j)<br>    &#123;<br>        quick_sort(arr, left, j);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; right)<br>    &#123;<br>        quick_sort(arr, i, right);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">21</span>, <span class="hljs-number">2</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-type">int</span> i, len;<br>    len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    quick_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔</title>
    <link href="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>经典递归问题：汉诺塔</p><p>汉诺塔的本质（x，y，z三根柱）：</p><ol><li>将n-1层从x移动到y</li><li>将第n层从x移动到z</li><li>将n-1层从y移动到z    </li></ol><p>三步解决</p><p>因此用递归的方法，只需考虑2层时候的代码（把第一层看作是n-1层，第二层看作是n层）</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/(1" alt>.png)</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/(2" alt>.png)</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/(3" alt>.png)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span><br>&#123;<br>    <span class="hljs-comment">//判断n的层数，如果为一层直接移动x到z</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c ---&gt;  %c\n&quot;</span>, x, z);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//当n！=1时候，将再次调用函数，移动n-1层：x到y，也就是把y和z互换</span><br>        hanoi(n - <span class="hljs-number">1</span>, x, z, y);<br>        <span class="hljs-comment">//移动第n层：x到z</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c ---&gt;  %c\n&quot;</span>, x, z);<br>        <span class="hljs-comment">//最后移动n-层：y到z</span><br>        hanoi(n - <span class="hljs-number">1</span>, y, x, z);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入汉诺塔的层数：\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    hanoi(n, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汉诺塔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git问题记录</title>
    <link href="/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git问题记录"><a href="#Git问题记录" class="headerlink" title="Git问题记录"></a>Git问题记录</h1><p>本文章记录使用Git遇到的问题，方便以后的查阅解决</p><h2 id="撤消尚未推送的Git合并"><a href="#撤消尚未推送的Git合并" class="headerlink" title="撤消尚未推送的Git合并"></a>撤消尚未推送的Git合并</h2><p>通过git-reset - 重置当前HEAD到指定的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard <br>git reset --hard ORIG_HEAD<br>git reset --merge ORIG_HEAD<br></code></pre></td></tr></table></figure><ol><li>没有进行合并提交，所以<code>git reset --hard</code>是<code>git reset --hard HEAD</code>的同义词，它清除了索引文件和工作树上的混乱。</li><li>“pull “或 “merge “总是在<code>ORIG_HEAD</code>中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。</li><li>在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。 运行<code>git reset --hard ORIG_HEAD</code>可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。 <code>git reset --merge</code>会保留你的本地修改。</li></ol><h2 id="恢复已经删除的提交"><a href="#恢复已经删除的提交" class="headerlink" title="恢复已经删除的提交"></a>恢复已经删除的提交</h2><p>当需要恢复已经删除的提交记录时候</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br>git rest --hard commitID<br>git push origin HEAD --force<br></code></pre></td></tr></table></figure><ol><li>通过reflog找到删除的提交的ID</li><li>执行上述命令，加上提交的ID即可恢复</li><li>本地退回后强制推送到远程仓库</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/zhouyuchen/2023/01/02/React/"/>
    <url>/zhouyuchen/2023/01/02/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>这篇博客是记录我react入门学习笔记，供我自己参考。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>React：用于构建用户界面的JavaScript库（将数据渲染为HTML视图的JS库）</p><h3 id="为什么要学"><a href="#为什么要学" class="headerlink" title="为什么要学"></a>为什么要学</h3><ol><li>原生JS操作DOM繁琐，效率低。</li><li>原生JS操作DOM会使浏览器大量重绘重排。</li><li>原生JS没有组件化的编码方案，代码复用率低。</li></ol><p>React特点：</p><ol><li>采用组件化模式，<strong>声明式编码</strong>，提高开发效率和组件复用率。</li><li>React Native 中可以使用React语法进行<strong>移动端开发</strong></li><li>使用<strong>虚拟DOM</strong>和优秀的<strong>Diffing算法</strong>，尽量减少与真实DOM的交互 </li></ol><h2 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h2><p>核心库必须先引入</p><p>babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p><p>react下载官网：<a href="http://react-cn.github.io/react/downloads.html">http://react-cn.github.io/react/downloads.html</a></p><p><strong>官方提供的：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引入react核心库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入babel，用于jsx转为js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Staticfile CDN 的 React CDN 库：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用JSX（JS+XML）创建虚拟DOM</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">&quot;test&quot;</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//创建虚拟DOM,不要写引号</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello,react<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//渲染虚拟DOM到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>用JS创建虚拟DOM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-comment">//创建虚拟DOM,不要写引号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;, <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;hello React&#x27;</span>))<br><span class="hljs-comment">//渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>可以看出JSX使用就如同写HTML一样方便，但是如果要嵌套多个标签，JS会大量增加重复的代码</p><p>关于虚拟DOM：</p><ol><li>本质是Object对象</li><li>虚拟DOM属性少，真实DOM属性多，因为虚拟DOM是React内部使用，无需那些多余的属性</li><li>虚拟DOM最终会被React转换为真实DOM，呈现在页面上</li></ol><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ol><li><p>定义虚拟DOM时，不要写引号。</p></li><li><p>标签混入JS表达式时用{}。</p></li><li><p>样式类名指定不要用class，用className</p></li><li><p>内联样式，要用style=的形式去写</p></li><li><p>虚拟DOM必须只有一个根标签</p></li><li><p>标签必须闭合</p></li><li><p>标签首字符</p><p>1）若<strong>小写字母</strong>开头，则将标签转为html中<strong>同名元素</strong>，若html中无，则报错</p><p>2）若<strong>大写字母</strong>开头，react渲染<strong>对应的组件</strong>，若组件未定义，则报错</p></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>JSX使用JavaScript表达式，表达式写在花括号 <strong>{}</strong> 中</p><p>在 JSX 中不能使用 <strong>if else</strong> 语句，但可以使用 <strong>conditional (三元运算)</strong> 表达式来替代。以下实例中如果变量 <strong>i</strong> 等于 <strong>1</strong> 浏览器将输出 <strong>true</strong>, 如果修改 i 的值，则会输出 <strong>false</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;i == 1 ? &#x27;True!&#x27; : &#x27;False&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type=&quot;text/babel&quot;&gt;<br>    console.log(this)//此处this是undefined 因为babel编译后开启了严格模式<br>    function MyComponent() &#123;<br>        return &lt;h1&gt;函数定义的组件&lt;/h1&gt;<br>    &#125;<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>执行ReactDOM.render(<MyComponent>…)</MyComponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由函数定义的，随后调用函数，将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type=&quot;text/babel&quot;&gt;<br>    class MyComponent extends React.Component &#123;<br>        render() &#123;<br>            console.log(this)//MyComponent实例<br>            return &lt;h1&gt;我是类定义的组件&lt;/h1&gt;<br>        &#125;<br>    &#125;<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&quot;test&quot;))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>执行ReactDOM.render(<MyComponent>…)</MyComponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由类定义的，随后new该类的实例，并通过该实例调用到原型上的render方法</li><li>将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state是组件对象的重要属性，值是对象（可以包含多个key-value的组合）</p><p>React的组件被看为”状态机“，通过更新组件的state来更新对象对应的页面显示（重新渲染组件，不需要操作DOM）</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><sup><a href="#fn_自定义function中默认开启了严格模式，所以function中的this为undefined" id="reffn_自定义function中默认开启了严格模式，所以function中的this为undefined">自定义function中默认开启了严格模式，所以function中的this为undefined</a></sup>:</p><ol><li>组件中的render方法中的this为实例对象</li><li><p>组件自定义的方法中的this为undefined解决方式：</p><ol><li>强制绑定this：通过函数对象的bind(this)</li><li>箭头函数</li></ol></li><li><p>状态数据，不能直接修改或者更新</p></li></ol><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>state 和 props 主要的区别在于 <strong>props</strong> 是不可变的，而 state 可以根据与用户交互来改变。 state 来更新和修改数据，子组件只能通过 props 来传递数据。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExcelReader</title>
    <link href="/zhouyuchen/2022/12/08/ExcelReader/"/>
    <url>/zhouyuchen/2022/12/08/ExcelReader/</url>
    
    <content type="html"><![CDATA[<h1 id="ExcelReader"><a href="#ExcelReader" class="headerlink" title="ExcelReader"></a>ExcelReader</h1><h2 id="用户导入"><a href="#用户导入" class="headerlink" title="用户导入"></a>用户导入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/import&quot;)</span><br>        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">imp</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br>                <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> ExcelUtil.getReader(inputStream);<br>                <span class="hljs-comment">// 方式1：(推荐) 通过 javabean的方式读取Excel内的对象，但是要求表头必须是英文，跟javabean的属性要对应起来</span><br><span class="hljs-comment">//        List&lt;User&gt; list = reader.readAll(User.class);</span><br><br>                <span class="hljs-comment">// 方式2：忽略表头的中文，直接读取表的内容</span><br>                List&lt;List&lt;Object&gt;&gt; list = reader.read(<span class="hljs-number">1</span>);<br>                List&lt;User&gt; users = CollUtil.newArrayList();<br>                <span class="hljs-keyword">for</span> (List&lt;Object&gt; row : list) &#123;<br>                        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                        user.setUsername(row.get(<span class="hljs-number">0</span>).toString());<br>                        user.setPassword(row.get(<span class="hljs-number">1</span>).toString());<br>                        users.add(user);<br>                &#125;<br>                userService.saveBatch(users);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="用户导出"><a href="#用户导出" class="headerlink" title="用户导出"></a>用户导出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/export&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从数据库查询出所有的数据</span><br>        List&lt;User&gt; list = userService.list();<br>        <span class="hljs-comment">// 通过工具类创建writer 写出到磁盘路径</span><br><span class="hljs-comment">//        ExcelWriter writer = ExcelUtil.getWriter(filesUploadPath + &quot;/用户信息.xlsx&quot;);</span><br>        <span class="hljs-comment">// 在内存操作，写出到浏览器</span><br>        <span class="hljs-type">ExcelWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> ExcelUtil.getWriter(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//自定义标题别名</span><br>        writer.addHeaderAlias(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;用户名&quot;</span>);<br>        writer.addHeaderAlias(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;密码&quot;</span>);<br><br>        <span class="hljs-comment">// 一次性写出list内的对象到excel，使用默认样式，强制输出标题</span><br>        writer.write(list, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 设置浏览器响应的格式</span><br>        response.setContentType(<span class="hljs-string">&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> URLEncoder.encode(<span class="hljs-string">&quot;用户信息&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + fileName + <span class="hljs-string">&quot;.xlsx&quot;</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        writer.flush(out, <span class="hljs-literal">true</span>);<br>        out.close();<br>        writer.close(); <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExcelReader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C算法记录</title>
    <link href="/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="C算法记录"><a href="#C算法记录" class="headerlink" title="C算法记录"></a>C算法记录</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-comment">//定义一个静态的全局变量，用于存放数组下标，大小为2</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//int *res=(int*)malloc(sizeof(int)*2);</span><br>    <span class="hljs-comment">//返回值大小</span><br>    *returnSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//暴力遍历所有方法，默认为有解，i只需遍历到数组倒数第二个值，j跟随i的变化而变化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)&#123;<br>            <span class="hljs-comment">//将每一种可能与target比较</span><br>            <span class="hljs-keyword">if</span>(*(nums+i)+*(nums+j)==target)&#123;<br>                <span class="hljs-comment">//存入res数组中并且返回</span><br>                res[<span class="hljs-number">0</span>]=i;<br>                res[<span class="hljs-number">1</span>]=j;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误记录：</strong></p><p>​    使用int res[2]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line <span class="hljs-number">207</span>: Char <span class="hljs-number">3</span>: runtime error: load of null pointer of type <span class="hljs-string">&#x27;int&#x27;</span> [__Serializer__.c]<br></code></pre></td></tr></table></figure><p>​    空指针异常</p><p>​    力扣提示Note: The returned array must be malloced, assume caller calls free().</p><p>​    因为函数返回的是指针地址指向函数内的局部变量数组，在函数退出时，数组的存储空间会被销毁，此时去访问该地址就会出现这个错误。</p><p><strong>解决办法：</strong></p><p>​    使用malloc函数，当malloc函数被调用时，它会沿空闲链表寻找一个可以满足需求的内存块，然后把所需大小的内存块分配给用户，剩下的返回到链表上。free函数被调用时，它将释放的内存块连接到空闲链表上。</p><p>​    malloc函数声明：void *malloc (int size)；向系统申请分配size字节的内存空间。</p><p>​    因为malloc返回是void类型指针，因此使用时候要强制转换为int：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *res=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*sizeNums);<br></code></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-plus</title>
    <link href="/zhouyuchen/2022/12/04/Mybatis-plus/"/>
    <url>/zhouyuchen/2022/12/04/Mybatis-plus/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot-集成Mybatis-plus"><a href="#Spring-Boot-集成Mybatis-plus" class="headerlink" title="Spring Boot 集成Mybatis-plus"></a>Spring Boot 集成Mybatis-plus</h2><p>在pom.xml引入Mybatis-plus </p><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建MybatisPlusConfig （我用的是MySQL数据库）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guanli.xitong.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;你的mapper的reference&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<span class="hljs-comment">//使用MySQL</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写 Mapper 包下的 <code>UserMapper</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>即可开始使用</p><p>下面是例子（分页查询）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询 mybatis plus</span><br><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> IPage&lt;User&gt; <span class="hljs-title function_">findPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer pageNum,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> Integer pageSize,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(defaultValue = &quot;&quot;)</span> String username,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> (defaultValue = <span class="hljs-string">&quot;&quot;</span>)</span>String nikename,<br>                            <span class="hljs-meta">@RequestParam(defaultValue = &quot;&quot;)</span> String address) &#123;<br>    IPage&lt;User&gt;page=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum,pageSize);<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">&quot;username&quot;</span>,username);<br>    queryWrapper.like(<span class="hljs-string">&quot;nikename&quot;</span>,nikename);<br>    queryWrapper.like(<span class="hljs-string">&quot;address&quot;</span>,address);<span class="hljs-comment">//通过Mybatis-plus的methods可知自动拼接条件查询</span><br>    <span class="hljs-keyword">return</span> userService.page(page, queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mybatis-plus代码生成器"><a href="#Mybatis-plus代码生成器" class="headerlink" title="Mybatis-plus代码生成器"></a>Mybatis-plus代码生成器</h2><h3 id="java-sql-SQLException-No-suitable-driver-found"><a href="#java-sql-SQLException-No-suitable-driver-found" class="headerlink" title="java.sql.SQLException: No suitable driver found"></a>java.sql.SQLException: No suitable driver found</h3><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/1675689644096.jpg" alt></p><p>原因是因为mysql-connector-java依赖版本太低，或者没有导入，换成高版本即可(我这使用的是8.0.17)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还需要导入的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意和你的Mybatis-plus版本号一致--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整配置代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    String url= <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/你的数据库名称?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你的数据库用户名&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你的数据库密码&quot;</span>;<br>    FastAutoGenerator.create(url, username, password)<br>            .globalConfig(builder -&gt; &#123;<br>                builder.author(<span class="hljs-string">&quot;你的名字&quot;</span>) <span class="hljs-comment">// 设置作者</span><br>                        .fileOverride() <span class="hljs-comment">// 覆盖已生成文件</span><br>                        .outputDir(<span class="hljs-string">&quot;...\\java\\&quot;</span>); <span class="hljs-comment">// 指定输出目录</span><br>            &#125;)<br>            .packageConfig(builder -&gt; &#123;<br>                builder.parent(<span class="hljs-string">&quot;com.xx.xx&quot;</span>) <span class="hljs-comment">// 设置父包名</span><br>                        .moduleName(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 设置父包模块名 </span><br>                        .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="hljs-string">&quot;...mapper\\&quot;</span>)); <span class="hljs-comment">// 设置mapperXml生成路径 copy mapper reference</span><br>            &#125;)<br>            .strategyConfig(builder -&gt; &#123;<br>                builder.entityBuilder().enableLombok();<span class="hljs-comment">//开启Lombok</span><br>                builder.controllerBuilder().enableHyphenStyle()  <span class="hljs-comment">// 开启驼峰转连字符</span><br>                    .enableRestStyle();  <span class="hljs-comment">// 开启生成@RestController 控制器</span><br>                builder.addInclude(<span class="hljs-string">&quot;你的数据库表名&quot;</span>) <span class="hljs-comment">// 设置需要生成的表名</span><br>                        .addTablePrefix(<span class="hljs-string">&quot;t_&quot;</span>, <span class="hljs-string">&quot;b_&quot;</span>); <span class="hljs-comment">// 设置过滤表前缀</span><br>            &#125;)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完后运行main方法即可看到生成的代码框架</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/1675689725109.jpg" alt></p><h3 id="CRUD模板"><a href="#CRUD模板" class="headerlink" title="CRUD模板"></a>CRUD模板</h3><p>在mybatis-plus-generator-版本号.jar（我这里是3.5.1）</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/1675689933873.jpg" alt></p><p>选择controller.java.vm复制到resource包下的templates中</p><p>导包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><br><span class="hljs-keyword">import</span> $!&#123;<span class="hljs-keyword">package</span>.Service&#125;.$!&#123;table.serviceName&#125;;<br><span class="hljs-keyword">import</span> $&#123;<span class="hljs-keyword">package</span>.Entity&#125;.$&#123;entity&#125;;<br></code></pre></td></tr></table></figure><p>在文件最后的end下加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> $&#123;table.serviceName&#125; $&#123;table.entityPath&#125;Service;<br><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> $&#123;entity&#125; $&#123;table.entityPath&#125;)</span> &#123;<span class="hljs-comment">//保存或者更新</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.saveOrUpdate($&#123;table.entityPath&#125;);<br>        &#125;<br><br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<span class="hljs-comment">//删除</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.removeById(id);<br>        &#125;<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> List&lt;$&#123;entity&#125;&gt; findAll() &#123;<span class="hljs-comment">//查询所有</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.list();<br>        &#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> $&#123;entity&#125; findOne(<span class="hljs-meta">@PathVariable</span> Integer id) &#123;<span class="hljs-comment">//按照ID查询</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.getById(id);<br>        &#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> Page&lt;$&#123;entity&#125;&gt; findPage(<span class="hljs-meta">@RequestParam</span> Integer pageNum,<span class="hljs-comment">//分页</span><br><span class="hljs-meta">@RequestParam</span> Integer pageSize) &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum, pageSize),queryWrapper);<br>        &#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/del/batch&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Integer&gt; ids)</span> &#123;<span class="hljs-comment">//批量删除</span><br>        <span class="hljs-keyword">return</span> $&#123;table.entityPath&#125;Service.removeBatchByIds(ids);<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行之前的main方法即可生成</p><p>其他模板同理！</p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot跨域</title>
    <link href="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/"/>
    <url>/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot跨域"><a href="#SpringBoot跨域" class="headerlink" title="SpringBoot跨域"></a>SpringBoot跨域</h1><p>在前端访问后端出现跨域问题时候</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20230202115339681-16753100243391.png" alt="image-20230202115339681"></p><p>通过创建一个CorsConfig .java配置文件来解决，重启即可跨域访问，前端无需配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<br><span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br><br><span class="hljs-comment">// 当前跨域请求最大有效时长。这里默认1天</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>    corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 1 设置访问源地址，即为前端的地址</span><br>    corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 2 设置访问源请求头</span><br>    corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 3 设置访问源请求方法</span><br>    corsConfiguration.setMaxAge(MAX_AGE);<br>    source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsConfiguration); <span class="hljs-comment">// 4 对接口配置跨域设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git上传仓库</title>
    <link href="/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <url>/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Git上传到码云仓库"><a href="#使用Git上传到码云仓库" class="headerlink" title="使用Git上传到码云仓库"></a>使用Git上传到码云仓库</h1><p>在码云新建仓库后</p><p>在需要上传的文件夹右键点击Git Bush Here</p><p>git init进行初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init <br></code></pre></td></tr></table></figure><p>点击克隆，复制你仓库的HTTPS路径，输入git remote add origin + 复制路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin<br></code></pre></td></tr></table></figure><p>git pull origin master 命令，将码云上的仓库pull到本地文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></table></figure><p>git add . （. 表示所有的）或者 git add + 文件名 ，将文件保存到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></table></figure><p>git commit -m “文件描述”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m<br></code></pre></td></tr></table></figure><p>git push origin master ，推送到码云仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure><p>刷新即可</p>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Git</title>
    <link href="/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/"/>
    <url>/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/</url>
    
    <content type="html"><![CDATA[<h1 id="了解Git"><a href="#了解Git" class="headerlink" title="了解Git"></a>了解Git</h1><p>Git（读音为/gɪt/）是一个开源的<strong>分布式</strong>版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h2 id="Git和SVN区别"><a href="#Git和SVN区别" class="headerlink" title="Git和SVN区别"></a>Git和SVN区别</h2><ol><li>核心区别：Git是分布式的，SVN不是</li><li>Git按照元数据方式存储，SVN按照文件方式存储</li><li>Git分支有多种使用方法，例如：创建、切换、合并、删除、跟踪等等，SVN仅仅是另一个文件目录</li><li>Git没有全局的版本号，SVN有</li><li>xxxxxxxxxx class Solution {    public int lengthOfLongestSubstring(String s) {        if (s.length()==0) return 0;        HashMap<Character, integer> map = new HashMap<Character, integer>();        int max = 0;//最长子串长度        int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标        for(int i = 0; i &lt; s.length(); i ++){            if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。                left = Math.max(left,map.get(s.charAt(i)) + 1);       //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移            }        //map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位            map.put(s.charAt(i),i);      //再更新map中a映射的下标            max = Math.max(max,i-left+1);     //比较两个参数的大小        }        return max;            }}java </Character,></Character,></li></ol><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。 </li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h2><p>工作区：你电脑看到的目录</p><p>暂存区：一般存放在.git/index，所以又称为索引（index或者stage）</p><p>版本库：隐藏的.git目录</p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支意味着从开发主线分离出来，而且在不影响主线的情况下同时继续工作</p><p>Git分支分支实际上是指向更改快照的指针</p><p>创建分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch (branchname)<br></code></pre></td></tr></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (branchname)<br></code></pre></td></tr></table></figure><p>合并分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge <br></code></pre></td></tr></table></figure><p>列出分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><p>创建分支并且切换到该分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b (branchname)<br></code></pre></td></tr></table></figure><p>删除分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (branchname)<br></code></pre></td></tr></table></figure><p>如果合并发现冲突需要手动修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add<br>git commit<br></code></pre></td></tr></table></figure><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log //查看历史提交记录<br>git log --oneline //查看历史记录的简洁的版本<br>git log --graph //查看历史中什么时候出现了分支、合并<br>git log --reverse --oneline //逆向显示所有日志<br>git log --author //查找指定用户的提交日志<br>git blame &lt;file&gt; //以列表的形式查看指定文件的历史修改记录<br></code></pre></td></tr></table></figure><h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><p>为什么要使用标签，直接commit不好吗？</p><p>标签即为版本库的一个快照，通过添加标签，可以更加方便查找到版本号：</p><p>commit号可能是51234c…</p><p>标签可以是v1.0</p><p>当达到一个重要阶段，并且希望更加方便记住这个提交，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v1.0 //-a意为创建一个带有注解的标签，可以不加<br></code></pre></td></tr></table></figure><p>查看已有标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag<br></code></pre></td></tr></table></figure><p>删除标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d 版本号<br></code></pre></td></tr></table></figure><p>查看该标签修改的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git show 版本号<br></code></pre></td></tr></table></figure><h2 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h2><p>这是一个Git的图形界面工具（GUI），SourceTree 简化了开发者与代码仓库之间的 Git 操作方式，我们可以通过界面菜单很方便的处理 Git 操作，而不需要通过命令。</p><p>可以在 Sourcetree 官网 <a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a> 直接点击下载按钮来下载，根据提示安装。</p>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>了解Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣</title>
    <link href="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/"/>
    <url>/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20201105160612408.png" alt></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20201105160645305.png" alt></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20201105160658443.png" alt></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/image-20201105160719623.png" alt></p><p>主要是先建立2个指针，一个指针移动，一个指针返回值，通过carry表示进位，如果为1就进位，如果为0就直接返回。</p><h2 id="指针滑动窗口"><a href="#指针滑动窗口" class="headerlink" title="指针滑动窗口"></a>指针滑动窗口</h2><p>java的方法：</p><ul><li><p>```java<br>string.charAt(i)<br>//用于返回string字符串i位置的字符</p><p>HashMap<Character, integer> map = new HashMap<Character, integer>()<br>map.put(“key”,1)<br>string key=”apple”<br>boolean contains=map.containsKey(key)<br>//用于比较key值是否包含指定的值</Character,></Character,></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```java <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<span class="hljs-comment">//最长子串长度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左下标，i相当于滑动窗口右下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">containsKey</span>(s.<span class="hljs-built_in">charAt</span>(i)))&#123;<span class="hljs-comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span><br>                left = Math.<span class="hljs-built_in">max</span>(left,map.<span class="hljs-built_in">get</span>(s.<span class="hljs-built_in">charAt</span>(i)) + <span class="hljs-number">1</span>);       <span class="hljs-comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span><br>            &#125;        <span class="hljs-comment">//map.get(&#x27;a&#x27;)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span><br>            map.<span class="hljs-built_in">put</span>(s.<span class="hljs-built_in">charAt</span>(i),i);      <span class="hljs-comment">//再更新map中a映射的下标</span><br>            max = Math.<span class="hljs-built_in">max</span>(max,i-left+<span class="hljs-number">1</span>);     <span class="hljs-comment">//比较两个参数的大小</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装</title>
    <link href="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/"/>
    <url>/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h1><p>由于node版本太低，记录一下更新node</p><p>node中文下载地址：：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/12.jpg" alt></p><p>对应电脑系统选择（windows）</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/1673433881757.jpg" alt></p><p>通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">where node<br></code></pre></td></tr></table></figure><p>查看自己node安装位置</p><p><img src="/zhouyuchen/Yu-s-a/zhouyuchen/1673434014083.jpg" alt></p><p>将文件内容全部替换为压缩包内容即可</p><p>查看是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
