<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/zhouyuchen/2024/04/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="信息增益ID3"><a href="#信息增益ID3" class="headerlink" title="信息增益ID3"></a>信息增益ID3</h2><p>选择具有最高信息增益的属性作为分裂属性</p><p>假设有两个类,P和N </p><p>让样本集S包含类P的p个元素以及类N的n个元素</p><p>识别S中一个样本是否属于P或N所需要的平均信息量为<br>$$<br>I(p, n) = -\frac{p}{p + n} \log_2\left(\frac{p}{p + n}\right) - \frac{n}{p + n} \log_2\left(\frac{n}{p + n}\right)<br>$$</p><p>对于离散随机变量 ，其熵定义同下</p><p>当熵公式推广到多个类别时，其形式保持不变，只是需要对所有可能的类别进行求和。对于离散随机变量 X，如果它有 k 个不同的取值 x1,x2,…,xk，每个取值的概率分别为 p(x1),p(x2),…,p(xk)，那么熵 H(X) 的公式为<br>$$<br>H(X) = -\sum_{i=1}^{k} p(x_i) \log_2 p(x_i)<br>$$<br>例如总共有14个样本，最终结果9是，5否，带入上面公式<br>$$<br>I(9, 5) = -\frac{9}{14} \log_2\left(\frac{9}{14}\right) - \frac{5}{14} \log_2\left(\frac{5}{14}\right)=0.940<br>$$</p><hr><p><strong>例题</strong></p><p>请按照ID3决策树分类算法，采用信息增益作为节点的选择指标，筛选出基于以下训练数据所生成的决策树的根节点，请详细写出计算步骤。</p><table><thead><tr><th align="center">不浮出水面是否可以生存</th><th align="center">是否有脚璞</th><th align="center">属于鱼类</th></tr></thead><tbody><tr><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr></tbody></table><ol><li>计算未分类前的熵,总共有5个样本，是2个,否3个</li></ol><p>$$<br>熵(总)=I(2,3) = -\frac{2}{5} \log_2\left(\frac{2}{5}\right) - \frac{3}{5} \log_2\left(\frac{3}{5}\right)=0.971<br>$$</p><ol start="2"><li>分别计算按不浮出水面是否可以生存和是否有脚蹊进行分类后的信息嫡。</li></ol><p>先按不浮出水面是否可以生存进行分类：是中有2是1否；否中有0是2否<br>$$<br>熵(是否可以生存_是)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28<br>$$</p><p>$$<br>熵(是否可以生存_否)=I(2,1) = -\frac{2}{3} \log_2\left(\frac{2}{3}\right) - \frac{1}{3} \log_2\left(\frac{1}{3}\right)=0.28<br>$$</p><p>$$<br>熵(是否可以生存)=\frac{3}{5}*0.28+\frac{2}{5}*0=0.17<br>$$</p><p>$$<br>信息增益=熵(总)-熵(是否可以生存)=0.971-0.17=0.801<br>$$</p><ol start="3"><li>是否有脚蹊进行分类：是中2是2否；否中有0是1否</li></ol><p>$$<br>熵(是否可以生存_是)=I(2,2) = -\frac{2}{4} \log_2\left(\frac{2}{4}\right) - \frac{2}{4} \log_2\left(\frac{2}{4}\right)=1<br>$$</p><p>$$<br>熵(是否可以生存_否)=I(0,1) = -\frac{0}{1} \log_2\left(\frac{0}{1}\right) - \frac{1}{1} \log_2\left(\frac{1}{1}\right)=0<br>$$</p><p>$$<br>熵(是否可以生存)=\frac{4}{5}*1+\frac{1}{5}*0=0.8<br>$$</p><p>$$<br>信息增益=熵(总)-熵(是否可以生存)=0.971-0.8=0.171<br>$$</p><p>信息增益更大，区分样本的能力更强，更具有代表性,故根节点为”不浮出水面是否可以生存”</p></body></html>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender</title>
    <link href="/zhouyuchen/2023/12/03/blender/"/>
    <url>/zhouyuchen/2023/12/03/blender/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h1><p>视图控制 按住 ~   +   数字</p><p>独立显示  /</p><p>位移     G          后面可以加上xyz</p><p>旋转     R          后面可以加上xyz </p><p>缩放     S          后面可以加上xyz</p><p>编辑视图 ctrl + tab</p><p>6 编辑点线面</p><p> alt Z 透视</p><p>CTRL B 倒角 用于创作圆角</p><p>右键平滑着色可以使用插值顶点法线，网格面的边缘会变得模糊，看起来很光滑</p><p>x 删除</p><p>alt  shift 循环切割线选中</p><p>shift D 复制</p><p>扳手工具添加修改器 添加镜像，选择吸管吸取镜像中心</p><p>物体-&gt;设置原点-&gt;几何中心  设置物体旋转轴心的方式</p></body></html>]]></content>
    
    
    <categories>
      
      <category>建模工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agisoft Metashape</title>
    <link href="/zhouyuchen/2023/09/18/Metashape/"/>
    <url>/zhouyuchen/2023/09/18/Metashape/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Agisoft-Metashape等使用"><a href="#Agisoft-Metashape等使用" class="headerlink" title="Agisoft Metashape等使用"></a>Agisoft Metashape等使用</h1><h2 id="Metashape使用"><a href="#Metashape使用" class="headerlink" title="Metashape使用"></a>Metashape使用</h2><ol><li>新建项目，将图片资源拖入堆块（Chunk）中</li><li>选择工作流程（Workflow）中的对齐照片（Align Photos）可选精度，目的是为了将导入的素材形成链接点描点拼接</li><li>选择移动区域（Move Region)调整区域，排除多余的点</li><li>再次选择工作流程中创建点云（build dense cloud）再次生成深度图</li><li>形成深度图后，双击左侧工作区中点云查看</li><li>选择工作流程中的生成网格（Build Mesh）选择点云更加精细</li><li>选择工作区中的3D Model优化多余的点</li><li>选择工作流程中的生成纹理（Build Texture），可选纹理大小数量</li><li>选择文件导出模型，同时选中纹理导出</li></ol><h3 id="离散点删除"><a href="#离散点删除" class="headerlink" title="离散点删除"></a>离散点删除</h3><p>在对齐照片后通过使用自由选择或者矩形工具先将不需要的离散点删除</p><p>调整移动区域大小重新规定计算点</p><p>重置视图可以移动到中心位置</p><h2 id="Upscayl"><a href="#Upscayl" class="headerlink" title="Upscayl"></a>Upscayl</h2><ul><li><strong>REAL-ESRGAN：</strong>提高图片的清晰度；</li><li><strong>RemaCRI：</strong>增强图片效果；</li><li><strong>UltraMix Balanced：</strong>提高图片色彩饱和度；</li><li><strong>UltraSharp：</strong>提高图片清晰度和锐化边缘；</li><li><strong>Digital Art：</strong>提高颜色和纹理细节；</li><li><strong>Sharpen Image：</strong>只锐化处理；</li></ul><p>注意在系统中开启：</p><p><img src="/zhouyuchen/2023/09/18/Metashape/image-20230925112737882.png"></p><p>测试记录：</p><ol><li><p>   图片记录（5张图）</p></li><li><p>96DPI放大4倍（9600x12800，3M，10分钟）</p></li><li><p>96DPI放大8倍（12000x16000，5M，15分钟）</p></li><li><p>300DPI（2400x3200，3M，15分钟）   300DPI放大后变为（1）</p></li><li><p>   建模记录</p></li><li><pre><code class="hljs"> 5张图建模总时长在20分钟左右，DPI大，时间长</code></pre></li><li><p>   （3）点云数量多于（1，2）</p></li><li><p>   （1）和（2）建模清晰度并无太大差异  （3）清晰度低</p></li><li><p>总结</p><ol><li>   每张图优化时长在3分钟左右，</li><li>   15cm大小一面至少需要4面整体，4面细节，位置需以球面等距拍摄</li></ol></li></ol><h2 id="DOTween"><a href="#DOTween" class="headerlink" title="DOTween"></a>DOTween</h2><p><strong>解压缩</strong>到 Unity Assets 文件夹中</p><p>使用的每个类/脚本中<strong>导入 DOTween 的命名空间：</strong></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br></code></pre></td></tr></tbody></table></figure><p>初始化以设置一些全局选项，DOTween 将使用默认设置自动初始化：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">DOTween.Init(autoKillMode, useSafeMode, logBehaviour);<br></code></pre></td></tr></tbody></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><img src="/zhouyuchen/Metashape/splash_lambda.png" alt="img"></p><p><img src="/zhouyuchen/Metashape/splash_shortcuts.png" alt="img"></p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//目标点（1，1，1），时长秒</span><br>DoMove(Vector3.one, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//X,Y,Z移动</span><br>DOMoveX<br><span class="hljs-comment">//旋转</span><br>DORotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">140</span>,<span class="hljs-number">140</span>, <span class="hljs-number">140</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment">//放大</span><br>DOScale<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Metashape</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Metashape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D</title>
    <link href="/zhouyuchen/2023/09/18/Unity3D/"/>
    <url>/zhouyuchen/2023/09/18/Unity3D/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="LateUpdate和Update"><a href="#LateUpdate和Update" class="headerlink" title="LateUpdate和Update"></a>LateUpdate和Update</h2><p>两者都是每帧调用，执行顺序不同</p><p>无论有多少个update函数，都要等update函数执行完才能再执行lateupdate</p><p>Lateupdate一般放相机处理</p><p>update放画面控制逻辑</p><p>update在渲染每一帧的时候调用。但是fixupdate一般是在固定的时间频率调用。这个时间不一定是每一帧的时间。</p><h2 id="光影"><a href="#光影" class="headerlink" title="光影"></a>光影</h2><p>区域光（Area）烘焙后相当于生成一张贴图，可以删除光源</p><p>烘焙光对一般动态物体没有影响</p><h3 id="体积雾学习笔记"><a href="#体积雾学习笔记" class="headerlink" title="体积雾学习笔记"></a>体积雾学习笔记</h3><p>Volumetric Fog放在camera下</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Unity3D</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#</title>
    <link href="/zhouyuchen/2023/06/01/C#/"/>
    <url>/zhouyuchen/2023/06/01/C#/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="C-学习入门"><a href="#C-学习入门" class="headerlink" title="C#学习入门"></a>C#学习入门</h1><h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h3><p>C# 是在 .Net 框架开发期间开发的。</p><p>C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。</p><ul><li>现代的、通用的编程语言。</li><li>面向对象。</li><li>面向组件。</li><li>容易学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以在多种计算机平台上编译。</li><li>.Net 框架的一部分。</li></ul><p>主要功能：</p><ul><li>布尔条件（Boolean Conditions）</li><li>自动垃圾回收（Automatic Garbage Collection）</li><li>标准库（Standard Library）</li><li>组件版本（Assembly Versioning）</li><li>属性（Properties）和事件（Events）</li><li><strong>委托（Delegates）和事件管理（Events Management）</strong></li><li>易于使用的泛型（Generics）</li><li>索引器（Indexers）</li><li>条件编译（Conditional Compilation）</li><li>简单的多线程（Multithreading）</li><li>LINQ 和 Lambda 表达式</li><li>集成 Windows</li></ul><p>注意以下几点：</p><ul><li>C# 是大小写敏感的。</li><li>所有的语句和表达式必须以分号（;）结尾。</li><li>程序的执行从 Main 方法开始。</li><li>与 Java 不同的是，文件名可以不同于类的名称。</li></ul><h3 id="与C不同的基本语法"><a href="#与C不同的基本语法" class="headerlink" title="与C不同的基本语法"></a>与C不同的基本语法</h3><h4 id="using-关键字"><a href="#using-关键字" class="headerlink" title="using 关键字"></a><em>using</em> 关键字</h4><p>在任何 C# 程序中的第一条语句都是：</p><p>由于使用 <code>using</code> 指令，因此程序可以使用 <code>Console.WriteLine</code> 作为 <code>System.Console.WriteLine</code> 的简写。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<span class="hljs-comment">//一个程序可以包含多个using语句</span><br></code></pre></td></tr></tbody></table></figure><h4 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h4><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System -  CTS）中所有数据类型的终极基类。Object 是 System.Object  类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><h4 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h4><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> &lt;variable_name&gt; = <span class="hljs-keyword">value</span>;<br></code></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">20</span>;<br></code></pre></td></tr></tbody></table></figure><h4 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h4><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">String str = <span class="hljs-string">"runoob.com"</span>;<br></code></pre></td></tr></tbody></table></figure><p>一个 @引号字符串：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-string">@"runoob.com"</span>;<br></code></pre></td></tr></tbody></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@"C:\Windows"</span>;<br></code></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">"C:\\Windows"</span>;<br></code></pre></td></tr></tbody></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> str = <span class="hljs-string">@"&lt;script type=""text/javascript""&gt;</span><br><span class="hljs-string">    &lt;!--</span><br><span class="hljs-string">    --&gt;</span><br><span class="hljs-string">&lt;/script&gt;"</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C#类型转换"></a>C#类型转换</h3><p>C#类型转换与C很类似，隐式转换和显示转换（强转）</p><p><a href="https://www.runoob.com/csharp/csharp-type-conversion.html">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C#变量"></a>C#变量</h3><h4 id="接受来自用户的值"><a href="#接受来自用户的值" class="headerlink" title="接受来自用户的值"></a>接受来自用户的值</h4><p><strong>System</strong> 命名空间中的 <strong>Console</strong> 类提供了一个函数 **ReadLine()**，用于接收来自用户的输入，并把它存储到一个变量中。</p><p>例如：</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> num;<br>num = Convert.ToInt32(Console.ReadLine());<br></code></pre></td></tr></tbody></table></figure><p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p><h3 id="C-常量运算符与C类似"><a href="#C-常量运算符与C类似" class="headerlink" title="C#常量运算符与C类似"></a>C#常量运算符与C类似</h3><p>需要注意的是</p><p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr><tr><td>? :</td><td>条件表达式</td><td>如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td>is</td><td>判断对象是否为某一类型。</td><td>If( Ford is Car)  // 检查 Ford 是否是 Car 类的一个对象。</td></tr><tr><td>as</td><td>强制转换，即使转换失败也不会抛出异常。</td><td>Object obj = new StringReader(“Hello”);      StringReader r = obj as StringReader;</td></tr></tbody></table><h3 id="C-封装"><a href="#C-封装" class="headerlink" title="C#封装"></a>C#封装</h3><p>internal：同一个程序集的对象可以访问；</p><p>protected internal：访问限于当前程序集或派生自包含类的类型。也就是包括protected 和 internal</p><p><img src="/zhouyuchen/2023/06/01/C#/image-20230712222252009.png"></p><h3 id="C-方法"><a href="#C-方法" class="headerlink" title="C#方法"></a>C#方法</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)<br>{<br>   Method Body<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</p><p><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</p><p><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</p><p><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</p><p><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>{<br>    <span class="hljs-comment">//方法主体</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="C-中调用方法"><a href="#C-中调用方法" class="headerlink" title="C# 中调用方法"></a>C# 中调用方法</h4><p>通过方法名调用</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全</p><p>即使在函数内改变了值，值也没有发生任何的变化。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>{<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>    {<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMax</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num1, <span class="hljs-built_in">int</span> num2</span>)</span><br>        {...}<br>    }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    {<br>        ...<br>        <span class="hljs-built_in">int</span> ret;<br>        <span class="hljs-comment">//调用 FindMax 方法</span><br>        ret = n.FindMax(a, b);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">CalculatorApplication</span><br>{<br>&nbsp; &nbsp;<span class="hljs-keyword">class</span> <span class="hljs-title">NumberManipulator</span><br>&nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<br>&nbsp; &nbsp; &nbsp; }&nbsp; <br>&nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.swap(a, b);<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp;}<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h4><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br></code></pre></td></tr></tbody></table></figure><h4 id="按输出传递参数"><a href="#按输出传递参数" class="headerlink" title="按输出传递参数"></a>按输出传递参数</h4><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NumberManipulator n = <span class="hljs-keyword">new</span> NumberManipulator();<br> ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">/* 调用函数 */</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n.getValue(<span class="hljs-keyword">out</span> a)<br>         ...<br>&nbsp; &nbsp; &nbsp; }<br></code></pre></td></tr></tbody></table></figure><p>通过用户输入值再输出</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> y </span>)</span><br>      {<br>          Console.WriteLine(<span class="hljs-string">"请输入第一个值： "</span>);<br>          x = Convert.ToInt32(Console.ReadLine());<br>          Console.WriteLine(<span class="hljs-string">"请输入第二个值： "</span>);<br>          y = Convert.ToInt32(Console.ReadLine());<br>      }<br></code></pre></td></tr></tbody></table></figure><h3 id="C-可空类型（Nullable）"><a href="#C-可空类型（Nullable）" class="headerlink" title="C# 可空类型（Nullable）"></a>C# 可空类型（Nullable）</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i; <span class="hljs-comment">//默认值0</span><br><span class="hljs-built_in">int</span>? ii; <span class="hljs-comment">//默认值nul</span><br></code></pre></td></tr></tbody></table></figure><h4 id="Null-合并运算符（-）"><a href="#Null-合并运算符（-）" class="headerlink" title="Null 合并运算符（ ?? ）"></a>Null 合并运算符（ ?? ）</h4><p>如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br></code></pre></td></tr></tbody></table></figure><h4 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 <em>foreach</em> 循环</h4><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/* 初始化数组 n 中的元素 */</span>        <br><span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ )<br>{<br>   n[i] = i + <span class="hljs-number">100</span>;<br>}<br><span class="hljs-comment">/* 输出每个数组元素的值 */</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> j <span class="hljs-keyword">in</span> n )<br>{<br>   <span class="hljs-built_in">int</span> i = j<span class="hljs-number">-100</span>;<br>   Console.WriteLine(<span class="hljs-string">"Element[{0}] = {1}"</span>, i, j);<br>}<br></code></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs result">Element[0] = 100<br>Element[1] = 101<br>Element[2] = 102<br>...<br></code></pre></td></tr></tbody></table></figure><h3 id="C-字符串（String）"><a href="#C-字符串（String）" class="headerlink" title="C# 字符串（String）"></a>C# 字符串（String）</h3><h4 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h4><p>String 类有以下两个属性：</p><table><thead><tr><th>序号</th><th>属性名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td>2</td><td><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table><h4 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h4><table><thead><tr><th>序号</th><th>方法名称 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>public static int Compare( string strA, string strB )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。该方法区分大小写。</td></tr><tr><td>2</td><td><strong>public static int Compare( string strA, string strB, bool ignoreCase )</strong>  比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数。但是，如果布尔参数为真时，该方法不区分大小写。</td></tr><tr><td>3</td><td><strong>public static string Concat( string str0, string str1 )</strong>  连接两个 string 对象。</td></tr><tr><td>4</td><td><strong>public static string Concat( string str0, string str1, string str2 )</strong>  连接三个 string 对象。</td></tr><tr><td>5</td><td><strong>public static string Concat( string str0, string str1, string str2, string str3 )</strong>  连接四个 string 对象。</td></tr><tr><td>6</td><td><strong>public bool Contains( string value )</strong>  返回一个表示指定 string 对象是否出现在字符串中的值。</td></tr><tr><td>7</td><td><strong>public static string Copy( string str )</strong>  创建一个与指定字符串具有相同值的新的 String 对象。</td></tr><tr><td>8</td><td><strong>public void CopyTo( int sourceIndex, char[] destination, int destinationIndex, int count )</strong>  从 string 对象的指定位置开始复制指定数量的字符到 Unicode 字符数组中的指定位置。</td></tr><tr><td>9</td><td><strong>public bool EndsWith( string value )</strong>  判断 string 对象的结尾是否匹配指定的字符串。</td></tr><tr><td>10</td><td><strong>public bool Equals( string value )</strong>  判断当前的 string 对象是否与指定的 string 对象具有相同的值。</td></tr><tr><td>11</td><td><strong>public static bool Equals( string a, string b )</strong>  判断两个指定的 string 对象是否具有相同的值。</td></tr><tr><td>12</td><td><strong>public static string Format( string format, Object arg0 )</strong>  把指定字符串中一个或多个格式项替换为指定对象的字符串表示形式。</td></tr><tr><td>13</td><td><strong>public int IndexOf( char value )</strong>  返回指定 Unicode 字符在当前字符串中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>14</td><td><strong>public int IndexOf( string value )</strong>  返回指定字符串在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>15</td><td><strong>public int IndexOf( char value, int startIndex )</strong>  返回指定 Unicode 字符从该字符串中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>16</td><td><strong>public int IndexOf( string value, int startIndex )</strong>  返回指定字符串从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>17</td><td><strong>public int IndexOfAny( char[] anyOf )</strong>  返回某一个指定的 Unicode 字符数组中任意字符在该实例中第一次出现的索引，索引从 0 开始。</td></tr><tr><td>18</td><td><strong>public int IndexOfAny( char[] anyOf, int startIndex )</strong>  返回某一个指定的 Unicode 字符数组中任意字符从该实例中指定字符位置开始搜索第一次出现的索引，索引从 0 开始。</td></tr><tr><td>19</td><td><strong>public string Insert( int startIndex, string value )</strong>  返回一个新的字符串，其中，指定的字符串被插入在当前 string 对象的指定索引位置。</td></tr><tr><td>20</td><td><strong>public static bool IsNullOrEmpty( string value )</strong>  指示指定的字符串是否为 null 或者是否为一个空的字符串。</td></tr><tr><td>21</td><td><strong>public static string Join( string separator,        string[] value )</strong>  连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>22</td><td><strong>public static string Join( string separator, string[] value, int startIndex, int count )</strong>  连接一个字符串数组中的指定位置开始的指定元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td>23</td><td><strong>public int LastIndexOf( char value )</strong>  返回指定 Unicode 字符在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>24</td><td><strong>public int LastIndexOf( string value )</strong>  返回指定字符串在当前 string 对象中最后一次出现的索引位置，索引从 0 开始。</td></tr><tr><td>25</td><td><strong>public string Remove( int startIndex )</strong>  移除当前实例中的所有字符，从指定位置开始，一直到最后一个位置为止，并返回字符串。</td></tr><tr><td>26</td><td><strong>public string Remove( int startIndex, int count )</strong>  从当前字符串的指定位置开始移除指定数量的字符，并返回字符串。</td></tr><tr><td>27</td><td><strong>public string Replace( char oldChar, char newChar )</strong>  把当前 string 对象中，所有指定的 Unicode 字符替换为另一个指定的 Unicode 字符，并返回新的字符串。</td></tr><tr><td>28</td><td><strong>public string Replace( string oldValue, string newValue )</strong>  把当前 string 对象中，所有指定的字符串替换为另一个指定的字符串，并返回新的字符串。</td></tr><tr><td>29</td><td><strong>public string[] Split( params char[] separator )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。</td></tr><tr><td>30</td><td><strong>public string[] Split( char[] separator, int count )</strong>  返回一个字符串数组，包含当前的 string 对象中的子字符串，子字符串是使用指定的 Unicode 字符数组中的元素进行分隔的。int 参数指定要返回的子字符串的最大数目。</td></tr><tr><td>31</td><td><strong>public bool StartsWith( string value )</strong>  判断字符串实例的开头是否匹配指定的字符串。</td></tr><tr><td>32</td><td><strong>public char[] ToCharArray()</strong> 返回一个带有当前 string 对象中所有字符的 Unicode 字符数组。</td></tr><tr><td>33</td><td><strong>public char[] ToCharArray( int startIndex, int length )</strong>  返回一个带有当前 string 对象中所有字符的 Unicode 字符数组，从指定的索引开始，直到指定的长度为止。</td></tr><tr><td>34</td><td><strong>public string ToLower()</strong> 把字符串转换为小写并返回。</td></tr><tr><td>35</td><td><strong>public string ToUpper()</strong> 把字符串转换为大写并返回。</td></tr><tr><td>36</td><td><strong>public string Trim()</strong> 移除当前 String 对象中的所有前导空白字符和后置空白字符。</td></tr></tbody></table><p>完整方法参考MSDN库</p><p>C# 结构体、枚举、类与C相同不再赘述</p><p>类的继承以  子类 ：父类 方式继承</p><p>多重继承以  子类：父类，父类  方式继承</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><img src="/zhouyuchen/C#/image-20240311201304749.png"></p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> counter;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>{<br>    StartCoroutine(<span class="hljs-string">"myCoroutine"</span>);<br>    print(<span class="hljs-string">"end"</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>{<br>    <span class="hljs-keyword">if</span> (counter &lt; <span class="hljs-number">10</span>)<br>        print(<span class="hljs-string">"帧数："</span> + counter++);<br><br>}<br><span class="hljs-function">IEnumerator <span class="hljs-title">myCoroutine</span>()</span><br>{<br>    print(<span class="hljs-string">"步骤1"</span>);<br>    <span class="hljs-comment">// 挂起，控制权返回原来的语句,直到下一帧,逐帧动态</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <br>    print(<span class="hljs-string">"步骤2"</span>);<br>    print(<span class="hljs-string">"步骤3"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/zhouyuchen/C#/image-20240311210341910.png"></p><p><img src="/zhouyuchen/C#/image-20240311211543512.png"></p><h2 id="c-快捷键"><a href="#c-快捷键" class="headerlink" title="c#快捷键"></a>c#快捷键</h2><ul><li>快速对齐：ctrl+Ｋ + D<br>快速弹出智能提示：ctrl + J<br>快速注释：ctrl +K+C<br>取消所选的注释：ctrl + K+ U<br>折叠冗余代码：#region 和 #endregion<br><strong>输入svm然后按Tab键会生成Main函数；</strong><br>ctrl+K+S 三个键一起按，会调出代码段；选中多行后，然后按以上三个快捷键，按下Tab，代码段会自动包括选中代码，就可以进行相关的操作。比如加上region等。<br> 单行选中： Shift+Home：选中当前坐标到行首的代码；Shift+End选中当前坐标到行尾的代码；<br>折叠代码：ctrl+M + O，用来查看代码结构是否规整。<br>展开折叠代码： ctrl + M + L<br>展开或折叠光标所在的的代码块：ctrl + M+ M<br>转到定义：F12<br>F7 从设计界面切转到后台代码。Shift+F7 从后台代码切换到设计界面。<br>自动给字段加属性，封装属性的快捷键：Ctrl+R+E。<br>删除整行：ctrl + L<br>F9 添加、消除断点；Shift+Ctrl+F9取消所有断点。</li><li><strong>复制当前行 ctrl D</strong></li></ul></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU</title>
    <link href="/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/"/>
    <url>/zhouyuchen/2023/04/14/GPU%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>GPU（Graphics Processing Unit）图形处理器与CPU（Central Processing Unit）相比具有：</p><ol><li>高并行结构，因此在处理图形数据和复杂算法效率更高</li><li>更多的ALU（Arithmetic Logical Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，适合对密集型数据并行处理</li><li>CPU执行计算时是时间片轮转算法，GPU具有多个处理器核，在一个时刻可以并行处理多个数据 </li><li>流式并行计算模式，对每个数据进行独立计算，任意元素不依赖其他同类元素</li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>GPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希算法</title>
    <link href="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><strong>哈希算法</strong>（Hash 算法，散列算法，消息摘要算法）将任意长度的二进制值映射为较短的固定长度的二进制值 ，这个小的二进制值称为哈希值。</p><p>简单来说就是通过哈希值快速定位到想要查找的记录，而不是通过表中存放的关键字来比较查找。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>哈希表是根据设定的哈希函数和处理冲突方法将<strong>一组关键字</strong>映射到<strong>一个有限的地址区间</strong>上，作为记录在表中的<strong>存储位置</strong>，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</li><li>通过将哈希算法应用到<strong>任意数量</strong>的数据会得到的<strong>固定大小</strong>的结果。如果输入数据中有变化，则哈希也会发生变化。哈希可用于许多操作，包括身份验证和数字签名。也称为“消息摘要”。</li><li>它是一种<strong>单向密码体制</strong>,即它是一个从明文到密文的不可逆的映射。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。</li><li>是一种基于Hash函数的文件构造方法，可对记录快速随机存取。把任意长关键字映射为一个固定长度的哈希值，一 般用于鉴权、认证、加密、索引等。其主要优点是<strong>运算简单</strong>，<strong>预处理时间较短</strong>，<strong>内存消耗低</strong>，匹配查找<strong>速度快</strong>，便于维护和刷新，支持匹配规则数多等。</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>如果对一个字符串数组进行查询。最快的检索办法是通过数组的下标进行检索，但是对于这种场景，只能从头查到尾，从而查询出目标元素。因此最坏情况下时间复杂度为O(n)，但是使用Hash可以将时间复杂度降为O(1)。</p><p>Hash表采用一个映射函数 function: key -&gt; address 将关键字映射到该记录在表中的存储位置，在想要查找该记录时，可以直接根据关键字和<strong>映射关系</strong>计算出该记录在表中的存储位置，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置（存储位置只是表中的存储位置，并不是实际的物理地址）称作为<strong>Hash地址</strong>。</p><p>比如上述例子中，假如字符串数组采用Hash表存储，则当想要找到字符串对应的信息时，直接根据字符串和Hash函数计算出 Hash 地址即可。所谓的 Hash 算法就是将字符串转换为数字的算法。例如我们可以将字符串数组的各个字符的ASCII码计算出，作为Hash表的地址，当需要哪个字符串时候就根据数字之间查找出，当然这是最笨的Hash算法。</p><h2 id="Hash函数设计"><a href="#Hash函数设计" class="headerlink" title="Hash函数设计"></a>Hash函数设计</h2><ol><li>直接定址法</li></ol><p>取关键字或者关键字的某个线性函数为 Hash 地址，即address(key) = a * key + b; 如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000(其中a = 1)作为Hash地址。</p><ol start="2"><li>平方取中法</li></ol><p>对关键字进行平方计算，取结果的中间几位作为 Hash 地址。如有以下关键字序列 {421，423，436} ，平方之后的结果为 {177241，178929，190096} ，那么可以取中间的两位数 {72，89，00} 作为 Hash 地址。</p><ol start="3"><li>折叠法</li></ol><p>将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。如图书的 ISBN 号为 8903-241-23，可以将address(key)=89+03+24+12+3 作为 Hash 地址。</p><ol start="4"><li>除留取余法</li></ol><p>如果知道 Hash 表的最大长度为 m，可以取不大于m的最大质数 p，然后对关键字进行取余运算，address(key)=key % p。这里 p 的选取非常关键，p 选择的好的话，能够最大程度地减少冲突，p 一般取不大于m的最大质数。</p><ol start="5"><li>基数转换法</li></ol><p>将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中若干为作为X的哈希值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。</p><ol start="6"><li>随机数法</li></ol><p>设定哈希函数为:H(key)=Random(key)其中，Random为伪随机函数</p><p>此法适于：对长度不等的关键字构造哈希函数。</p><ol start="7"><li>字符串数值哈希法</li></ol><p>把字符串的前10个字符的ASCⅡ值之和对N取摸作为Hash地址，只要N较小，Hash地址将较均匀分布[0，N]区间内。对于N很大的情形，可使用ELFHash(ExecutableandLinkingFormat,ELF,可执行链接格式)函数，它把一个字符串的绝对长度作为输入，并通过一种方式把字符的十进制值结合起来，对长字符串和短字符串都有效，这种方式产生的位置可能不均匀分布。</p><ol start="8"><li>旋转法</li></ol><p>旋转法是将数据的键值中进行旋转。旋转法通常并不直接使用在哈希函数上，而是搭配其他哈希函数使用。</p><h2 id="Hash-冲突及解决方案"><a href="#Hash-冲突及解决方案" class="headerlink" title="Hash 冲突及解决方案"></a>Hash 冲突及解决方案</h2><p>因为我们是用字符串数组对哈希值进行定值，有可能不同键值所得到的索引值相同，这里就是冲突。如不同的字符串可能ASCII总和是相同的，显然出现的这种情况是不合理的，解决该冲突的方法就是改变数据结构。我们将数组内的元素改变为一个链表，这样就能容下足够多的元素了，冲突问题也能得到解决。具体如何解决请看下面的链地址法。</p><ol><li>开放定址法</li></ol><p>发生冲突时，使用某种探测技术在 Hash 表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash 表长为14，Hash 函数为 address(key) = key % 11，当插入12，13，25时可以直接插入，而当插入 23 时，地址 1 被占用了（因为 12%11 和 23%11 的结果相同）。此时沿着地址 1 依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将 23 插入其中。</p><ol start="2"><li>链地址法</li></ol><p>采用数组和链表相结合的数据结构，将 Hash 地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。如下图最左边是数组结构，数组内的元素为链表结构。</p><p><img src="/zhouyuchen/2023/02/15/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20230330224717657.png"></p><h2 id="Hash-表的用处以及优劣"><a href="#Hash-表的用处以及优劣" class="headerlink" title="Hash 表的用处以及优劣"></a>Hash 表的用处以及优劣</h2><ol><li>找出两文件找出重复的元素</li></ol><p>假设有两个文件，文件中均包含一些短字符串，字符串个数分别为n。它们是有重复的字符串，现在需要找出所有重复的字符串。</p><p>最笨的解决办法可能是：遍历文件 1 中的每个元素，取出每一个元素分别去文件 2 中进行查找，这样的时间复杂度为O（n^2）。</p><p>但是借助 Hash 表可以有一种相对巧妙的方法，分别遍历文件 1 中的元素和文件 2 中的元素，然后放入 Hash Table 中，对于遍历的每一个元素我们只要简单的做一下计数处理即可。最后遍历整个 Hash 列表，找出所有个数大于 1 的元素即为重复的元素。</p><ol start="2"><li>找出两文件找出出现次数最多的元素</li></ol><p>同找出两文件找出重复的元素这样的问题解决方案类似，只是在最后遍历的时找计数最大的元素，即为出现次数最多的元素。</p><ol start="3"><li>路由算法</li></ol><p>多线程处理数据的场景下，通常需要将一个数据集分给不同的线程进行处理，同时要保证，相同的元素需要分到相同的处理线程上。这其实这个就是一个很典型的 Hash 值应用场景，对于很多的计算引擎默认都是用 Hash 算法去解决这个问题。因为相同元素的 Hash 值相同，那么我们可以取 Hash 之后进行模运算，运算结果分配到不同的线程。</p><p>优点</p><p>哈希表的效率非常高，查找、插入、删除操作只需要接近常量的时间即0(1）的时间级。如果需要在一秒种内查找上千条记录通常使用哈希表，哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。如果不需要遍历数据，不二的选择。</p><p>缺点</p><p>它是基于数组的，数组创建后难于扩展。有些情况下，哈希表被基本填满时，性能下降得非常严重，所以开发者必须要清楚表中将要存储的数据量。或者也可以定期地把数据转移到更大的哈希表中，不过这个过程耗时相对比较大。</p><p>注意点</p><p>在设计Hash算法的时候。一定要保证相同字符串产生的 Hash 值相同，同时要尽量的减小Hash冲突的发生，这样才算是好的 hash 算法。</p><h2 id="哈希加盐"><a href="#哈希加盐" class="headerlink" title="哈希加盐"></a>哈希加盐</h2><p>我们知道，系统保存用户的密码时，一般不会直接保存下密码，而是通过md5加密后保存；</p><p>md5加密原理：Orz</p><p>md5已经是一种十分安全的加密方法了，但是通过彩虹表依旧可以破解（彩虹表原理），那么我们伟大机智的程序员们就想出了在密码后加一段序列然后再md5加密的方法，这个后面加上的序列就是所谓的 “ 盐 ” 。</p><p>具体的流程是：</p><p>用户注册时：</p><ol><li><p>用户在网站注册时提供ID与口令</p></li><li><p>系统随机为用户分配盐值</p></li><li><p>盐值插入口令后进行hash</p></li><li><p>将ID，hash值与盐值存入数据库</p></li></ol><p>身份验证时：</p><ol><li><p>用户提供ID与口令</p></li><li><p>系统在数据库中通过用户提供的ID查找HASH值与盐值</p></li><li><p>将盐值插入用户提供的口令后进行HASH</p></li><li><p>将HASH值与数据库中的HASH值比较，相等则验证成功，反之验证失败</p></li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache</title>
    <link href="/zhouyuchen/2023/02/08/Cache/"/>
    <url>/zhouyuchen/2023/02/08/Cache/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>CPU的运行速度是远远高于读写内存速度的，以当前嵌入式普遍使用的mcu来说，主频也普遍在几百Mhz，但是要知道使用的主存储器使用的动态存储器（DRAM）其存储速度在10Mhz左右。这样，如果指令和数据都存储在主存储器中，内存的速度会严重制约整个系统的性能。因此，为了解决内存速度低下，Cache就被引入了。可以说 Cache 是连接 CPU 和内存的桥梁。 </p><p>Cache全部是由硬件实现的，其不仅对于应用程序员是透明的，对系统程序员也是透明的，其是由速度与cpu速度相近的SRAM构成（Cahce和内存都是用的SRAM，那么速度为什么不同这是因为离CPU距离不同越近总线读写速度越快）。现在的处理器一般是通过多级缓存的组织形式来达到性能和功能的最优。但是其实对于多级cache还是一级cache，其原理是一致的，了解其原理后，多级和一级没有什么功能上的差异。</p><h2 id="Cache功能"><a href="#Cache功能" class="headerlink" title="Cache功能"></a>Cache功能</h2><p>cache是一种<strong>高速缓冲存储器</strong>，是为了解决CPU和主存之间速度不匹配而采用的一项重要技术</p><h2 id="Cache原理"><a href="#Cache原理" class="headerlink" title="Cache原理"></a>Cache原理</h2><p>cache原理是基于程序运行中具有的<strong>空间</strong>局限性和<strong>时间</strong>局限性特征。</p><p>空间局限性：在最近的未来要用到的信息(指令和数据)，很有可能与现在正在使用的信息在存储空间上是邻近的，如：数组元素、顺序执行的指令代码</p><p>时间局限性：在最近的未来要用到的信息，很可能是现在正在使用的信息，  如：循环结构的指令代码</p><p>基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放在Cache中</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/zhouyuchen/2023/02/02/Redis/"/>
    <url>/zhouyuchen/2023/02/02/Redis/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是C语言开发的一个开源高性能键值对的<strong>内存数据库</strong>，可以用来做数据库、缓存、消息中间件等场景，是一种NoSQL(not-only sql,非关系型数据库)的数据库。</p><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>优秀的性能，数据是存储在内存中，读写速度非常快，可支持并发10W QPS(一般指每秒查询率)</li><li>单线程但进程，是线程安全的，采用IO 多路复用制</li><li>可作为分布式锁</li><li>支持五种数据类型</li><li>支持数据持久化到磁盘</li><li>可以作为消息中间件使用，支持消息发布及订阅</li></ul><h2 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h2><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。       </li></ul><h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>每个 hash 可以存储 23^2 -1 键值对（40多亿）。</p><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表最多可存储  23^2 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis  zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><table><thead><tr><th align="center">类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td align="center">String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td align="center">Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td align="center">List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td align="center">Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td align="center">Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><p>Redis中文文档链接: <a href="http://www.redis.cn/documentation.html">http://www.redis.cn/documentation.html</a></p><p>Redis英文文档 <a href="https://redis.io/topics/data-types">https://redis.io/topics/data-types</a></p><p>Redis官网:<a href="http://redis.io/">http://redis.io/</a></p><p>Redis官方文档:<a href="http://redis.io/documentation">http://redis.io/documentation</a></p></body></html>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是冒泡排序的改进，之所以快速是由于运用了<strong>分治法</strong></p><p>主要思路：</p><ol><li>选择一个数为基准点</li><li>从左往右，将数与基准点相比较，同时从右往左将数与基准点相比较</li><li>当左边的数比基准点大时，同时右边的数比基准点小时，把两数交换</li><li>此时左边的数都小于基准点，右边的数都大于基准点。此时以基准点拆分成2队，重复执行步骤2，3，4</li></ol><p>如下是<strong>一次快排</strong>图解，选用了中点（pivot）作为基准点</p><p>xxxxxxxxxx&nbsp;class Solution { &nbsp; &nbsp;public int lengthOfLongestSubstring(String s) { &nbsp; &nbsp; &nbsp; &nbsp;if (s.length()==0) return 0; &nbsp; &nbsp; &nbsp; &nbsp;HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); &nbsp; &nbsp; &nbsp; &nbsp;int max = 0;//最长子串长度 &nbsp; &nbsp; &nbsp; &nbsp;int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标 &nbsp; &nbsp; &nbsp; &nbsp;for(int i = 0; i &lt; s.length(); i ++){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left = Math.max(left,map.get(s.charAt(i)) + 1); &nbsp; &nbsp; &nbsp; //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;//map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;map.put(s.charAt(i),i); &nbsp; &nbsp; &nbsp;//再更新map中a映射的下标 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max = Math.max(max,i-left+1); &nbsp; &nbsp; //比较两个参数的大小 &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;return max; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }}java </p><p>下面用个简单的实例说明：</p><p><img src="/zhouyuchen/2023/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image-20230317124246696.png"></p><p>这是以20作为了基准点，进行一次快排的过程</p><p>之后以20为基准点分为左右两队再进行快排便可以得到结果。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>{<br>    <span class="hljs-type">int</span> i = left, j = right;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-comment">// 基准点</span><br>    <span class="hljs-type">int</span> pivot;<br><br>    pivot = arr[(i + j) / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">while</span> (i &lt;= j)<br>    {<br>        <span class="hljs-comment">// 从左到右边找到大于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[i] &lt; pivot)<br>        {<br>            i++;<br>        }<br>        <span class="hljs-comment">// 从右到左边找到小于等于基准点的元素</span><br>        <span class="hljs-keyword">while</span> (arr[j] &gt; pivot)<br>        {<br>            j--;<br>        }<br>        <span class="hljs-comment">// 如果i&lt;=j则互换元素</span><br>        <span class="hljs-keyword">if</span> (i &lt;= j)<br>        {<br>            temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            i++;<br>            j--;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (left &lt; j)<br>    {<br>        quick_sort(arr, left, j);<br>    }<br>    <span class="hljs-keyword">if</span> (i &lt; right)<br>    {<br>        quick_sort(arr, i, right);<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> arr[] = {<span class="hljs-number">21</span>, <span class="hljs-number">2</span>, <span class="hljs-number">25</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>};<br>    <span class="hljs-type">int</span> i, len;<br>    len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    quick_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i]);<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔</title>
    <link href="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>经典递归问题：汉诺塔</p><p>汉诺塔的本质（x，y，z三根柱）：</p><ol><li>将n-1层从x移动到y</li><li>将第n层从x移动到z</li><li>将n-1层从y移动到z    </li></ol><p>三步解决</p><p>因此用递归的方法，只需考虑2层时候的代码（把第一层看作是n-1层，第二层看作是n层）</p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(1).png"></p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(2).png"></p><p><img src="/zhouyuchen/2023/01/15/%E6%B1%89%E8%AF%BA%E5%A1%94/(3).png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span><br>{<br>    <span class="hljs-comment">//判断n的层数，如果为一层直接移动x到z</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c ---&gt;  %c\n"</span>, x, z);<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<span class="hljs-comment">//当n！=1时候，将再次调用函数，移动n-1层：x到y，也就是把y和z互换</span><br>        hanoi(n - <span class="hljs-number">1</span>, x, z, y);<br>        <span class="hljs-comment">//移动第n层：x到z</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c ---&gt;  %c\n"</span>, x, z);<br>        <span class="hljs-comment">//最后移动n-层：y到z</span><br>        hanoi(n - <span class="hljs-number">1</span>, y, x, z);<br>    }<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"请输入汉诺塔的层数：\n"</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);<br>    hanoi(n, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汉诺塔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git问题记录</title>
    <link href="/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2023/01/04/Git%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="Git问题记录"><a href="#Git问题记录" class="headerlink" title="Git问题记录"></a>Git问题记录</h1><p>本文章记录使用Git遇到的问题，方便以后的查阅解决</p><h2 id="撤消尚未推送的Git合并"><a href="#撤消尚未推送的Git合并" class="headerlink" title="撤消尚未推送的Git合并"></a>撤消尚未推送的Git合并</h2><p>通过git-reset - 重置当前HEAD到指定的状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard <br>git reset --hard ORIG_HEAD<br>git reset --merge ORIG_HEAD<br></code></pre></td></tr></tbody></table></figure><ol><li>没有进行合并提交，所以<code>git reset --hard</code>是<code>git reset --hard HEAD</code>的同义词，它清除了索引文件和工作树上的混乱。</li><li>“pull “或 “merge “总是在<code>ORIG_HEAD</code>中留下当前分支的原始提示，所以硬重置到它会使你的索引文件和工作树回到那个状态，并将分支的提示重置到那个提交。</li><li>在检查了合并的结果后，你可能会发现另一个分支的修改不尽人意。 运行<code>git reset --hard ORIG_HEAD</code>可以让你回到原来的位置，但它会丢弃你的本地修改，这是你不想要的。 <code>git reset --merge</code>会保留你的本地修改。</li></ol><h2 id="恢复已经删除的提交"><a href="#恢复已经删除的提交" class="headerlink" title="恢复已经删除的提交"></a>恢复已经删除的提交</h2><p>当需要恢复已经删除的提交记录时候</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br>git rest --hard commitID<br>git push origin HEAD --force<br></code></pre></td></tr></tbody></table></figure><ol><li>通过reflog找到删除的提交的ID</li><li>执行上述命令，加上提交的ID即可恢复</li><li>本地退回后强制推送到远程仓库</li></ol></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/zhouyuchen/2023/01/02/React/"/>
    <url>/zhouyuchen/2023/01/02/React/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>这篇博客是记录我react入门学习笔记，供我自己参考。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>React：用于构建用户界面的JavaScript库（将数据渲染为HTML视图的JS库）</p><h3 id="为什么要学"><a href="#为什么要学" class="headerlink" title="为什么要学"></a>为什么要学</h3><ol><li>原生JS操作DOM繁琐，效率低。</li><li>原生JS操作DOM会使浏览器大量重绘重排。</li><li>原生JS没有组件化的编码方案，代码复用率低。</li></ol><p>React特点：</p><ol><li>采用组件化模式，<strong>声明式编码</strong>，提高开发效率和组件复用率。</li><li>React Native 中可以使用React语法进行<strong>移动端开发</strong></li><li>使用<strong>虚拟DOM</strong>和优秀的<strong>Diffing算法</strong>，尽量减少与真实DOM的交互 </li></ol><h2 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h2><p>核心库必须先引入</p><p>babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></p><p>react下载官网：<a href="http://react-cn.github.io/react/downloads.html">http://react-cn.github.io/react/downloads.html</a></p><p><strong>官方提供的：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 引入react核心库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react@16/umd/react.development.js"</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入babel，用于jsx转为js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/@babel/standalone/babel.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>Staticfile CDN 的 React CDN 库：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>用JSX（JS+XML）创建虚拟DOM</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">"test"</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/babel"</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//创建虚拟DOM,不要写引号</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (</span></span><br><span class="language-javascript"><span class="language-xml">         <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello,react<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">        )</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//渲染虚拟DOM到页面</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'test'</span>))</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><p>用JS创建虚拟DOM</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;<br><span class="hljs-comment">//创建虚拟DOM,不要写引号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'h1'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'title'</span> }, <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, {}, <span class="hljs-string">'hello React'</span>))<br><span class="hljs-comment">//渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'test'</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>可以看出JSX使用就如同写HTML一样方便，但是如果要嵌套多个标签，JS会大量增加重复的代码</p><p>关于虚拟DOM：</p><ol><li>本质是Object对象</li><li>虚拟DOM属性少，真实DOM属性多，因为虚拟DOM是React内部使用，无需那些多余的属性</li><li>虚拟DOM最终会被React转换为真实DOM，呈现在页面上</li></ol><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ol><li><p>定义虚拟DOM时，不要写引号。</p></li><li><p>标签混入JS表达式时用{}。</p></li><li><p>样式类名指定不要用class，用className</p></li><li><p>内联样式，要用style=的形式去写</p></li><li><p>虚拟DOM必须只有一个根标签</p></li><li><p>标签必须闭合</p></li><li><p>标签首字符</p><p>1）若<strong>小写字母</strong>开头，则将标签转为html中<strong>同名元素</strong>，若html中无，则报错</p><p>2）若<strong>大写字母</strong>开头，react渲染<strong>对应的组件</strong>，若组件未定义，则报错</p></li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>JSX使用JavaScript表达式，表达式写在花括号 <strong>{}</strong> 中</p><p>在 JSX 中不能使用 <strong>if else</strong> 语句，但可以使用 <strong>conditional (三元运算)</strong> 表达式来替代。以下实例中如果变量 <strong>i</strong> 等于 <strong>1</strong> 浏览器将输出 <strong>true</strong>, 如果修改 i 的值，则会输出 <strong>false</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{i == 1 ? 'True!' : 'False'}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type="text/babel"&gt;<br>    console.log(this)//此处this是undefined 因为babel编译后开启了严格模式<br>    function MyComponent() {<br>        return &lt;h1&gt;函数定义的组件&lt;/h1&gt;<br>    }<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById("test"))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>执行ReactDOM.render(<mycomponent>…)</mycomponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由函数定义的，随后调用函数，将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;script type="text/babel"&gt;<br>    class MyComponent extends React.Component {<br>        render() {<br>            console.log(this)//MyComponent实例<br>            return &lt;h1&gt;我是类定义的组件&lt;/h1&gt;<br>        }<br>    }<br>    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById("test"))<br>&lt;/script&gt;<br></code></pre></td></tr></tbody></table></figure><p>执行ReactDOM.render(<mycomponent>…)</mycomponent></p><ol><li>React解析组件标签，找到了MyComponent组件</li><li>由于组件是由类定义的，随后new该类的实例，并通过该实例调用到原型上的render方法</li><li>将返回的虚拟DOM转为真实的DOM，呈现在页面中</li></ol><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state是组件对象的重要属性，值是对象（可以包含多个key-value的组合）</p><p>React的组件被看为”状态机“，通过更新组件的state来更新对象对应的页面显示（重新渲染组件，不需要操作DOM）</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>[^自定义function中默认开启了严格模式，所以function中的this为undefined]:</p><ol><li><p>组件中的render方法中的this为实例对象</p></li><li><p>组件自定义的方法中的this为undefined解决方式：</p><ol><li>强制绑定this：通过函数对象的bind(this)</li><li>箭头函数</li></ol></li><li><p>状态数据，不能直接修改或者更新</p></li></ol><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>state 和 props 主要的区别在于 <strong>props</strong> 是不可变的，而 state 可以根据与用户交互来改变。 state 来更新和修改数据，子组件只能通过 props 来传递数据。</p></body></html>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C算法记录</title>
    <link href="/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/zhouyuchen/2022/12/08/C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="C算法记录"><a href="#C算法记录" class="headerlink" title="C算法记录"></a>C算法记录</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>{<br>    <span class="hljs-comment">//定义一个静态的全局变量，用于存放数组下标，大小为2</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> res[<span class="hljs-number">2</span>]={<span class="hljs-number">0</span>};<span class="hljs-comment">//int *res=(int*)malloc(sizeof(int)*2);</span><br>    <span class="hljs-comment">//返回值大小</span><br>    *returnSize=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//暴力遍历所有方法，默认为有解，i只需遍历到数组倒数第二个值，j跟随i的变化而变化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++){<br>            <span class="hljs-comment">//将每一种可能与target比较</span><br>            <span class="hljs-keyword">if</span>(*(nums+i)+*(nums+j)==target){<br>                <span class="hljs-comment">//存入res数组中并且返回</span><br>                res[<span class="hljs-number">0</span>]=i;<br>                res[<span class="hljs-number">1</span>]=j;<br>                <span class="hljs-keyword">return</span> res;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>错误记录：</strong></p><p>​    使用int res[2]</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Line <span class="hljs-number">207</span>: Char <span class="hljs-number">3</span>: runtime error: load of null pointer of type <span class="hljs-string">'int'</span> [__Serializer__.c]<br></code></pre></td></tr></tbody></table></figure><p>​    空指针异常</p><p>​    力扣提示Note: The returned array must be malloced, assume caller calls free().</p><p>​    因为函数返回的是指针地址指向函数内的局部变量数组，在函数退出时，数组的存储空间会被销毁，此时去访问该地址就会出现这个错误。</p><p><strong>解决办法：</strong></p><p>​    使用malloc函数，当malloc函数被调用时，它会沿空闲链表寻找一个可以满足需求的内存块，然后把所需大小的内存块分配给用户，剩下的返回到链表上。free函数被调用时，它将释放的内存块连接到空闲链表上。</p><p>​    malloc函数声明：void *malloc (int size)；向系统申请分配size字节的内存空间。</p><p>​    因为malloc返回是void类型指针，因此使用时候要强制转换为int：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *res=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*sizeNums);<br></code></pre></td></tr></tbody></table></figure><p>​    </p></body></html>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExcelReader</title>
    <link href="/zhouyuchen/2022/12/08/ExcelReader/"/>
    <url>/zhouyuchen/2022/12/08/ExcelReader/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="ExcelReader"><a href="#ExcelReader" class="headerlink" title="ExcelReader"></a>ExcelReader</h1><h2 id="用户导入"><a href="#用户导入" class="headerlink" title="用户导入"></a>用户导入</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping("/import")</span><br>        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">imp</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception {<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();<br>                <span class="hljs-type">ExcelReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> ExcelUtil.getReader(inputStream);<br>                <span class="hljs-comment">// 方式1：(推荐) 通过 javabean的方式读取Excel内的对象，但是要求表头必须是英文，跟javabean的属性要对应起来</span><br><span class="hljs-comment">//        List&lt;User&gt; list = reader.readAll(User.class);</span><br><br>                <span class="hljs-comment">// 方式2：忽略表头的中文，直接读取表的内容</span><br>                List&lt;List&lt;Object&gt;&gt; list = reader.read(<span class="hljs-number">1</span>);<br>                List&lt;User&gt; users = CollUtil.newArrayList();<br>                <span class="hljs-keyword">for</span> (List&lt;Object&gt; row : list) {<br>                        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                        user.setUsername(row.get(<span class="hljs-number">0</span>).toString());<br>                        user.setPassword(row.get(<span class="hljs-number">1</span>).toString());<br>                        users.add(user);<br>                }<br>                userService.saveBatch(users);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br></code></pre></td></tr></tbody></table></figure><h2 id="用户导出"><a href="#用户导出" class="headerlink" title="用户导出"></a>用户导出</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping("/export")</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception {<br>        <span class="hljs-comment">// 从数据库查询出所有的数据</span><br>        List&lt;User&gt; list = userService.list();<br>        <span class="hljs-comment">// 通过工具类创建writer 写出到磁盘路径</span><br><span class="hljs-comment">//        ExcelWriter writer = ExcelUtil.getWriter(filesUploadPath + "/用户信息.xlsx");</span><br>        <span class="hljs-comment">// 在内存操作，写出到浏览器</span><br>        <span class="hljs-type">ExcelWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> ExcelUtil.getWriter(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//自定义标题别名</span><br>        writer.addHeaderAlias(<span class="hljs-string">"username"</span>, <span class="hljs-string">"用户名"</span>);<br>        writer.addHeaderAlias(<span class="hljs-string">"password"</span>, <span class="hljs-string">"密码"</span>);<br><br>        <span class="hljs-comment">// 一次性写出list内的对象到excel，使用默认样式，强制输出标题</span><br>        writer.write(list, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 设置浏览器响应的格式</span><br>        response.setContentType(<span class="hljs-string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8"</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> URLEncoder.encode(<span class="hljs-string">"用户信息"</span>, <span class="hljs-string">"UTF-8"</span>);<br>        response.setHeader(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;filename="</span> + fileName + <span class="hljs-string">".xlsx"</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        writer.flush(out, <span class="hljs-literal">true</span>);<br>        out.close();<br>        writer.close(); <br>    }<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExcelReader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-plus</title>
    <link href="/zhouyuchen/2022/12/04/Mybatis-plus/"/>
    <url>/zhouyuchen/2022/12/04/Mybatis-plus/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="Spring-Boot-集成Mybatis-plus"><a href="#Spring-Boot-集成Mybatis-plus" class="headerlink" title="Spring Boot 集成Mybatis-plus"></a>Spring Boot 集成Mybatis-plus</h2><p>在pom.xml引入Mybatis-plus </p><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>创建MybatisPlusConfig （我用的是MySQL数据库）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.guanli.xitong.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan("你的mapper的reference")</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> {<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> {<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<span class="hljs-comment">//使用MySQL</span><br>        <span class="hljs-keyword">return</span> interceptor;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>编写 Mapper 包下的 <code>UserMapper</code>接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; {}<br></code></pre></td></tr></tbody></table></figure><p>即可开始使用</p><p>下面是例子（分页查询）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询 mybatis plus</span><br><span class="hljs-meta">@GetMapping("/")</span><br><span class="hljs-keyword">public</span> IPage&lt;User&gt; <span class="hljs-title function_">findPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Integer pageNum,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> Integer pageSize,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(defaultValue = "")</span> String username,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam</span> (defaultValue = <span class="hljs-string">""</span>)</span>String nikename,<br>                            <span class="hljs-meta">@RequestParam(defaultValue = "")</span> String address) {<br>    IPage&lt;User&gt;page=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum,pageSize);<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">"username"</span>,username);<br>    queryWrapper.like(<span class="hljs-string">"nikename"</span>,nikename);<br>    queryWrapper.like(<span class="hljs-string">"address"</span>,address);<span class="hljs-comment">//通过Mybatis-plus的methods可知自动拼接条件查询</span><br>    <span class="hljs-keyword">return</span> userService.page(page, queryWrapper);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="Mybatis-plus代码生成器"><a href="#Mybatis-plus代码生成器" class="headerlink" title="Mybatis-plus代码生成器"></a>Mybatis-plus代码生成器</h2><h3 id="java-sql-SQLException-No-suitable-driver-found"><a href="#java-sql-SQLException-No-suitable-driver-found" class="headerlink" title="java.sql.SQLException: No suitable driver found"></a>java.sql.SQLException: No suitable driver found</h3><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689644096.jpg"></p><p>原因是因为mysql-connector-java依赖版本太低，或者没有导入，换成高版本即可(我这使用的是8.0.17)</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>还需要导入的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意和你的Mybatis-plus版本号一致--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>完整配置代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>    String url= <span class="hljs-string">"jdbc:mysql://localhost:3306/你的数据库名称?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8"</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">"你的数据库用户名"</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">"你的数据库密码"</span>;<br>    FastAutoGenerator.create(url, username, password)<br>            .globalConfig(builder -&gt; {<br>                builder.author(<span class="hljs-string">"你的名字"</span>) <span class="hljs-comment">// 设置作者</span><br>                        .fileOverride() <span class="hljs-comment">// 覆盖已生成文件</span><br>                        .outputDir(<span class="hljs-string">"...\\java\\"</span>); <span class="hljs-comment">// 指定输出目录</span><br>            })<br>            .packageConfig(builder -&gt; {<br>                builder.parent(<span class="hljs-string">"com.xx.xx"</span>) <span class="hljs-comment">// 设置父包名</span><br>                        .moduleName(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 设置父包模块名 </span><br>                        .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="hljs-string">"...mapper\\"</span>)); <span class="hljs-comment">// 设置mapperXml生成路径 copy mapper reference</span><br>            })<br>            .strategyConfig(builder -&gt; {<br>                builder.entityBuilder().enableLombok();<span class="hljs-comment">//开启Lombok</span><br>                builder.controllerBuilder().enableHyphenStyle()  <span class="hljs-comment">// 开启驼峰转连字符</span><br>                    .enableRestStyle();  <span class="hljs-comment">// 开启生成@RestController 控制器</span><br>                builder.addInclude(<span class="hljs-string">"你的数据库表名"</span>) <span class="hljs-comment">// 设置需要生成的表名</span><br>                        .addTablePrefix(<span class="hljs-string">"t_"</span>, <span class="hljs-string">"b_"</span>); <span class="hljs-comment">// 设置过滤表前缀</span><br>            })<br>            .execute();<br>}<br></code></pre></td></tr></tbody></table></figure><p>配置完后运行main方法即可看到生成的代码框架</p><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689725109.jpg"></p><h3 id="CRUD模板"><a href="#CRUD模板" class="headerlink" title="CRUD模板"></a>CRUD模板</h3><p>在mybatis-plus-generator-版本号.jar（我这里是3.5.1）</p><p><img src="/zhouyuchen/2022/12/04/Mybatis-plus/1675689933873.jpg"></p><p>选择controller.java.vm复制到resource包下的templates中</p><p>导包：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><br><span class="hljs-keyword">import</span> $!{<span class="hljs-keyword">package</span>.Service}.$!{table.serviceName};<br><span class="hljs-keyword">import</span> ${<span class="hljs-keyword">package</span>.Entity}.${entity};<br></code></pre></td></tr></tbody></table></figure><p>在文件最后的end下加入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ${table.serviceName} ${table.entityPath}Service;<br><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ${entity} ${table.entityPath})</span> {<span class="hljs-comment">//保存或者更新</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.saveOrUpdate(${table.entityPath});<br>        }<br><br><span class="hljs-meta">@DeleteMapping("/{id}")</span><br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> {<span class="hljs-comment">//删除</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.removeById(id);<br>        }<br><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> List&lt;${entity}&gt; findAll() {<span class="hljs-comment">//查询所有</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.list();<br>        }<br><br><span class="hljs-meta">@GetMapping("/{id}")</span><br><span class="hljs-keyword">public</span> ${entity} findOne(<span class="hljs-meta">@PathVariable</span> Integer id) {<span class="hljs-comment">//按照ID查询</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.getById(id);<br>        }<br><br><span class="hljs-meta">@GetMapping("/page")</span><br><span class="hljs-keyword">public</span> Page&lt;${entity}&gt; findPage(<span class="hljs-meta">@RequestParam</span> Integer pageNum,<span class="hljs-comment">//分页</span><br><span class="hljs-meta">@RequestParam</span> Integer pageSize) {<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum, pageSize),queryWrapper);<br>        }<br><br><span class="hljs-meta">@PostMapping("/del/batch")</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Integer&gt; ids)</span> {<span class="hljs-comment">//批量删除</span><br>        <span class="hljs-keyword">return</span> ${table.entityPath}Service.removeBatchByIds(ids);<br>        }<br></code></pre></td></tr></tbody></table></figure><p>运行之前的main方法即可生成</p><p>其他模板同理！</p></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot跨域</title>
    <link href="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/"/>
    <url>/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="SpringBoot跨域"><a href="#SpringBoot跨域" class="headerlink" title="SpringBoot跨域"></a>SpringBoot跨域</h1><p>在前端访问后端出现跨域问题时候</p><p><img src="/zhouyuchen/2022/12/02/SpringBoot%E8%B7%A8%E5%9F%9F/image-20230202115339681-16753100243391.png" alt="image-20230202115339681"></p><p>通过创建一个CorsConfig .java配置文件来解决，重启即可跨域访问，前端无需配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<br><span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> {<br><br><span class="hljs-comment">// 当前跨域请求最大有效时长。这里默认1天</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MAX_AGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>    corsConfiguration.addAllowedOrigin(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 1 设置访问源地址，即为前端的地址</span><br>    corsConfiguration.addAllowedHeader(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 2 设置访问源请求头</span><br>    corsConfiguration.addAllowedMethod(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 3 设置访问源请求方法</span><br>    corsConfiguration.setMaxAge(MAX_AGE);<br>    source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, corsConfiguration); <span class="hljs-comment">// 4 对接口配置跨域设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>}<br>}<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git上传仓库</title>
    <link href="/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <url>/zhouyuchen/2022/10/08/Git%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="使用Git上传到码云仓库"><a href="#使用Git上传到码云仓库" class="headerlink" title="使用Git上传到码云仓库"></a>使用Git上传到码云仓库</h1><p>在码云新建仓库后</p><p>在需要上传的文件夹右键点击Git Bush Here</p><p>git init进行初始化</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init <br></code></pre></td></tr></tbody></table></figure><p>点击克隆，复制你仓库的HTTPS路径，输入git remote add origin + 复制路径</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin<br></code></pre></td></tr></tbody></table></figure><p>git pull origin master 命令，将码云上的仓库pull到本地文件夹</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></tbody></table></figure><p>git add . （. 表示所有的）或者 git add + 文件名 ，将文件保存到暂存区</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br></code></pre></td></tr></tbody></table></figure><p>git commit -m “文件描述”</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m<br></code></pre></td></tr></tbody></table></figure><p>git push origin master ，推送到码云仓库</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></tbody></table></figure><p>刷新即可</p></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Git</title>
    <link href="/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/"/>
    <url>/zhouyuchen/2022/10/08/%E4%BA%86%E8%A7%A3Git/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="了解Git"><a href="#了解Git" class="headerlink" title="了解Git"></a>了解Git</h1><p>Git（读音为/gɪt/）是一个开源的<strong>分布式</strong>版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><h2 id="Git和SVN区别"><a href="#Git和SVN区别" class="headerlink" title="Git和SVN区别"></a>Git和SVN区别</h2><ol><li>核心区别：Git是分布式的，SVN不是</li><li>Git按照元数据方式存储，SVN按照文件方式存储</li><li>Git分支有多种使用方法，例如：创建、切换、合并、删除、跟踪等等，SVN仅仅是另一个文件目录</li><li>Git没有全局的版本号，SVN有</li><li>xxxxxxxxxx&nbsp;class Solution { &nbsp; &nbsp;public int lengthOfLongestSubstring(String s) { &nbsp; &nbsp; &nbsp; &nbsp;if (s.length()==0) return 0; &nbsp; &nbsp; &nbsp; &nbsp;HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); &nbsp; &nbsp; &nbsp; &nbsp;int max = 0;//最长子串长度 &nbsp; &nbsp; &nbsp; &nbsp;int left = 0;//滑动窗口左下标，i相当于滑动窗口右下标 &nbsp; &nbsp; &nbsp; &nbsp;for(int i = 0; i &lt; s.length(); i ++){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(map.containsKey(s.charAt(i))){//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left = Math.max(left,map.get(s.charAt(i)) + 1); &nbsp; &nbsp; &nbsp; //map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;//map.get(‘a’)=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;map.put(s.charAt(i),i); &nbsp; &nbsp; &nbsp;//再更新map中a映射的下标 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max = Math.max(max,i-left+1); &nbsp; &nbsp; //比较两个参数的大小 &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;return max; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }}java </li></ol><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。 </li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h2 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h2><p>工作区：你电脑看到的目录</p><p>暂存区：一般存放在.git/index，所以又称为索引（index或者stage）</p><p>版本库：隐藏的.git目录</p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>分支意味着从开发主线分离出来，而且在不影响主线的情况下同时继续工作</p><p>Git分支分支实际上是指向更改快照的指针</p><p>创建分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch (branchname)<br></code></pre></td></tr></tbody></table></figure><p>切换分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (branchname)<br></code></pre></td></tr></tbody></table></figure><p>合并分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge <br></code></pre></td></tr></tbody></table></figure><p>列出分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></tbody></table></figure><p>创建分支并且切换到该分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b (branchname)<br></code></pre></td></tr></tbody></table></figure><p>删除分支：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (branchname)<br></code></pre></td></tr></tbody></table></figure><p>如果合并发现冲突需要手动修改</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add<br>git commit<br></code></pre></td></tr></tbody></table></figure><h2 id="Git查看提交历史"><a href="#Git查看提交历史" class="headerlink" title="Git查看提交历史"></a>Git查看提交历史</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log //查看历史提交记录<br>git log --oneline //查看历史记录的简洁的版本<br>git log --graph //查看历史中什么时候出现了分支、合并<br>git log --reverse --oneline //逆向显示所有日志<br>git log --author //查找指定用户的提交日志<br>git blame &lt;file&gt; //以列表的形式查看指定文件的历史修改记录<br></code></pre></td></tr></tbody></table></figure><h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><p>为什么要使用标签，直接commit不好吗？</p><p>标签即为版本库的一个快照，通过添加标签，可以更加方便查找到版本号：</p><p>commit号可能是51234c…</p><p>标签可以是v1.0</p><p>当达到一个重要阶段，并且希望更加方便记住这个提交，可以使用：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v1.0 //-a意为创建一个带有注解的标签，可以不加<br></code></pre></td></tr></tbody></table></figure><p>查看已有标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag<br></code></pre></td></tr></tbody></table></figure><p>删除标签：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d 版本号<br></code></pre></td></tr></tbody></table></figure><p>查看该标签修改的内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git show 版本号<br></code></pre></td></tr></tbody></table></figure><h2 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h2><p>这是一个Git的图形界面工具（GUI），SourceTree 简化了开发者与代码仓库之间的 Git 操作方式，我们可以通过界面菜单很方便的处理 Git 操作，而不需要通过命令。</p><p>可以在 Sourcetree 官网 <a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a> 直接点击下载按钮来下载，根据提示安装。</p></body></html>]]></content>
    
    
    <categories>
      
      <category>其他工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>了解Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣</title>
    <link href="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/"/>
    <url>/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160612408.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160645305.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160658443.png"></p><p><img src="/zhouyuchen/2022/01/02/%E5%8A%9B%E6%89%A3/image-20201105160719623.png"></p><p>主要是先建立2个指针，一个指针移动，一个指针返回值，通过carry表示进位，如果为1就进位，如果为0就直接返回。</p><h2 id="指针滑动窗口"><a href="#指针滑动窗口" class="headerlink" title="指针滑动窗口"></a>指针滑动窗口</h2><p>java的方法：</p><ul><li>```java<br>string.charAt(i)<br>//用于返回string字符串i位置的字符HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()<br>map.put(“key”,1)<br>string key=”apple”<br>boolean contains=map.containsKey(key)<br>//用于比较key值是否包含指定的值<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```java <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<span class="hljs-comment">//最长子串长度</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左下标，i相当于滑动窗口右下标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++){<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">containsKey</span>(s.<span class="hljs-built_in">charAt</span>(i))){<span class="hljs-comment">//charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</span><br>                left = Math.<span class="hljs-built_in">max</span>(left,map.<span class="hljs-built_in">get</span>(s.<span class="hljs-built_in">charAt</span>(i)) + <span class="hljs-number">1</span>);       <span class="hljs-comment">//map.get():返回字符所对应的索引，当发现重复元素时，窗口左指针右移</span><br>            }        <span class="hljs-comment">//map.get('a')=0,因为map中只有第一个a的下标，然后更新left指针到原来left的的下一位</span><br>            map.<span class="hljs-built_in">put</span>(s.<span class="hljs-built_in">charAt</span>(i),i);      <span class="hljs-comment">//再更新map中a映射的下标</span><br>            max = Math.<span class="hljs-built_in">max</span>(max,i-left+<span class="hljs-number">1</span>);     <span class="hljs-comment">//比较两个参数的大小</span><br>        }<br>        <span class="hljs-keyword">return</span> max;<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></body></html>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装</title>
    <link href="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/"/>
    <url>/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h1><p>由于node版本太低，记录一下更新node</p><p>node中文下载地址：：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/12.jpg"></p><p>对应电脑系统选择（windows）</p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/1673433881757.jpg"></p><p>通过</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">where node<br></code></pre></td></tr></tbody></table></figure><p>查看自己node安装位置</p><p><img src="/zhouyuchen/2021/12/11/node%E5%AE%89%E8%A3%85/1673434014083.jpg"></p><p>将文件内容全部替换为压缩包内容即可</p><p>查看是否成功：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
